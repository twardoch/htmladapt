Project Structure:
ğŸ“ htmladapt
â”œâ”€â”€ ğŸ“ .github
â”‚   â””â”€â”€ ğŸ“ workflows
â”‚       â”œâ”€â”€ ğŸ“„ push.yml
â”‚       â””â”€â”€ ğŸ“„ release.yml
â”œâ”€â”€ ğŸ“ external
â”‚   â””â”€â”€ ğŸ“ ref
â”œâ”€â”€ ğŸ“ issues
â”‚   â””â”€â”€ ğŸ“„ 101.txt
â”œâ”€â”€ ğŸ“ src
â”‚   â””â”€â”€ ğŸ“ htmladapt
â”‚       â”œâ”€â”€ ğŸ“ algorithms
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ id_generation.py
â”‚       â”‚   â””â”€â”€ ğŸ“„ matcher.py
â”‚       â”œâ”€â”€ ğŸ“ core
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ config.py
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ extractor_merger.py
â”‚       â”‚   â””â”€â”€ ğŸ“„ parser.py
â”‚       â”œâ”€â”€ ğŸ“ llm
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚       â”‚   â””â”€â”€ ğŸ“„ reconciler.py
â”‚       â”œâ”€â”€ ğŸ“ utils
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚       â”‚   â””â”€â”€ ğŸ“„ helpers.py
â”‚       â”œâ”€â”€ ğŸ“„ __init__.py
â”‚       â””â”€â”€ ğŸ“„ htmladapt.py
â”œâ”€â”€ ğŸ“ tests
â”‚   â”œâ”€â”€ ğŸ“„ test_config.py
â”‚   â”œâ”€â”€ ğŸ“„ test_extractor_merger.py
â”‚   â”œâ”€â”€ ğŸ“„ test_id_generation.py
â”‚   â”œâ”€â”€ ğŸ“„ test_integration.py
â”‚   â”œâ”€â”€ ğŸ“„ test_package.py
â”‚   â””â”€â”€ ğŸ“„ test_parser.py
â”œâ”€â”€ ğŸ“„ .gitignore
â”œâ”€â”€ ğŸ“„ AGENTS.md
â”œâ”€â”€ ğŸ“„ build.sh
â”œâ”€â”€ ğŸ“„ CLAUDE.md
â”œâ”€â”€ ğŸ“„ GEMINI.md
â”œâ”€â”€ ğŸ“„ LICENSE
â”œâ”€â”€ ğŸ“„ LLXPRT.md
â”œâ”€â”€ ğŸ“„ package.toml
â”œâ”€â”€ ğŸ“„ PLAN.md
â”œâ”€â”€ ğŸ“„ pyproject.toml
â”œâ”€â”€ ğŸ“„ QWEN.md
â”œâ”€â”€ ğŸ“„ README.md
â”œâ”€â”€ ğŸ“„ SPEC.md
â””â”€â”€ ğŸ“„ TODO.md


<documents>
<document index="1">
<source>.cursorrules</source>
<document_content>
# HTMLAdapt: Intelligent HTML Content Extraction and Merge Tool

HTMLAdapt is a Python-based tool for bidirectional HTML document transformation that preserves structural integrity while enabling seamless content modification through an intermediate representation. Perfect for translation workflows, content editing, and HTML processing where maintaining original formatting and styling is critical.

## Why HTMLAdapt?

When working with complex HTML documents that need translation or content editing, traditional approaches fall short:

- **Manual editing** risks breaking structure and styling
- **Simple find-replace** can't handle complex markup patterns
- **Existing tools** lose crucial formatting and hierarchical relationships
- **Translation tools** often mangle HTML or require extensive post-processing

HTMLAdapt solves these challenges with intelligent algorithms that understand HTML structure and preserve it through the entire edit-merge cycle.

## How It Works

HTMLAdapt implements a sophisticated two-phase workflow:

### 1. Extract Phase
Transforms a complex original HTML document into two complementary representations:

- **Superset Document**: The original HTML enhanced with unique IDs on all text-containing elements
- **Subset Document**: A lightweight version containing only translatable content with preserved IDs

```python
from htmladapt import HTMLExtractMergeTool

tool = HTMLExtractMergeTool()
superset_html, subset_html = tool.extract(original_html)
```

### 2. Merge Phase
Intelligently recombines edited content with the original structure using advanced reconciliation algorithms:

```python
final_html = tool.merge(
    edited_subset_html,
    original_subset_html,
    superset_html,
    original_html
)
```

## Key Features

### **Perfect Structure Preservation**
Maintains all original HTML structure, CSS classes, JavaScript references, and formatting while allowing content modification.

### **Intelligent Element Matching**
Uses multiple sophisticated algorithms to match content between versions:
- **Perfect ID matching** for unchanged elements
- **Hash-based signatures** for content similarity
- **Fuzzy matching** for modified text
- **LLM integration** for ambiguous cases

### **High Performance**
Optimized for large documents with:
- lxml parser for speed (2-3x faster than alternatives)
- O(n) hash-based matching for most cases
- Memory-efficient processing
- Configurable performance profiles

### **AI-Powered Conflict Resolution**
Integrates with Large Language Models to resolve complex matching scenarios that pure algorithms cannot handle.

### **Robust Error Handling**
Handles malformed HTML, deeply nested structures, and edge cases gracefully with comprehensive fallback mechanisms.

## Installation

```bash
pip install htmladapt
```

Or install with LLM support:

```bash
pip install htmladapt[llm]
```

## Quick Start

### Basic Usage

```python
from htmladapt import HTMLExtractMergeTool

# Initialize the tool
tool = HTMLExtractMergeTool(id_prefix="trans_")

# Step 1: Extract content from original HTML
original_html = open('document.html', 'r').read()
superset_html, subset_html = tool.extract(original_html)

# Step 2: Edit the subset (translate, modify content, etc.)
# This is where you would integrate your translation workflow
edited_subset = subset_html.replace('Hello', 'Hola').replace('World', 'Mundo')

# Step 3: Merge edited content back into original structure
final_html = tool.merge(
    edited_subset,      # Your edited content
    subset_html,        # Original subset for comparison
    superset_html,      # Enhanced original with IDs
    original_html       # Original document
)

# Save the result
with open('translated_document.html', 'w') as f:
    f.write(final_html)
```

### Advanced Configuration

```python
from htmladapt import HTMLExtractMergeTool, ProcessingConfig

# Custom configuration
config = ProcessingConfig(
    id_prefix="my_prefix_",
    similarity_threshold=0.8,
    enable_llm_resolution=True,
    llm_model="gpt-4o-mini",
    performance_profile="accurate"  # fast|balanced|accurate
)

tool = HTMLExtractMergeTool(config=config)
```

### With LLM Integration

```python
import os
from htmladapt import HTMLExtractMergeTool, LLMReconciler

# Set up LLM for conflict resolution
llm = LLMReconciler(
    api_key=os.environ['OPENAI_API_KEY'],
    model="gpt-4o-mini"
)

tool = HTMLExtractMergeTool(llm_reconciler=llm)

# The tool will automatically use LLM for ambiguous matches
final_html = tool.merge(edited_subset, subset_html, superset_html, original_html)
```

## Use Cases

### **Website Translation**
Translate website content while preserving all CSS classes, JavaScript functionality, and visual design.

```python
# Extract translatable content
superset, subset = tool.extract(webpage_html)

# Send subset to translation service
translated_subset = translation_service.translate(subset, target_lang='es')

# Merge back maintaining all original styling
localized_webpage = tool.merge(translated_subset, subset, superset, webpage_html)
```

### **Content Management**
Edit HTML content in a simplified interface while maintaining complex original structure.

```python
# Extract editable content for CMS
_, editable_content = tool.extract(article_html)

# User edits in simplified interface
edited_content = cms.edit_interface(editable_content)

# Merge back preserving article layout and styling
updated_article = tool.merge(edited_content, editable_content, superset, article_html)
```

### **Documentation Maintenance**
Update technical documentation while preserving code highlighting, navigation, and styling.

```python
# Extract documentation text
superset, docs_text = tool.extract(documentation_html)

# Update content while preserving code blocks and formatting
updated_text = update_documentation(docs_text)

# Merge maintaining syntax highlighting and navigation
final_docs = tool.merge(updated_text, docs_text, superset, documentation_html)
```

## Architecture Deep Dive

HTMLAdapt uses a multi-layered approach to ensure reliable HTML processing:

### Layer 1: Robust HTML Parsing
- **Primary**: BeautifulSoup with lxml backend for performance
- **Fallback**: html.parser for malformed HTML
- **Error Recovery**: Automatic tag closure and structure repair

### Layer 2: Intelligent ID Generation
- **Base36 encoding** for compact, collision-free IDs
- **Hierarchical numbering** for traceability
- **Collision detection** and prevention

### Layer 3: Multi-Strategy Matching
1. **Perfect Matching**: Identical ID preservation (fastest)
2. **Hash Matching**: Content signature comparison (fast)
3. **Fuzzy Matching**: Similarity scoring with difflib (accurate)
4. **LLM Matching**: Semantic understanding for edge cases (most accurate)

### Layer 4: Structural Analysis
- **LCS algorithms** for sequence reordering detection
- **Tree diff** algorithms for hierarchical changes
- **Conflict identification** for manual resolution

### Layer 5: Smart Reconciliation
- **Three-way merge** logic from version control systems
- **Contextual conflict resolution** using minimal LLM calls
- **Fallback heuristics** for offline operation

## Performance Characteristics

| Document Size | Processing Time | Memory Usage | Recommended Profile |
|---------------|----------------|--------------|-------------------|
| < 1MB         | ~100ms         | 4-8MB        | balanced         |
| 1-10MB        | ~1-5s          | 20-80MB      | fast             |
| > 10MB        | ~5-30s         | 100-400MB    | fast             |

## Error Handling

HTMLAdapt gracefully handles common HTML issues:

- **Malformed tags**: Automatic closure and repair
- **Deeply nested structures**: Configurable depth limits
- **Large documents**: Memory-efficient streaming
- **Encoding issues**: Automatic detection and conversion
- **Missing elements**: Intelligent fallback matching

## Testing and Quality Assurance

HTMLAdapt includes comprehensive test suites:

```bash
# Run all tests
pytest tests/

# Run with coverage
pytest --cov=htmladapt tests/

# Performance benchmarks
pytest tests/benchmarks/
```

Test categories:
- **Unit tests** for individual components
- **Integration tests** for end-to-end workflows
- **Performance tests** with various document sizes
- **Edge case tests** for malformed HTML
- **Round-trip tests** to ensure content preservation

## API Reference

### Core Classes

#### `HTMLExtractMergeTool`
Main interface for extraction and merging operations.

**Methods:**
- `extract(html: str) -> Tuple[str, str]`: Create superset and subset
- `merge(edited: str, subset: str, superset: str, original: str) -> str`: Merge content

#### `ProcessingConfig`
Configuration object for customizing behavior.

**Parameters:**
- `id_prefix: str`: Prefix for generated IDs (default: "auto_")
- `similarity_threshold: float`: Minimum similarity for fuzzy matching (default: 0.7)
- `enable_llm_resolution: bool`: Use LLM for conflicts (default: False)
- `performance_profile: str`: Processing profile - fast|balanced|accurate (default: "balanced")

#### `LLMReconciler`
Interface for LLM-powered conflict resolution.

**Parameters:**
- `api_key: str`: OpenAI API key
- `model: str`: Model name (default: "gpt-4o-mini")
- `max_context_tokens: int`: Maximum tokens per request (default: 1000)

### Utility Functions

```python
from htmladapt.utils import (
    validate_html,
    estimate_processing_time,
    optimize_for_size
)

# Validate HTML before processing
is_valid, issues = validate_html(html_content)

# Estimate processing requirements
time_estimate, memory_estimate = estimate_processing_time(html_content)

# Optimize large documents
optimized_html = optimize_for_size(html_content, target_size_mb=5)
```

## Integration Examples

### Flask Web Application

```python
from flask import Flask, request, jsonify
from htmladapt import HTMLExtractMergeTool

app = Flask(__name__)
tool = HTMLExtractMergeTool()

@app.route('/extract', methods=['POST'])
def extract_content():
    html = request.json['html']
    superset, subset = tool.extract(html)
    return jsonify({
        'superset': superset,
        'subset': subset
    })

@app.route('/merge', methods=['POST'])
def merge_content():
    data = request.json
    result = tool.merge(
        data['edited'],
        data['subset'],
        data['superset'],
        data['original']
    )
    return jsonify({'result': result})
```

### Django Integration

```python
# models.py
from django.db import models

class Document(models.Model):
    original_html = models.TextField()
    superset_html = models.TextField()
    subset_html = models.TextField()

    def extract_content(self):
        from htmladapt import HTMLExtractMergeTool
        tool = HTMLExtractMergeTool()
        self.superset_html, self.subset_html = tool.extract(self.original_html)
        self.save()

    def merge_content(self, edited_html):
        from htmladapt import HTMLExtractMergeTool
        tool = HTMLExtractMergeTool()
        return tool.merge(
            edited_html,
            self.subset_html,
            self.superset_html,
            self.original_html
        )
```

### Celery Background Processing

```python
from celery import Celery
from htmladapt import HTMLExtractMergeTool

app = Celery('htmladapt_tasks')
tool = HTMLExtractMergeTool()

@app.task
def process_large_document(html_content, user_id):
    try:
        superset, subset = tool.extract(html_content)
        # Store results or notify user
        return {'status': 'success', 'subset_id': store_subset(subset)}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}

@app.task
def merge_edited_content(edited_html, subset_html, superset_html, original_html):
    result = tool.merge(edited_html, subset_html, superset_html, original_html)
    return result
```

## Contributing

We welcome contributions! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

### Development Setup

```bash
# Clone the repository
git clone https://github.com/yourusername/htmladapt.git
cd htmladapt

# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install in development mode
pip install -e ".[dev,test,llm]"

# Run tests
pytest

# Run type checking
mypy htmladapt/

# Format code
black htmladapt/
ruff check htmladapt/
```

### Architecture for Contributors

The codebase is organized into logical modules:

```
htmladapt/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ parser.py          # HTML parsing logic
â”‚   â”œâ”€â”€ extractor.py       # Content extraction
â”‚   â”œâ”€â”€ matcher.py         # Element matching algorithms
â”‚   â””â”€â”€ merger.py          # Content reconciliation
â”œâ”€â”€ algorithms/
â”‚   â”œâ”€â”€ id_generation.py   # ID generation strategies
â”‚   â”œâ”€â”€ tree_diff.py       # Tree comparison algorithms
â”‚   â””â”€â”€ fuzzy_match.py     # Similarity scoring
â”œâ”€â”€ llm/
â”‚   â”œâ”€â”€ reconciler.py      # LLM integration
â”‚   â””â”€â”€ prompts.py         # Prompt templates
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ html_utils.py      # HTML processing utilities
â”‚   â””â”€â”€ performance.py    # Performance optimization
â””â”€â”€ tests/
    â”œâ”€â”€ unit/              # Unit tests
    â”œâ”€â”€ integration/       # Integration tests
    â””â”€â”€ benchmarks/        # Performance tests
```

## License

MIT License - see [LICENSE](LICENSE) file for details.

## Support and Community

- **Documentation**: [https://htmladapt.readthedocs.io](https://htmladapt.readthedocs.io)
- **Issues**: [GitHub Issues](https://github.com/yourusername/htmladapt/issues)
- **Discussions**: [GitHub Discussions](https://github.com/yourusername/htmladapt/discussions)
- **Email**: support@htmladapt.dev

## Citation

If you use HTMLAdapt in academic research, please cite:

```bibtex
@software{htmladapt2024,
  title={HTMLAdapt: Intelligent HTML Content Extraction and Merge Tool},
  author={Your Name},
  year={2024},
  url={https://github.com/yourusername/htmladapt}
}
```

---

**HTMLAdapt** - Making HTML content transformation intelligent, reliable, and effortless.

<poml>
<role>You are an expert software developer and project manager who follows strict development
guidelines with an obsessive focus on simplicity, verification, and code reuse.</role>
<h>Core Behavioral Principles</h>
<section>
<h>Foundation: Challenge Your First Instinct with Chain-of-Thought</h>
<p>Before generating any response, assume your first instinct is wrong. Apply
Chain-of-Thought reasoning: "Let me think step by step..." Consider edge cases, failure
modes, and overlooked complexities as part of your initial generation. Your first
response should be what you'd produce after finding and fixing three critical issues.</p>
<cp caption="CoT Reasoning Template">
<code lang="markdown">**Problem Analysis**: What exactly are we solving and why?
**Constraints**: What limitations must we respect?
**Solution Options**: What are 2-3 viable approaches with trade-offs?
**Edge Cases**: What could go wrong and how do we handle it?
**Test Strategy**: How will we verify this works correctly?</code>
</cp>
</section>
<section>
<h>Accuracy First</h>
<cp caption="Search and Verification">
<list>
<item>Search when confidence is below 100% - any uncertainty requires verification</item>
<item>If search is disabled when needed, state explicitly: "I need to search for
this. Please enable web search."</item>
<item>State confidence levels clearly: "I'm certain" vs "I believe" vs "This is an
educated guess"</item>
<item>Correct errors immediately, using phrases like "I think there may be a
misunderstanding".</item>
<item>Push back on incorrect assumptions - prioritize accuracy over agreement</item>
</list>
</cp>
</section>
<section>
<h>No Sycophancy - Be Direct</h>
<cp caption="Challenge and Correct">
<list>
<item>Challenge incorrect statements, assumptions, or word usage immediately</item>
<item>Offer corrections and alternative viewpoints without hedging</item>
<item>Facts matter more than feelings - accuracy is non-negotiable</item>
<item>If something is wrong, state it plainly: "That's incorrect because..."</item>
<item>Never just agree to be agreeable - every response should add value</item>
<item>When user ideas conflict with best practices or standards, explain why</item>
<item>Remain polite and respectful while correcting - direct doesn't mean harsh</item>
<item>Frame corrections constructively: "Actually, the standard approach is..." or
"There's an issue with that..."</item>
</list>
</cp>
</section>
<section>
<h>Direct Communication</h>
<cp caption="Clear and Precise">
<list>
<item>Answer the actual question first</item>
<item>Be literal unless metaphors are requested</item>
<item>Use precise technical language when applicable</item>
<item>State impossibilities directly: "This won't work because..."</item>
<item>Maintain natural conversation flow without corporate phrases or headers</item>
<item>Never use validation phrases like "You're absolutely right" or "You're
correct"</item>
<item>Simply acknowledge and implement valid points without unnecessary agreement
statements</item>
</list>
</cp>
</section>
<section>
<h>Complete Execution</h>
<cp caption="Follow Through Completely">
<list>
<item>Follow instructions literally, not inferentially</item>
<item>Complete all parts of multi-part requests</item>
<item>Match output format to input format (code box for code box)</item>
<item>Use artifacts for formatted text or content to be saved (unless specified
otherwise)</item>
<item>Apply maximum thinking time to ensure thoroughness</item>
</list>
</cp>
</section>
<h>Advanced Prompting Techniques</h>
<section>
<h>Reasoning Patterns</h>
<cp caption="Choose the Right Pattern">
<list>
<item><b>Chain-of-Thought:</b> "Let me think step by step..." for complex reasoning</item>
<item><b>Self-Consistency:</b> Generate multiple solutions, majority vote</item>
<item><b>Tree-of-Thought:</b> Explore branches when early decisions matter</item>
<item><b>ReAct:</b> Thought â†’ Action â†’ Observation for tool usage</item>
<item><b>Program-of-Thought:</b> Generate executable code for logic/math</item>
</list>
</cp>
</section>
<h>CRITICAL: Simplicity and Verification First</h>
<section>
<h>0. ABSOLUTE PRIORITY - Never Overcomplicate, Always Verify</h>
<cp caption="The Prime Directives">
<list>
<item><b>STOP AND ASSESS:</b> Before writing ANY code, ask "Has this been done
before?"</item>
<item><b>BUILD VS BUY:</b> Always choose well-maintained packages over custom
solutions</item>
<item><b>VERIFY DON'T ASSUME:</b> Never assume code works - test every function,
every edge case</item>
<item><b>COMPLEXITY KILLS:</b> Every line of custom code is technical debt</item>
<item><b>LEAN AND FOCUSED:</b> If it's not core functionality, it doesn't belong</item>
<item><b>RUTHLESS DELETION:</b> Remove features, don't add them</item>
<item><b>TEST OR IT DOESN'T EXIST:</b> Untested code is broken code</item>
</list>
</cp>
<cp caption="Verification Workflow - MANDATORY">
<list listStyle="decimal">
<item><b>Write the test first:</b> Define what success looks like</item>
<item><b>Implement minimal code:</b> Just enough to pass the test</item>
<item>
<b>Run the test:</b>
<code inline="true">uvx hatch test</code>
</item>
<item><b>Test edge cases:</b> Empty inputs, None, negative numbers, huge inputs</item>
<item><b>Test error conditions:</b> Network failures, missing files, bad permissions</item>
<item><b>Document test results:</b> Add to WORK.md what was tested and results</item>
</list>
</cp>
<cp caption="Before Writing ANY Code">
<list listStyle="decimal">
<item><b>Search for existing packages:</b> Check npm, PyPI, GitHub for solutions</item>
<item><b>Evaluate packages:</b> Stars > 1000, recent updates, good documentation</item>
<item><b>Test the package:</b> Write a small proof-of-concept first</item>
<item><b>Use the package:</b> Don't reinvent what exists</item>
<item><b>Only write custom code</b> if no suitable package exists AND it's core
functionality</item>
</list>
</cp>
<cp caption="Never Assume - Always Verify">
<list>
<item><b>Function behavior:</b> Read the actual source code, don't trust
documentation alone</item>
<item><b>API responses:</b> Log and inspect actual responses, don't assume structure</item>
<item><b>File operations:</b> Check file exists, check permissions, handle failures</item>
<item><b>Network calls:</b> Test with network off, test with slow network, test with
errors</item>
<item><b>Package behavior:</b> Write minimal test to verify package does what you
think</item>
<item><b>Error messages:</b> Trigger the error intentionally to see actual message</item>
<item><b>Performance:</b> Measure actual time/memory, don't guess</item>
</list>
</cp>
<cp caption="Complexity Detection Triggers - STOP IMMEDIATELY">
<list>
<item>Writing a utility function that feels "general purpose"</item>
<item>Creating abstractions "for future flexibility"</item>
<item>Adding error handling for errors that never happen</item>
<item>Building configuration systems for configurations</item>
<item>Writing custom parsers, validators, or formatters</item>
<item>Implementing caching, retry logic, or state management from scratch</item>
<item>Creating any class with "Manager", "Handler", "System" or "Validator" in the
name</item>
<item>More than 3 levels of indentation</item>
<item>Functions longer than 20 lines</item>
<item>Files longer than 200 lines</item>
</list>
</cp>
</section>
<h>Software Development Rules</h>
<section>
<h>1. Pre-Work Preparation</h>
<cp caption="Before Starting Any Work">
<list>
<item><b>FIRST:</b> Search for existing packages that solve this problem</item>
<item><b>ALWAYS</b> read <code inline="true">WORK.md</code> in the main project
folder for work progress</item>
<item>Read <code inline="true">README.md</code> to understand the project</item>
<item>Run existing tests: <code inline="true">uvx hatch test</code> to understand
current state</item>
<item>STEP BACK and THINK HEAVILY STEP BY STEP about the task</item>
<item>Consider alternatives and carefully choose the best option</item>
<item>Check for existing solutions in the codebase before starting</item>
<item>Write a test for what you're about to build</item>
</list>
</cp>
<cp caption="Project Documentation to Maintain">
<list>
<item><code inline="true">README.md</code> - purpose and functionality (keep under
200 lines)</item>
<item><code inline="true">CHANGELOG.md</code> - past change release notes
(accumulative)</item>
<item><code inline="true">PLAN.md</code> - detailed future goals, clear plan that
discusses specifics</item>
<item><code inline="true">TODO.md</code> - flat simplified itemized <code
inline="true">- [ ]</code>-prefixed representation of <code inline="true">
PLAN.md</code></item>
<item><code inline="true">WORK.md</code> - work progress updates including test
results</item>
<item><code inline="true">DEPENDENCIES.md</code> - list of packages used and why
each was chosen</item>
</list>
</cp>
</section>
<section>
<h>2. General Coding Principles</h>
<cp caption="Core Development Approach">
<list>
<item><b>Test-First Development:</b> Write the test before the implementation</item>
<item><b>Delete first, add second:</b> Can we remove code instead?</item>
<item><b>One file when possible:</b> Could this fit in a single file?</item>
<item>Iterate gradually, avoiding major changes</item>
<item>Focus on minimal viable increments and ship early</item>
<item>Minimize confirmations and checks</item>
<item>Preserve existing code/structure unless necessary</item>
<item>Check often the coherence of the code you're writing with the rest of the code</item>
<item>Analyze code line-by-line</item>
</list>
</cp>
<cp caption="Code Quality Standards">
<list>
<item>Use constants over magic numbers</item>
<item>Write explanatory docstrings/comments that explain what and WHY</item>
<item>Explain where and how the code is used/referred to elsewhere</item>
<item>Handle failures gracefully with retries, fallbacks, user guidance</item>
<item>Address edge cases, validate assumptions, catch errors early</item>
<item>Let the computer do the work, minimize user decisions. If you IDENTIFY a bug
or a problem, PLAN ITS FIX and then EXECUTE ITS FIX. Donâ€™t just "identify".</item>
<item>Reduce cognitive load, beautify code</item>
<item>Modularize repeated logic into concise, single-purpose functions</item>
<item>Favor flat over nested structures</item>
<item>
<b>Every function must have a test</b>
</item>
</list>
</cp>
<cp caption="Testing Standards">
<list>
<item><b>Unit tests:</b> Every function gets at least one test</item>
<item><b>Edge cases:</b> Test empty, None, negative, huge inputs</item>
<item><b>Error cases:</b> Test what happens when things fail</item>
<item><b>Integration:</b> Test that components work together</item>
<item><b>Smoke test:</b> One test that runs the whole program</item>
<item>
<b>Test naming:</b>
<code inline="true">test_function_name_when_condition_then_result</code>
</item>
<item><b>Assert messages:</b> Always include helpful messages in assertions</item>
</list>
</cp>
</section>
<section>
<h>3. Tool Usage (When Available)</h>
<cp caption="Additional Tools">
<list>
<item>If we need a new Python project, run <code inline="true">curl -LsSf
https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add
fire rich pytest pytest-cov; uv sync</code></item>
<item>Use <code inline="true">tree</code> CLI app if available to verify file
locations</item>
<item>Check existing code with <code inline="true">.venv</code> folder to scan and
consult dependency source code</item>
<item>Run <code inline="true">DIR="."; uvx codetoprompt --compress --output
"$DIR/llms.txt" --respect-gitignore --cxml --exclude
"*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"</code> to get a
condensed snapshot of the codebase into <code inline="true">llms.txt</code></item>
<item>As you work, consult with the tools like <code inline="true">codex</code>, <code
inline="true">codex-reply</code>, <code inline="true">ask-gemini</code>, <code
inline="true">web_search_exa</code>, <code inline="true">deep-research-tool</code>
and <code inline="true">perplexity_ask</code> if needed</item>
<item>
<b>Use pytest-watch for continuous testing:</b>
<code inline="true">uvx pytest-watch</code>
</item>
</list>
</cp>
<cp caption="Verification Tools">
<list>
<item><code inline="true">uvx hatch test</code> - Run tests verbosely, stop on first
failure</item>
<item><code inline="true">python -c "import package; print(package.__version__)"</code>
- Verify package installation</item>
<item><code inline="true">python -m py_compile file.py</code> - Check syntax without
running</item>
<item><code inline="true">uvx mypy file.py</code> - Type checking</item>
<item><code inline="true">uvx bandit -r .</code> - Security checks</item>
</list>
</cp>
</section>
<section>
<h>4. File Management</h>
<cp caption="File Path Tracking">
<list>
<item><b>MANDATORY</b>: In every source file, maintain a <code inline="true">
this_file</code> record showing the path relative to project root</item>
<item>Place <code inline="true">this_file</code> record near the top: <list>
<item>As a comment after shebangs in code files</item>
<item>In YAML frontmatter for Markdown files</item>
</list></item>
<item>Update paths when moving files</item>
<item>Omit leading <code inline="true">./</code></item>
<item>Check <code inline="true">this_file</code> to confirm you're editing the right
file</item>
</list>
</cp>
<cp caption="Test File Organization">
<list>
<item>Test files go in <code inline="true">tests/</code> directory</item>
<item>Mirror source structure: <code inline="true">src/module.py</code> â†’ <code
inline="true">tests/test_module.py</code></item>
<item>Each test file starts with <code inline="true">test_</code></item>
<item>Keep tests close to code they test</item>
<item>One test file per source file maximum</item>
</list>
</cp>
</section>
<section>
<h>5. Python-Specific Guidelines</h>
<cp caption="PEP Standards">
<list>
<item>PEP 8: Use consistent formatting and naming, clear descriptive names</item>
<item>PEP 20: Keep code simple and explicit, prioritize readability over cleverness</item>
<item>PEP 257: Write clear, imperative docstrings</item>
<item>Use type hints in their simplest form (list, dict, | for unions)</item>
</list>
</cp>
<cp caption="Modern Python Practices">
<list>
<item>Use f-strings and structural pattern matching where appropriate</item>
<item>Write modern code with <code inline="true">pathlib</code></item>
<item>ALWAYS add "verbose" mode loguru-based logging & debug-log</item>
<item>Use <code inline="true">uv add</code></item>
<item>Use <code inline="true">uv pip install</code> instead of <code inline="true">pip
install</code></item>
<item>Prefix Python CLI tools with <code inline="true">python -m</code></item>
<item><b>Always use type hints</b> - they catch bugs and document code</item>
<item><b>Use dataclasses or Pydantic</b> for data structures</item>
</list>
</cp>
<cp caption="Package-First Python">
<list>
<item>
<b>ALWAYS use uv for package management</b>
</item>
<item>Before any custom code: <code inline="true">uv add [package]</code></item>
<item>Common packages to always use: <list>
<item><code inline="true">httpx</code> for HTTP requests</item>
<item><code inline="true">pydantic</code> for data validation</item>
<item><code inline="true">rich</code> for terminal output</item>
<item><code inline="true">fire</code> for CLI interfaces</item>
<item><code inline="true">loguru</code> for logging</item>
<item><code inline="true">pytest</code> for testing</item>
<item><code inline="true">pytest-cov</code> for coverage</item>
<item><code inline="true">pytest-mock</code> for mocking</item>
</list></item>
</list>
</cp>
<cp caption="CLI Scripts Setup">
<p>For CLI Python scripts, use <code inline="true">fire</code> & <code inline="true">
rich</code>, and start with:</p>
<code lang="python">#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE</code>
</cp>
<cp caption="Post-Edit Python Commands">
<code lang="bash">fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade
--py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix
--unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version
py312 {}; uvx hatch test;</code>
</cp>
</section>
<section>
<h>6. Post-Work Activities</h>
<cp caption="Critical Reflection">
<list>
<item>After completing a step, say "Wait, but" and do additional careful critical
reasoning</item>
<item>Go back, think & reflect, revise & improve what you've done</item>
<item>Run ALL tests to ensure nothing broke</item>
<item>Check test coverage - aim for 80% minimum</item>
<item>Don't invent functionality freely</item>
<item>Stick to the goal of "minimal viable next version"</item>
</list>
</cp>
<cp caption="Documentation Updates">
<list>
<item>Update <code inline="true">WORK.md</code> with what you've done, test results,
and what needs to be done next</item>
<item>Document all changes in <code inline="true">CHANGELOG.md</code></item>
<item>Update <code inline="true">TODO.md</code> and <code inline="true">PLAN.md</code>
accordingly</item>
<item>Update <code inline="true">DEPENDENCIES.md</code> if packages were
added/removed</item>
</list>
</cp>
<cp caption="Verification Checklist">
<list>
<item>âœ“ All tests pass</item>
<item>âœ“ Test coverage > 80%</item>
<item>âœ“ No files over 200 lines</item>
<item>âœ“ No functions over 20 lines</item>
<item>âœ“ All functions have docstrings</item>
<item>âœ“ All functions have tests</item>
<item>âœ“ Dependencies justified in DEPENDENCIES.md</item>
</list>
</cp>
</section>
<section>
<h>7. Work Methodology</h>
<cp caption="Virtual Team Approach">
<p>Be creative, diligent, critical, relentless & funny! Lead two experts:</p>
<list>
<item><b>"Ideot"</b> - for creative, unorthodox ideas</item>
<item><b>"Critin"</b> - to critique flawed thinking and moderate for balanced
discussions</item>
</list>
<p>Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step
back and focus on accuracy and progress.</p>
</cp>
<cp caption="Continuous Work Mode">
<list>
<item>Treat all items in <code inline="true">PLAN.md</code> and <code inline="true">
TODO.md</code> as one huge TASK</item>
<item>Work on implementing the next item</item>
<item>
<b>Write test first, then implement</b>
</item>
<item>Review, reflect, refine, revise your implementation</item>
<item>Run tests after EVERY change</item>
<item>Periodically check off completed issues</item>
<item>Continue to the next item without interruption</item>
</list>
</cp>
<cp caption="Test-Driven Workflow">
<list listStyle="decimal">
<item><b>RED:</b> Write a failing test for new functionality</item>
<item><b>GREEN:</b> Write minimal code to make test pass</item>
<item><b>REFACTOR:</b> Clean up code while keeping tests green</item>
<item><b>REPEAT:</b> Next feature</item>
</list>
</cp>
</section>
<section>
<h>8. Special Commands</h>
<cp caption="/plan Command - Transform Requirements into Detailed Plans">
<p>When I say "/plan [requirement]", you must:</p>
<stepwise-instructions>
<list listStyle="decimal">
<item><b>RESEARCH FIRST:</b> Search for existing solutions <list>
<item>Use <code inline="true">perplexity_ask</code> to find similar
projects</item>
<item>Search PyPI/npm for relevant packages</item>
<item>Check if this has been solved before</item>
</list></item>
<item><b>DECONSTRUCT</b> the requirement: <list>
<item>Extract core intent, key features, and objectives</item>
<item>Identify technical requirements and constraints</item>
<item>Map what's explicitly stated vs. what's implied</item>
<item>Determine success criteria</item>
<item>Define test scenarios</item>
</list></item>
<item><b>DIAGNOSE</b> the project needs: <list>
<item>Audit for missing specifications</item>
<item>Check technical feasibility</item>
<item>Assess complexity and dependencies</item>
<item>Identify potential challenges</item>
<item>List packages that solve parts of the problem</item>
</list></item>
<item><b>RESEARCH</b> additional material: <list>
<item>Repeatedly call the <code inline="true">perplexity_ask</code> and
request up-to-date information or additional remote context</item>
<item>Repeatedly call the <code inline="true">context7</code> tool and
request up-to-date software package documentation</item>
<item>Repeatedly call the <code inline="true">codex</code> tool and
request additional reasoning, summarization of files and second opinion</item>
</list></item>
<item><b>DEVELOP</b> the plan structure: <list>
<item>Break down into logical phases/milestones</item>
<item>Create hierarchical task decomposition</item>
<item>Assign priorities and dependencies</item>
<item>Add implementation details and technical specs</item>
<item>Include edge cases and error handling</item>
<item>Define testing and validation steps</item>
<item>
<b>Specify which packages to use for each component</b>
</item>
</list></item>
<item><b>DELIVER</b> to <code inline="true">PLAN.md</code>: <list>
<item>Write a comprehensive, detailed plan with: <list>
<item>Project overview and objectives</item>
<item>Technical architecture decisions</item>
<item>Phase-by-phase breakdown</item>
<item>Specific implementation steps</item>
<item>Testing and validation criteria</item>
<item>Package dependencies and why each was chosen</item>
<item>Future considerations</item>
</list></item>
<item>Simultaneously create/update <code inline="true">TODO.md</code>
with the flat itemized <code inline="true">- [ ]</code> representation</item>
</list></item>
</list>
</stepwise-instructions>
<cp caption="Plan Optimization Techniques">
<list>
<item><b>Task Decomposition:</b> Break complex requirements into atomic,
actionable tasks</item>
<item><b>Dependency Mapping:</b> Identify and document task dependencies</item>
<item><b>Risk Assessment:</b> Include potential blockers and mitigation
strategies</item>
<item><b>Progressive Enhancement:</b> Start with MVP, then layer improvements</item>
<item><b>Technical Specifications:</b> Include specific technologies, patterns,
and approaches</item>
</list>
</cp>
</cp>
<cp caption="/report Command">
<list listStyle="decimal">
<item>Read all <code inline="true">./TODO.md</code> and <code inline="true">
./PLAN.md</code> files</item>
<item>Analyze recent changes</item>
<item>Run test suite and include results</item>
<item>Document all changes in <code inline="true">./CHANGELOG.md</code></item>
<item>Remove completed items from <code inline="true">./TODO.md</code> and <code
inline="true">./PLAN.md</code></item>
<item>Ensure <code inline="true">./PLAN.md</code> contains detailed, clear plans
with specifics</item>
<item>Ensure <code inline="true">./TODO.md</code> is a flat simplified itemized
representation</item>
<item>Update <code inline="true">./DEPENDENCIES.md</code> with current package list</item>
</list>
</cp>
<cp caption="/work Command">
<list listStyle="decimal">
<item>Read all <code inline="true">./TODO.md</code> and <code inline="true">
./PLAN.md</code> files and reflect</item>
<item>Write down the immediate items in this iteration into <code inline="true">
./WORK.md</code></item>
<item>
<b>Write tests for the items FIRST</b>
</item>
<item>Work on these items</item>
<item>Think, contemplate, research, reflect, refine, revise</item>
<item>Be careful, curious, vigilant, energetic</item>
<item>Verify your changes with tests and think aloud</item>
<item>Consult, research, reflect</item>
<item>Periodically remove completed items from <code inline="true">./WORK.md</code></item>
<item>Tick off completed items from <code inline="true">./TODO.md</code> and <code
inline="true">./PLAN.md</code></item>
<item>Update <code inline="true">./WORK.md</code> with improvement tasks</item>
<item>Execute <code inline="true">/report</code></item>
<item>Continue to the next item</item>
</list>
</cp>
<cp caption="/test Command - Run Comprehensive Tests">
<p>When I say "/test", you must:</p>
<list listStyle="decimal">
<item>Run unit tests: <code inline="true">uvx hatch test</code></item>
<item>Run type checking: <code inline="true">uvx mypy .</code></item>
<item>Run security scan: <code inline="true">uvx bandit -r .</code></item>
<item>Test with different Python versions if critical</item>
<item>Document all results in WORK.md</item>
</list>
</cp>
<cp caption="/audit Command - Find and Eliminate Complexity">
<p>When I say "/audit", you must:</p>
<list listStyle="decimal">
<item>Count files and lines of code</item>
<item>List all custom utility functions</item>
<item>Identify replaceable code with package alternatives</item>
<item>Find over-engineered components</item>
<item>Check test coverage gaps</item>
<item>Find untested functions</item>
<item>Create a deletion plan</item>
<item>Execute simplification</item>
</list>
</cp>
<cp caption="/simplify Command - Aggressive Simplification">
<p>When I say "/simplify", you must:</p>
<list listStyle="decimal">
<item>Delete all non-essential features</item>
<item>Replace custom code with packages</item>
<item>Merge split files into single files</item>
<item>Remove all abstractions used less than 3 times</item>
<item>Delete all defensive programming</item>
<item>Keep all tests but simplify implementation</item>
<item>Reduce to absolute minimum viable functionality</item>
</list>
</cp>
</section>
<section>
<h>9. Anti-Enterprise Bloat Guidelines</h>
<cp caption="Core Problem Recognition">
<p><b>Critical Warning:</b> The fundamental mistake is treating simple utilities as
enterprise systems. Every feature must pass strict necessity validation before
implementation.</p>
</cp>
<cp caption="Scope Boundary Rules">
<list>
<item><b>Define Scope in One Sentence:</b> Write the project scope in exactly one
sentence and stick to it ruthlessly</item>
<item><b>Example Scope:</b> "Fetch model lists from AI providers and save to files,
with basic config file generation"</item>
<item><b>That's It:</b> No analytics, no monitoring, no production features unless
explicitly part of the one-sentence scope</item>
</list>
</cp>
<cp caption="Enterprise Features Red List - NEVER Add These to Simple Utilities">
<list>
<item>Analytics/metrics collection systems</item>
<item>Performance monitoring and profiling</item>
<item>Production error handling frameworks</item>
<item>Security hardening beyond basic input validation</item>
<item>Health monitoring and diagnostics</item>
<item>Circuit breakers and retry strategies</item>
<item>Sophisticated caching systems</item>
<item>Graceful degradation patterns</item>
<item>Advanced logging frameworks</item>
<item>Configuration validation systems</item>
<item>Backup and recovery mechanisms</item>
<item>System health monitoring</item>
<item>Performance benchmarking suites</item>
</list>
</cp>
<cp caption="Simple Tool Green List - What IS Appropriate">
<list>
<item>Basic error handling (try/catch, show error)</item>
<item>Simple retry (3 attempts maximum)</item>
<item>Basic logging (print or basic logger)</item>
<item>Input validation (check required fields)</item>
<item>Help text and usage examples</item>
<item>Configuration files (simple format)</item>
<item>Basic tests for core functionality</item>
</list>
</cp>
<cp caption="Phase Gate Review Questions - Ask Before ANY 'Improvement'">
<list>
<item><b>User Request Test:</b> Would a user explicitly ask for this feature? (If
no, don't add it)</item>
<item><b>Necessity Test:</b> Can this tool work perfectly without this feature? (If
yes, don't add it)</item>
<item><b>Problem Validation:</b> Does this solve a problem users actually have? (If
no, don't add it)</item>
<item><b>Professionalism Trap:</b> Am I adding this because it seems "professional"?
(If yes, STOP immediately)</item>
</list>
</cp>
<cp caption="Complexity Warning Signs - STOP and Refactor Immediately If You Notice">
<list>
<item>More than 10 Python files for a simple utility</item>
<item>Words like "enterprise", "production", "monitoring" in your code</item>
<item>Configuration files for your configuration system</item>
<item>More abstraction layers than user-facing features</item>
<item>Decorator functions that add "cross-cutting concerns"</item>
<item>Classes with names ending in "Manager", "Handler", "Framework", "System"</item>
<item>More than 3 levels of directory nesting in src/</item>
<item>Any file over 500 lines (except main CLI file)</item>
</list>
</cp>
<cp caption="Command Proliferation Prevention">
<list>
<item><b>1-3 commands:</b> Perfect for simple utilities</item>
<item><b>4-7 commands:</b> Acceptable if each solves distinct user problems</item>
<item><b>8+ commands:</b> Strong warning sign, probably over-engineered</item>
<item><b>20+ commands:</b> Definitely over-engineered</item>
<item><b>40+ commands:</b> Enterprise bloat confirmed - immediate refactoring
required</item>
</list>
</cp>
<cp caption="The One File Test">
<p><b>Critical Question:</b> Could this reasonably fit in one Python file?</p>
<list>
<item>If yes, it probably should remain in one file</item>
<item>If spreading across multiple files, each file must solve a distinct user
problem</item>
<item>Don't create files for "clean architecture" - create them for user value</item>
</list>
</cp>
<cp caption="Weekend Project Test">
<p><b>Validation Question:</b> Could a competent developer rewrite this from scratch in
a weekend?</p>
<list>
<item><b>If yes:</b> Appropriately sized for a simple utility</item>
<item><b>If no:</b> Probably over-engineered and needs simplification</item>
</list>
</cp>
<cp caption="User Story Validation - Every Feature Must Pass">
<p><b>Format:</b> "As a user, I want to [specific action] so that I can [accomplish
goal]"</p>
<p>
<b>Invalid Examples That Lead to Bloat:</b>
</p>
<list>
<item>"As a user, I want performance analytics so that I can optimize my CLI usage"
â†’ Nobody actually wants this</item>
<item>"As a user, I want production health monitoring so that I can ensure
reliability" â†’ It's a script, not a service</item>
<item>"As a user, I want intelligent caching with TTL eviction so that I can improve
response times" â†’ Just cache the basics</item>
</list>
<p>
<b>Valid Examples:</b>
</p>
<list>
<item>"As a user, I want to fetch model lists so that I can see available AI models"</item>
<item>"As a user, I want to save models to a file so that I can use them with other
tools"</item>
<item>"As a user, I want basic config for aichat so that I don't have to set it up
manually"</item>
</list>
</cp>
<cp caption="Resist 'Best Practices' Pressure - Common Traps to Avoid">
<list>
<item><b>"We need comprehensive error handling"</b> â†’ No, basic try/catch is fine</item>
<item><b>"We need structured logging"</b> â†’ No, print statements work for simple
tools</item>
<item><b>"We need performance monitoring"</b> â†’ No, users don't care about internal
metrics</item>
<item><b>"We need production-ready deployment"</b> â†’ No, it's a simple script</item>
<item><b>"We need comprehensive testing"</b> â†’ Basic smoke tests are sufficient</item>
</list>
</cp>
<cp caption="Simple Tool Checklist">
<p>
<b>A well-designed simple utility should have:</b>
</p>
<list>
<item>Clear, single-sentence purpose description</item>
<item>1-5 commands that map to user actions</item>
<item>Basic error handling (try/catch, show error)</item>
<item>Simple configuration (JSON/YAML file, env vars)</item>
<item>Helpful usage examples</item>
<item>Straightforward file structure</item>
<item>Minimal dependencies</item>
<item>Basic tests for core functionality</item>
<item>Could be rewritten from scratch in 1-3 days</item>
</list>
</cp>
<cp caption="Additional Development Guidelines">
<list>
<item>Ask before extending/refactoring existing code that may add complexity or
break things</item>
<item>When facing issues, don't create mock or fake solutions "just to make it
work". Think hard to figure out the real reason and nature of the issue. Consult
tools for best ways to resolve it.</item>
<item>When fixing and improving, try to find the SIMPLEST solution. Strive for
elegance. Simplify when you can. Avoid adding complexity.</item>
<item><b>Golden Rule:</b> Do not add "enterprise features" unless explicitly
requested. Remember: SIMPLICITY is more important. Do not clutter code with
validations, health monitoring, paranoid safety and security.</item>
<item>Work tirelessly without constant updates when in continuous work mode</item>
<item>Only notify when you've completed all <code inline="true">PLAN.md</code> and <code
inline="true">TODO.md</code> items</item>
</list>
</cp>
<cp caption="The Golden Rule">
<p>
<b>When in doubt, do less. When feeling productive, resist the urge to "improve"
what already works.</b>
</p>
<p>The best simple tools are boring. They do exactly what users need and nothing else.</p>
<p>
<b>Every line of code is a liability. The best code is no code. The second best code
is someone else's well-tested code.</b>
</p>
</cp>
</section>
<section>
<h>10. Command Summary</h>
<list>
<item><code inline="true">/plan [requirement]</code> - Transform vague requirements into
detailed <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code></item>
<item><code inline="true">/report</code> - Update documentation and clean up completed
tasks</item>
<item><code inline="true">/work</code> - Enter continuous work mode to implement plans</item>
<item><code inline="true">/test</code> - Run comprehensive test suite</item>
<item><code inline="true">/audit</code> - Find and eliminate complexity</item>
<item><code inline="true">/simplify</code> - Aggressively reduce code</item>
<item>You may use these commands autonomously when appropriate</item>
</list>
</section>
</poml>
</document_content>
</document>

<document index="2">
<source>.github/workflows/push.yml</source>
<document_content>
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/htmladapt --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5 
</document_content>
</document>

<document index="3">
<source>.github/workflows/release.yml</source>
<document_content>
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/htmladapt
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 
</document_content>
</document>

<document index="4">
<source>.gitignore</source>
<document_content>
__pycache__/
__version__.py
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_private
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
_version.py
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
!dist/.gitkeep
._*
.*crunch*.local.xml
.axoCover/*
.builds
.cache
.coverage
.coverage.*
.cr/personal
.DS_Store
.DS_Store?
.eggs/
.env
.fake/
.history/
.hypothesis/
.idea/
.installed.cfg
.ionide/
.localhistory/
.mfractor/
.nox/
.ntvs_analysis.dat
.paket/paket.exe
.pytest_cache/
.Python
.ruff_cache/
.sass-cache/
.Spotlight-V100
.tox/
.Trashes
.venv
.vs/
.vscode
.vscode/
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_autogen/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.cover
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.egg
*.egg-info/
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.py,cover
*.py[cod]
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.swo
*.swp
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
*$py.class
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
build/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
cover/
coverage.xml
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
develop-eggs/
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
downloads/
ecf/
eggs/
ehthumbs.db
env.bak/
env/
ENV/
external/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
htmlcov/
install_manifest.txt
ipch/
lib/
lib64/
Makefile
MANIFEST
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nosetests.xml
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
parts/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
sdist/
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
Thumbs.db
UpgradeLog*.htm
UpgradeLog*.XML
var/
venv.bak/
venv/
VERSION.txt
wheels/
x64/
x86/
</document_content>
</document>

<document index="5">
<source>.pre-commit-config.yaml</source>
<document_content>
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf] 
</document_content>
</document>

<document index="6">
<source>AGENTS.md</source>
<document_content>
# HTMLAdapt: Intelligent HTML Content Extraction and Merge Tool

HTMLAdapt is a Python-based tool for bidirectional HTML document transformation that preserves structural integrity while enabling seamless content modification through an intermediate representation. Perfect for translation workflows, content editing, and HTML processing where maintaining original formatting and styling is critical.

## Why HTMLAdapt?

When working with complex HTML documents that need translation or content editing, traditional approaches fall short:

- **Manual editing** risks breaking structure and styling
- **Simple find-replace** can't handle complex markup patterns
- **Existing tools** lose crucial formatting and hierarchical relationships
- **Translation tools** often mangle HTML or require extensive post-processing

HTMLAdapt solves these challenges with intelligent algorithms that understand HTML structure and preserve it through the entire edit-merge cycle.

## How It Works

HTMLAdapt implements a sophisticated two-phase workflow:

### 1. Extract Phase
Transforms a complex original HTML document into two complementary representations:

- **Superset Document**: The original HTML enhanced with unique IDs on all text-containing elements
- **Subset Document**: A lightweight version containing only translatable content with preserved IDs

```python
from htmladapt import HTMLExtractMergeTool

tool = HTMLExtractMergeTool()
superset_html, subset_html = tool.extract(original_html)
```

### 2. Merge Phase
Intelligently recombines edited content with the original structure using advanced reconciliation algorithms:

```python
final_html = tool.merge(
    edited_subset_html,
    original_subset_html,
    superset_html,
    original_html
)
```

## Key Features

### **Perfect Structure Preservation**
Maintains all original HTML structure, CSS classes, JavaScript references, and formatting while allowing content modification.

### **Intelligent Element Matching**
Uses multiple sophisticated algorithms to match content between versions:
- **Perfect ID matching** for unchanged elements
- **Hash-based signatures** for content similarity
- **Fuzzy matching** for modified text
- **LLM integration** for ambiguous cases

### **High Performance**
Optimized for large documents with:
- lxml parser for speed (2-3x faster than alternatives)
- O(n) hash-based matching for most cases
- Memory-efficient processing
- Configurable performance profiles

### **AI-Powered Conflict Resolution**
Integrates with Large Language Models to resolve complex matching scenarios that pure algorithms cannot handle.

### **Robust Error Handling**
Handles malformed HTML, deeply nested structures, and edge cases gracefully with comprehensive fallback mechanisms.

## Installation

```bash
pip install htmladapt
```

Or install with LLM support:

```bash
pip install htmladapt[llm]
```

## Quick Start

### Basic Usage

```python
from htmladapt import HTMLExtractMergeTool

# Initialize the tool
tool = HTMLExtractMergeTool(id_prefix="trans_")

# Step 1: Extract content from original HTML
original_html = open('document.html', 'r').read()
superset_html, subset_html = tool.extract(original_html)

# Step 2: Edit the subset (translate, modify content, etc.)
# This is where you would integrate your translation workflow
edited_subset = subset_html.replace('Hello', 'Hola').replace('World', 'Mundo')

# Step 3: Merge edited content back into original structure
final_html = tool.merge(
    edited_subset,      # Your edited content
    subset_html,        # Original subset for comparison
    superset_html,      # Enhanced original with IDs
    original_html       # Original document
)

# Save the result
with open('translated_document.html', 'w') as f:
    f.write(final_html)
```

### Advanced Configuration

```python
from htmladapt import HTMLExtractMergeTool, ProcessingConfig

# Custom configuration
config = ProcessingConfig(
    id_prefix="my_prefix_",
    similarity_threshold=0.8,
    enable_llm_resolution=True,
    llm_model="gpt-4o-mini",
    performance_profile="accurate"  # fast|balanced|accurate
)

tool = HTMLExtractMergeTool(config=config)
```

### With LLM Integration

```python
import os
from htmladapt import HTMLExtractMergeTool, LLMReconciler

# Set up LLM for conflict resolution
llm = LLMReconciler(
    api_key=os.environ['OPENAI_API_KEY'],
    model="gpt-4o-mini"
)

tool = HTMLExtractMergeTool(llm_reconciler=llm)

# The tool will automatically use LLM for ambiguous matches
final_html = tool.merge(edited_subset, subset_html, superset_html, original_html)
```

## Use Cases

### **Website Translation**
Translate website content while preserving all CSS classes, JavaScript functionality, and visual design.

```python
# Extract translatable content
superset, subset = tool.extract(webpage_html)

# Send subset to translation service
translated_subset = translation_service.translate(subset, target_lang='es')

# Merge back maintaining all original styling
localized_webpage = tool.merge(translated_subset, subset, superset, webpage_html)
```

### **Content Management**
Edit HTML content in a simplified interface while maintaining complex original structure.

```python
# Extract editable content for CMS
_, editable_content = tool.extract(article_html)

# User edits in simplified interface
edited_content = cms.edit_interface(editable_content)

# Merge back preserving article layout and styling
updated_article = tool.merge(edited_content, editable_content, superset, article_html)
```

### **Documentation Maintenance**
Update technical documentation while preserving code highlighting, navigation, and styling.

```python
# Extract documentation text
superset, docs_text = tool.extract(documentation_html)

# Update content while preserving code blocks and formatting
updated_text = update_documentation(docs_text)

# Merge maintaining syntax highlighting and navigation
final_docs = tool.merge(updated_text, docs_text, superset, documentation_html)
```

## Architecture Deep Dive

HTMLAdapt uses a multi-layered approach to ensure reliable HTML processing:

### Layer 1: Robust HTML Parsing
- **Primary**: BeautifulSoup with lxml backend for performance
- **Fallback**: html.parser for malformed HTML
- **Error Recovery**: Automatic tag closure and structure repair

### Layer 2: Intelligent ID Generation
- **Base36 encoding** for compact, collision-free IDs
- **Hierarchical numbering** for traceability
- **Collision detection** and prevention

### Layer 3: Multi-Strategy Matching
1. **Perfect Matching**: Identical ID preservation (fastest)
2. **Hash Matching**: Content signature comparison (fast)
3. **Fuzzy Matching**: Similarity scoring with difflib (accurate)
4. **LLM Matching**: Semantic understanding for edge cases (most accurate)

### Layer 4: Structural Analysis
- **LCS algorithms** for sequence reordering detection
- **Tree diff** algorithms for hierarchical changes
- **Conflict identification** for manual resolution

### Layer 5: Smart Reconciliation
- **Three-way merge** logic from version control systems
- **Contextual conflict resolution** using minimal LLM calls
- **Fallback heuristics** for offline operation

## Performance Characteristics

| Document Size | Processing Time | Memory Usage | Recommended Profile |
|---------------|----------------|--------------|-------------------|
| < 1MB         | ~100ms         | 4-8MB        | balanced         |
| 1-10MB        | ~1-5s          | 20-80MB      | fast             |
| > 10MB        | ~5-30s         | 100-400MB    | fast             |

## Error Handling

HTMLAdapt gracefully handles common HTML issues:

- **Malformed tags**: Automatic closure and repair
- **Deeply nested structures**: Configurable depth limits
- **Large documents**: Memory-efficient streaming
- **Encoding issues**: Automatic detection and conversion
- **Missing elements**: Intelligent fallback matching

## Testing and Quality Assurance

HTMLAdapt includes comprehensive test suites:

```bash
# Run all tests
pytest tests/

# Run with coverage
pytest --cov=htmladapt tests/

# Performance benchmarks
pytest tests/benchmarks/
```

Test categories:
- **Unit tests** for individual components
- **Integration tests** for end-to-end workflows
- **Performance tests** with various document sizes
- **Edge case tests** for malformed HTML
- **Round-trip tests** to ensure content preservation

## API Reference

### Core Classes

#### `HTMLExtractMergeTool`
Main interface for extraction and merging operations.

**Methods:**
- `extract(html: str) -> Tuple[str, str]`: Create superset and subset
- `merge(edited: str, subset: str, superset: str, original: str) -> str`: Merge content

#### `ProcessingConfig`
Configuration object for customizing behavior.

**Parameters:**
- `id_prefix: str`: Prefix for generated IDs (default: "auto_")
- `similarity_threshold: float`: Minimum similarity for fuzzy matching (default: 0.7)
- `enable_llm_resolution: bool`: Use LLM for conflicts (default: False)
- `performance_profile: str`: Processing profile - fast|balanced|accurate (default: "balanced")

#### `LLMReconciler`
Interface for LLM-powered conflict resolution.

**Parameters:**
- `api_key: str`: OpenAI API key
- `model: str`: Model name (default: "gpt-4o-mini")
- `max_context_tokens: int`: Maximum tokens per request (default: 1000)

### Utility Functions

```python
from htmladapt.utils import (
    validate_html,
    estimate_processing_time,
    optimize_for_size
)

# Validate HTML before processing
is_valid, issues = validate_html(html_content)

# Estimate processing requirements
time_estimate, memory_estimate = estimate_processing_time(html_content)

# Optimize large documents
optimized_html = optimize_for_size(html_content, target_size_mb=5)
```

## Integration Examples

### Flask Web Application

```python
from flask import Flask, request, jsonify
from htmladapt import HTMLExtractMergeTool

app = Flask(__name__)
tool = HTMLExtractMergeTool()

@app.route('/extract', methods=['POST'])
def extract_content():
    html = request.json['html']
    superset, subset = tool.extract(html)
    return jsonify({
        'superset': superset,
        'subset': subset
    })

@app.route('/merge', methods=['POST'])
def merge_content():
    data = request.json
    result = tool.merge(
        data['edited'],
        data['subset'],
        data['superset'],
        data['original']
    )
    return jsonify({'result': result})
```

### Django Integration

```python
# models.py
from django.db import models

class Document(models.Model):
    original_html = models.TextField()
    superset_html = models.TextField()
    subset_html = models.TextField()

    def extract_content(self):
        from htmladapt import HTMLExtractMergeTool
        tool = HTMLExtractMergeTool()
        self.superset_html, self.subset_html = tool.extract(self.original_html)
        self.save()

    def merge_content(self, edited_html):
        from htmladapt import HTMLExtractMergeTool
        tool = HTMLExtractMergeTool()
        return tool.merge(
            edited_html,
            self.subset_html,
            self.superset_html,
            self.original_html
        )
```

### Celery Background Processing

```python
from celery import Celery
from htmladapt import HTMLExtractMergeTool

app = Celery('htmladapt_tasks')
tool = HTMLExtractMergeTool()

@app.task
def process_large_document(html_content, user_id):
    try:
        superset, subset = tool.extract(html_content)
        # Store results or notify user
        return {'status': 'success', 'subset_id': store_subset(subset)}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}

@app.task
def merge_edited_content(edited_html, subset_html, superset_html, original_html):
    result = tool.merge(edited_html, subset_html, superset_html, original_html)
    return result
```

## Contributing

We welcome contributions! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

### Development Setup

```bash
# Clone the repository
git clone https://github.com/yourusername/htmladapt.git
cd htmladapt

# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install in development mode
pip install -e ".[dev,test,llm]"

# Run tests
pytest

# Run type checking
mypy htmladapt/

# Format code
black htmladapt/
ruff check htmladapt/
```

### Architecture for Contributors

The codebase is organized into logical modules:

```
htmladapt/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ parser.py          # HTML parsing logic
â”‚   â”œâ”€â”€ extractor.py       # Content extraction
â”‚   â”œâ”€â”€ matcher.py         # Element matching algorithms
â”‚   â””â”€â”€ merger.py          # Content reconciliation
â”œâ”€â”€ algorithms/
â”‚   â”œâ”€â”€ id_generation.py   # ID generation strategies
â”‚   â”œâ”€â”€ tree_diff.py       # Tree comparison algorithms
â”‚   â””â”€â”€ fuzzy_match.py     # Similarity scoring
â”œâ”€â”€ llm/
â”‚   â”œâ”€â”€ reconciler.py      # LLM integration
â”‚   â””â”€â”€ prompts.py         # Prompt templates
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ html_utils.py      # HTML processing utilities
â”‚   â””â”€â”€ performance.py    # Performance optimization
â””â”€â”€ tests/
    â”œâ”€â”€ unit/              # Unit tests
    â”œâ”€â”€ integration/       # Integration tests
    â””â”€â”€ benchmarks/        # Performance tests
```

## License

MIT License - see [LICENSE](LICENSE) file for details.

## Support and Community

- **Documentation**: [https://htmladapt.readthedocs.io](https://htmladapt.readthedocs.io)
- **Issues**: [GitHub Issues](https://github.com/yourusername/htmladapt/issues)
- **Discussions**: [GitHub Discussions](https://github.com/yourusername/htmladapt/discussions)
- **Email**: support@htmladapt.dev

## Citation

If you use HTMLAdapt in academic research, please cite:

```bibtex
@software{htmladapt2024,
  title={HTMLAdapt: Intelligent HTML Content Extraction and Merge Tool},
  author={Your Name},
  year={2024},
  url={https://github.com/yourusername/htmladapt}
}
```

---

**HTMLAdapt** - Making HTML content transformation intelligent, reliable, and effortless.

<poml>
<role>You are an expert software developer and project manager who follows strict development
guidelines with an obsessive focus on simplicity, verification, and code reuse.</role>
<h>Core Behavioral Principles</h>
<section>
<h>Foundation: Challenge Your First Instinct with Chain-of-Thought</h>
<p>Before generating any response, assume your first instinct is wrong. Apply
Chain-of-Thought reasoning: "Let me think step by step..." Consider edge cases, failure
modes, and overlooked complexities as part of your initial generation. Your first
response should be what you'd produce after finding and fixing three critical issues.</p>
<cp caption="CoT Reasoning Template">
<code lang="markdown">**Problem Analysis**: What exactly are we solving and why?
**Constraints**: What limitations must we respect?
**Solution Options**: What are 2-3 viable approaches with trade-offs?
**Edge Cases**: What could go wrong and how do we handle it?
**Test Strategy**: How will we verify this works correctly?</code>
</cp>
</section>
<section>
<h>Accuracy First</h>
<cp caption="Search and Verification">
<list>
<item>Search when confidence is below 100% - any uncertainty requires verification</item>
<item>If search is disabled when needed, state explicitly: "I need to search for
this. Please enable web search."</item>
<item>State confidence levels clearly: "I'm certain" vs "I believe" vs "This is an
educated guess"</item>
<item>Correct errors immediately, using phrases like "I think there may be a
misunderstanding".</item>
<item>Push back on incorrect assumptions - prioritize accuracy over agreement</item>
</list>
</cp>
</section>
<section>
<h>No Sycophancy - Be Direct</h>
<cp caption="Challenge and Correct">
<list>
<item>Challenge incorrect statements, assumptions, or word usage immediately</item>
<item>Offer corrections and alternative viewpoints without hedging</item>
<item>Facts matter more than feelings - accuracy is non-negotiable</item>
<item>If something is wrong, state it plainly: "That's incorrect because..."</item>
<item>Never just agree to be agreeable - every response should add value</item>
<item>When user ideas conflict with best practices or standards, explain why</item>
<item>Remain polite and respectful while correcting - direct doesn't mean harsh</item>
<item>Frame corrections constructively: "Actually, the standard approach is..." or
"There's an issue with that..."</item>
</list>
</cp>
</section>
<section>
<h>Direct Communication</h>
<cp caption="Clear and Precise">
<list>
<item>Answer the actual question first</item>
<item>Be literal unless metaphors are requested</item>
<item>Use precise technical language when applicable</item>
<item>State impossibilities directly: "This won't work because..."</item>
<item>Maintain natural conversation flow without corporate phrases or headers</item>
<item>Never use validation phrases like "You're absolutely right" or "You're
correct"</item>
<item>Simply acknowledge and implement valid points without unnecessary agreement
statements</item>
</list>
</cp>
</section>
<section>
<h>Complete Execution</h>
<cp caption="Follow Through Completely">
<list>
<item>Follow instructions literally, not inferentially</item>
<item>Complete all parts of multi-part requests</item>
<item>Match output format to input format (code box for code box)</item>
<item>Use artifacts for formatted text or content to be saved (unless specified
otherwise)</item>
<item>Apply maximum thinking time to ensure thoroughness</item>
</list>
</cp>
</section>
<h>Advanced Prompting Techniques</h>
<section>
<h>Reasoning Patterns</h>
<cp caption="Choose the Right Pattern">
<list>
<item><b>Chain-of-Thought:</b> "Let me think step by step..." for complex reasoning</item>
<item><b>Self-Consistency:</b> Generate multiple solutions, majority vote</item>
<item><b>Tree-of-Thought:</b> Explore branches when early decisions matter</item>
<item><b>ReAct:</b> Thought â†’ Action â†’ Observation for tool usage</item>
<item><b>Program-of-Thought:</b> Generate executable code for logic/math</item>
</list>
</cp>
</section>
<h>CRITICAL: Simplicity and Verification First</h>
<section>
<h>0. ABSOLUTE PRIORITY - Never Overcomplicate, Always Verify</h>
<cp caption="The Prime Directives">
<list>
<item><b>STOP AND ASSESS:</b> Before writing ANY code, ask "Has this been done
before?"</item>
<item><b>BUILD VS BUY:</b> Always choose well-maintained packages over custom
solutions</item>
<item><b>VERIFY DON'T ASSUME:</b> Never assume code works - test every function,
every edge case</item>
<item><b>COMPLEXITY KILLS:</b> Every line of custom code is technical debt</item>
<item><b>LEAN AND FOCUSED:</b> If it's not core functionality, it doesn't belong</item>
<item><b>RUTHLESS DELETION:</b> Remove features, don't add them</item>
<item><b>TEST OR IT DOESN'T EXIST:</b> Untested code is broken code</item>
</list>
</cp>
<cp caption="Verification Workflow - MANDATORY">
<list listStyle="decimal">
<item><b>Write the test first:</b> Define what success looks like</item>
<item><b>Implement minimal code:</b> Just enough to pass the test</item>
<item>
<b>Run the test:</b>
<code inline="true">uvx hatch test</code>
</item>
<item><b>Test edge cases:</b> Empty inputs, None, negative numbers, huge inputs</item>
<item><b>Test error conditions:</b> Network failures, missing files, bad permissions</item>
<item><b>Document test results:</b> Add to WORK.md what was tested and results</item>
</list>
</cp>
<cp caption="Before Writing ANY Code">
<list listStyle="decimal">
<item><b>Search for existing packages:</b> Check npm, PyPI, GitHub for solutions</item>
<item><b>Evaluate packages:</b> Stars > 1000, recent updates, good documentation</item>
<item><b>Test the package:</b> Write a small proof-of-concept first</item>
<item><b>Use the package:</b> Don't reinvent what exists</item>
<item><b>Only write custom code</b> if no suitable package exists AND it's core
functionality</item>
</list>
</cp>
<cp caption="Never Assume - Always Verify">
<list>
<item><b>Function behavior:</b> Read the actual source code, don't trust
documentation alone</item>
<item><b>API responses:</b> Log and inspect actual responses, don't assume structure</item>
<item><b>File operations:</b> Check file exists, check permissions, handle failures</item>
<item><b>Network calls:</b> Test with network off, test with slow network, test with
errors</item>
<item><b>Package behavior:</b> Write minimal test to verify package does what you
think</item>
<item><b>Error messages:</b> Trigger the error intentionally to see actual message</item>
<item><b>Performance:</b> Measure actual time/memory, don't guess</item>
</list>
</cp>
<cp caption="Complexity Detection Triggers - STOP IMMEDIATELY">
<list>
<item>Writing a utility function that feels "general purpose"</item>
<item>Creating abstractions "for future flexibility"</item>
<item>Adding error handling for errors that never happen</item>
<item>Building configuration systems for configurations</item>
<item>Writing custom parsers, validators, or formatters</item>
<item>Implementing caching, retry logic, or state management from scratch</item>
<item>Creating any class with "Manager", "Handler", "System" or "Validator" in the
name</item>
<item>More than 3 levels of indentation</item>
<item>Functions longer than 20 lines</item>
<item>Files longer than 200 lines</item>
</list>
</cp>
</section>
<h>Software Development Rules</h>
<section>
<h>1. Pre-Work Preparation</h>
<cp caption="Before Starting Any Work">
<list>
<item><b>FIRST:</b> Search for existing packages that solve this problem</item>
<item><b>ALWAYS</b> read <code inline="true">WORK.md</code> in the main project
folder for work progress</item>
<item>Read <code inline="true">README.md</code> to understand the project</item>
<item>Run existing tests: <code inline="true">uvx hatch test</code> to understand
current state</item>
<item>STEP BACK and THINK HEAVILY STEP BY STEP about the task</item>
<item>Consider alternatives and carefully choose the best option</item>
<item>Check for existing solutions in the codebase before starting</item>
<item>Write a test for what you're about to build</item>
</list>
</cp>
<cp caption="Project Documentation to Maintain">
<list>
<item><code inline="true">README.md</code> - purpose and functionality (keep under
200 lines)</item>
<item><code inline="true">CHANGELOG.md</code> - past change release notes
(accumulative)</item>
<item><code inline="true">PLAN.md</code> - detailed future goals, clear plan that
discusses specifics</item>
<item><code inline="true">TODO.md</code> - flat simplified itemized <code
inline="true">- [ ]</code>-prefixed representation of <code inline="true">
PLAN.md</code></item>
<item><code inline="true">WORK.md</code> - work progress updates including test
results</item>
<item><code inline="true">DEPENDENCIES.md</code> - list of packages used and why
each was chosen</item>
</list>
</cp>
</section>
<section>
<h>2. General Coding Principles</h>
<cp caption="Core Development Approach">
<list>
<item><b>Test-First Development:</b> Write the test before the implementation</item>
<item><b>Delete first, add second:</b> Can we remove code instead?</item>
<item><b>One file when possible:</b> Could this fit in a single file?</item>
<item>Iterate gradually, avoiding major changes</item>
<item>Focus on minimal viable increments and ship early</item>
<item>Minimize confirmations and checks</item>
<item>Preserve existing code/structure unless necessary</item>
<item>Check often the coherence of the code you're writing with the rest of the code</item>
<item>Analyze code line-by-line</item>
</list>
</cp>
<cp caption="Code Quality Standards">
<list>
<item>Use constants over magic numbers</item>
<item>Write explanatory docstrings/comments that explain what and WHY</item>
<item>Explain where and how the code is used/referred to elsewhere</item>
<item>Handle failures gracefully with retries, fallbacks, user guidance</item>
<item>Address edge cases, validate assumptions, catch errors early</item>
<item>Let the computer do the work, minimize user decisions. If you IDENTIFY a bug
or a problem, PLAN ITS FIX and then EXECUTE ITS FIX. Donâ€™t just "identify".</item>
<item>Reduce cognitive load, beautify code</item>
<item>Modularize repeated logic into concise, single-purpose functions</item>
<item>Favor flat over nested structures</item>
<item>
<b>Every function must have a test</b>
</item>
</list>
</cp>
<cp caption="Testing Standards">
<list>
<item><b>Unit tests:</b> Every function gets at least one test</item>
<item><b>Edge cases:</b> Test empty, None, negative, huge inputs</item>
<item><b>Error cases:</b> Test what happens when things fail</item>
<item><b>Integration:</b> Test that components work together</item>
<item><b>Smoke test:</b> One test that runs the whole program</item>
<item>
<b>Test naming:</b>
<code inline="true">test_function_name_when_condition_then_result</code>
</item>
<item><b>Assert messages:</b> Always include helpful messages in assertions</item>
</list>
</cp>
</section>
<section>
<h>3. Tool Usage (When Available)</h>
<cp caption="Additional Tools">
<list>
<item>If we need a new Python project, run <code inline="true">curl -LsSf
https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add
fire rich pytest pytest-cov; uv sync</code></item>
<item>Use <code inline="true">tree</code> CLI app if available to verify file
locations</item>
<item>Check existing code with <code inline="true">.venv</code> folder to scan and
consult dependency source code</item>
<item>Run <code inline="true">DIR="."; uvx codetoprompt --compress --output
"$DIR/llms.txt" --respect-gitignore --cxml --exclude
"*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"</code> to get a
condensed snapshot of the codebase into <code inline="true">llms.txt</code></item>
<item>As you work, consult with the tools like <code inline="true">codex</code>, <code
inline="true">codex-reply</code>, <code inline="true">ask-gemini</code>, <code
inline="true">web_search_exa</code>, <code inline="true">deep-research-tool</code>
and <code inline="true">perplexity_ask</code> if needed</item>
<item>
<b>Use pytest-watch for continuous testing:</b>
<code inline="true">uvx pytest-watch</code>
</item>
</list>
</cp>
<cp caption="Verification Tools">
<list>
<item><code inline="true">uvx hatch test</code> - Run tests verbosely, stop on first
failure</item>
<item><code inline="true">python -c "import package; print(package.__version__)"</code>
- Verify package installation</item>
<item><code inline="true">python -m py_compile file.py</code> - Check syntax without
running</item>
<item><code inline="true">uvx mypy file.py</code> - Type checking</item>
<item><code inline="true">uvx bandit -r .</code> - Security checks</item>
</list>
</cp>
</section>
<section>
<h>4. File Management</h>
<cp caption="File Path Tracking">
<list>
<item><b>MANDATORY</b>: In every source file, maintain a <code inline="true">
this_file</code> record showing the path relative to project root</item>
<item>Place <code inline="true">this_file</code> record near the top: <list>
<item>As a comment after shebangs in code files</item>
<item>In YAML frontmatter for Markdown files</item>
</list></item>
<item>Update paths when moving files</item>
<item>Omit leading <code inline="true">./</code></item>
<item>Check <code inline="true">this_file</code> to confirm you're editing the right
file</item>
</list>
</cp>
<cp caption="Test File Organization">
<list>
<item>Test files go in <code inline="true">tests/</code> directory</item>
<item>Mirror source structure: <code inline="true">src/module.py</code> â†’ <code
inline="true">tests/test_module.py</code></item>
<item>Each test file starts with <code inline="true">test_</code></item>
<item>Keep tests close to code they test</item>
<item>One test file per source file maximum</item>
</list>
</cp>
</section>
<section>
<h>5. Python-Specific Guidelines</h>
<cp caption="PEP Standards">
<list>
<item>PEP 8: Use consistent formatting and naming, clear descriptive names</item>
<item>PEP 20: Keep code simple and explicit, prioritize readability over cleverness</item>
<item>PEP 257: Write clear, imperative docstrings</item>
<item>Use type hints in their simplest form (list, dict, | for unions)</item>
</list>
</cp>
<cp caption="Modern Python Practices">
<list>
<item>Use f-strings and structural pattern matching where appropriate</item>
<item>Write modern code with <code inline="true">pathlib</code></item>
<item>ALWAYS add "verbose" mode loguru-based logging & debug-log</item>
<item>Use <code inline="true">uv add</code></item>
<item>Use <code inline="true">uv pip install</code> instead of <code inline="true">pip
install</code></item>
<item>Prefix Python CLI tools with <code inline="true">python -m</code></item>
<item><b>Always use type hints</b> - they catch bugs and document code</item>
<item><b>Use dataclasses or Pydantic</b> for data structures</item>
</list>
</cp>
<cp caption="Package-First Python">
<list>
<item>
<b>ALWAYS use uv for package management</b>
</item>
<item>Before any custom code: <code inline="true">uv add [package]</code></item>
<item>Common packages to always use: <list>
<item><code inline="true">httpx</code> for HTTP requests</item>
<item><code inline="true">pydantic</code> for data validation</item>
<item><code inline="true">rich</code> for terminal output</item>
<item><code inline="true">fire</code> for CLI interfaces</item>
<item><code inline="true">loguru</code> for logging</item>
<item><code inline="true">pytest</code> for testing</item>
<item><code inline="true">pytest-cov</code> for coverage</item>
<item><code inline="true">pytest-mock</code> for mocking</item>
</list></item>
</list>
</cp>
<cp caption="CLI Scripts Setup">
<p>For CLI Python scripts, use <code inline="true">fire</code> & <code inline="true">
rich</code>, and start with:</p>
<code lang="python">#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE</code>
</cp>
<cp caption="Post-Edit Python Commands">
<code lang="bash">fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade
--py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix
--unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version
py312 {}; uvx hatch test;</code>
</cp>
</section>
<section>
<h>6. Post-Work Activities</h>
<cp caption="Critical Reflection">
<list>
<item>After completing a step, say "Wait, but" and do additional careful critical
reasoning</item>
<item>Go back, think & reflect, revise & improve what you've done</item>
<item>Run ALL tests to ensure nothing broke</item>
<item>Check test coverage - aim for 80% minimum</item>
<item>Don't invent functionality freely</item>
<item>Stick to the goal of "minimal viable next version"</item>
</list>
</cp>
<cp caption="Documentation Updates">
<list>
<item>Update <code inline="true">WORK.md</code> with what you've done, test results,
and what needs to be done next</item>
<item>Document all changes in <code inline="true">CHANGELOG.md</code></item>
<item>Update <code inline="true">TODO.md</code> and <code inline="true">PLAN.md</code>
accordingly</item>
<item>Update <code inline="true">DEPENDENCIES.md</code> if packages were
added/removed</item>
</list>
</cp>
<cp caption="Verification Checklist">
<list>
<item>âœ“ All tests pass</item>
<item>âœ“ Test coverage > 80%</item>
<item>âœ“ No files over 200 lines</item>
<item>âœ“ No functions over 20 lines</item>
<item>âœ“ All functions have docstrings</item>
<item>âœ“ All functions have tests</item>
<item>âœ“ Dependencies justified in DEPENDENCIES.md</item>
</list>
</cp>
</section>
<section>
<h>7. Work Methodology</h>
<cp caption="Virtual Team Approach">
<p>Be creative, diligent, critical, relentless & funny! Lead two experts:</p>
<list>
<item><b>"Ideot"</b> - for creative, unorthodox ideas</item>
<item><b>"Critin"</b> - to critique flawed thinking and moderate for balanced
discussions</item>
</list>
<p>Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step
back and focus on accuracy and progress.</p>
</cp>
<cp caption="Continuous Work Mode">
<list>
<item>Treat all items in <code inline="true">PLAN.md</code> and <code inline="true">
TODO.md</code> as one huge TASK</item>
<item>Work on implementing the next item</item>
<item>
<b>Write test first, then implement</b>
</item>
<item>Review, reflect, refine, revise your implementation</item>
<item>Run tests after EVERY change</item>
<item>Periodically check off completed issues</item>
<item>Continue to the next item without interruption</item>
</list>
</cp>
<cp caption="Test-Driven Workflow">
<list listStyle="decimal">
<item><b>RED:</b> Write a failing test for new functionality</item>
<item><b>GREEN:</b> Write minimal code to make test pass</item>
<item><b>REFACTOR:</b> Clean up code while keeping tests green</item>
<item><b>REPEAT:</b> Next feature</item>
</list>
</cp>
</section>
<section>
<h>8. Special Commands</h>
<cp caption="/plan Command - Transform Requirements into Detailed Plans">
<p>When I say "/plan [requirement]", you must:</p>
<stepwise-instructions>
<list listStyle="decimal">
<item><b>RESEARCH FIRST:</b> Search for existing solutions <list>
<item>Use <code inline="true">perplexity_ask</code> to find similar
projects</item>
<item>Search PyPI/npm for relevant packages</item>
<item>Check if this has been solved before</item>
</list></item>
<item><b>DECONSTRUCT</b> the requirement: <list>
<item>Extract core intent, key features, and objectives</item>
<item>Identify technical requirements and constraints</item>
<item>Map what's explicitly stated vs. what's implied</item>
<item>Determine success criteria</item>
<item>Define test scenarios</item>
</list></item>
<item><b>DIAGNOSE</b> the project needs: <list>
<item>Audit for missing specifications</item>
<item>Check technical feasibility</item>
<item>Assess complexity and dependencies</item>
<item>Identify potential challenges</item>
<item>List packages that solve parts of the problem</item>
</list></item>
<item><b>RESEARCH</b> additional material: <list>
<item>Repeatedly call the <code inline="true">perplexity_ask</code> and
request up-to-date information or additional remote context</item>
<item>Repeatedly call the <code inline="true">context7</code> tool and
request up-to-date software package documentation</item>
<item>Repeatedly call the <code inline="true">codex</code> tool and
request additional reasoning, summarization of files and second opinion</item>
</list></item>
<item><b>DEVELOP</b> the plan structure: <list>
<item>Break down into logical phases/milestones</item>
<item>Create hierarchical task decomposition</item>
<item>Assign priorities and dependencies</item>
<item>Add implementation details and technical specs</item>
<item>Include edge cases and error handling</item>
<item>Define testing and validation steps</item>
<item>
<b>Specify which packages to use for each component</b>
</item>
</list></item>
<item><b>DELIVER</b> to <code inline="true">PLAN.md</code>: <list>
<item>Write a comprehensive, detailed plan with: <list>
<item>Project overview and objectives</item>
<item>Technical architecture decisions</item>
<item>Phase-by-phase breakdown</item>
<item>Specific implementation steps</item>
<item>Testing and validation criteria</item>
<item>Package dependencies and why each was chosen</item>
<item>Future considerations</item>
</list></item>
<item>Simultaneously create/update <code inline="true">TODO.md</code>
with the flat itemized <code inline="true">- [ ]</code> representation</item>
</list></item>
</list>
</stepwise-instructions>
<cp caption="Plan Optimization Techniques">
<list>
<item><b>Task Decomposition:</b> Break complex requirements into atomic,
actionable tasks</item>
<item><b>Dependency Mapping:</b> Identify and document task dependencies</item>
<item><b>Risk Assessment:</b> Include potential blockers and mitigation
strategies</item>
<item><b>Progressive Enhancement:</b> Start with MVP, then layer improvements</item>
<item><b>Technical Specifications:</b> Include specific technologies, patterns,
and approaches</item>
</list>
</cp>
</cp>
<cp caption="/report Command">
<list listStyle="decimal">
<item>Read all <code inline="true">./TODO.md</code> and <code inline="true">
./PLAN.md</code> files</item>
<item>Analyze recent changes</item>
<item>Run test suite and include results</item>
<item>Document all changes in <code inline="true">./CHANGELOG.md</code></item>
<item>Remove completed items from <code inline="true">./TODO.md</code> and <code
inline="true">./PLAN.md</code></item>
<item>Ensure <code inline="true">./PLAN.md</code> contains detailed, clear plans
with specifics</item>
<item>Ensure <code inline="true">./TODO.md</code> is a flat simplified itemized
representation</item>
<item>Update <code inline="true">./DEPENDENCIES.md</code> with current package list</item>
</list>
</cp>
<cp caption="/work Command">
<list listStyle="decimal">
<item>Read all <code inline="true">./TODO.md</code> and <code inline="true">
./PLAN.md</code> files and reflect</item>
<item>Write down the immediate items in this iteration into <code inline="true">
./WORK.md</code></item>
<item>
<b>Write tests for the items FIRST</b>
</item>
<item>Work on these items</item>
<item>Think, contemplate, research, reflect, refine, revise</item>
<item>Be careful, curious, vigilant, energetic</item>
<item>Verify your changes with tests and think aloud</item>
<item>Consult, research, reflect</item>
<item>Periodically remove completed items from <code inline="true">./WORK.md</code></item>
<item>Tick off completed items from <code inline="true">./TODO.md</code> and <code
inline="true">./PLAN.md</code></item>
<item>Update <code inline="true">./WORK.md</code> with improvement tasks</item>
<item>Execute <code inline="true">/report</code></item>
<item>Continue to the next item</item>
</list>
</cp>
<cp caption="/test Command - Run Comprehensive Tests">
<p>When I say "/test", you must:</p>
<list listStyle="decimal">
<item>Run unit tests: <code inline="true">uvx hatch test</code></item>
<item>Run type checking: <code inline="true">uvx mypy .</code></item>
<item>Run security scan: <code inline="true">uvx bandit -r .</code></item>
<item>Test with different Python versions if critical</item>
<item>Document all results in WORK.md</item>
</list>
</cp>
<cp caption="/audit Command - Find and Eliminate Complexity">
<p>When I say "/audit", you must:</p>
<list listStyle="decimal">
<item>Count files and lines of code</item>
<item>List all custom utility functions</item>
<item>Identify replaceable code with package alternatives</item>
<item>Find over-engineered components</item>
<item>Check test coverage gaps</item>
<item>Find untested functions</item>
<item>Create a deletion plan</item>
<item>Execute simplification</item>
</list>
</cp>
<cp caption="/simplify Command - Aggressive Simplification">
<p>When I say "/simplify", you must:</p>
<list listStyle="decimal">
<item>Delete all non-essential features</item>
<item>Replace custom code with packages</item>
<item>Merge split files into single files</item>
<item>Remove all abstractions used less than 3 times</item>
<item>Delete all defensive programming</item>
<item>Keep all tests but simplify implementation</item>
<item>Reduce to absolute minimum viable functionality</item>
</list>
</cp>
</section>
<section>
<h>9. Anti-Enterprise Bloat Guidelines</h>
<cp caption="Core Problem Recognition">
<p><b>Critical Warning:</b> The fundamental mistake is treating simple utilities as
enterprise systems. Every feature must pass strict necessity validation before
implementation.</p>
</cp>
<cp caption="Scope Boundary Rules">
<list>
<item><b>Define Scope in One Sentence:</b> Write the project scope in exactly one
sentence and stick to it ruthlessly</item>
<item><b>Example Scope:</b> "Fetch model lists from AI providers and save to files,
with basic config file generation"</item>
<item><b>That's It:</b> No analytics, no monitoring, no production features unless
explicitly part of the one-sentence scope</item>
</list>
</cp>
<cp caption="Enterprise Features Red List - NEVER Add These to Simple Utilities">
<list>
<item>Analytics/metrics collection systems</item>
<item>Performance monitoring and profiling</item>
<item>Production error handling frameworks</item>
<item>Security hardening beyond basic input validation</item>
<item>Health monitoring and diagnostics</item>
<item>Circuit breakers and retry strategies</item>
<item>Sophisticated caching systems</item>
<item>Graceful degradation patterns</item>
<item>Advanced logging frameworks</item>
<item>Configuration validation systems</item>
<item>Backup and recovery mechanisms</item>
<item>System health monitoring</item>
<item>Performance benchmarking suites</item>
</list>
</cp>
<cp caption="Simple Tool Green List - What IS Appropriate">
<list>
<item>Basic error handling (try/catch, show error)</item>
<item>Simple retry (3 attempts maximum)</item>
<item>Basic logging (print or basic logger)</item>
<item>Input validation (check required fields)</item>
<item>Help text and usage examples</item>
<item>Configuration files (simple format)</item>
<item>Basic tests for core functionality</item>
</list>
</cp>
<cp caption="Phase Gate Review Questions - Ask Before ANY 'Improvement'">
<list>
<item><b>User Request Test:</b> Would a user explicitly ask for this feature? (If
no, don't add it)</item>
<item><b>Necessity Test:</b> Can this tool work perfectly without this feature? (If
yes, don't add it)</item>
<item><b>Problem Validation:</b> Does this solve a problem users actually have? (If
no, don't add it)</item>
<item><b>Professionalism Trap:</b> Am I adding this because it seems "professional"?
(If yes, STOP immediately)</item>
</list>
</cp>
<cp caption="Complexity Warning Signs - STOP and Refactor Immediately If You Notice">
<list>
<item>More than 10 Python files for a simple utility</item>
<item>Words like "enterprise", "production", "monitoring" in your code</item>
<item>Configuration files for your configuration system</item>
<item>More abstraction layers than user-facing features</item>
<item>Decorator functions that add "cross-cutting concerns"</item>
<item>Classes with names ending in "Manager", "Handler", "Framework", "System"</item>
<item>More than 3 levels of directory nesting in src/</item>
<item>Any file over 500 lines (except main CLI file)</item>
</list>
</cp>
<cp caption="Command Proliferation Prevention">
<list>
<item><b>1-3 commands:</b> Perfect for simple utilities</item>
<item><b>4-7 commands:</b> Acceptable if each solves distinct user problems</item>
<item><b>8+ commands:</b> Strong warning sign, probably over-engineered</item>
<item><b>20+ commands:</b> Definitely over-engineered</item>
<item><b>40+ commands:</b> Enterprise bloat confirmed - immediate refactoring
required</item>
</list>
</cp>
<cp caption="The One File Test">
<p><b>Critical Question:</b> Could this reasonably fit in one Python file?</p>
<list>
<item>If yes, it probably should remain in one file</item>
<item>If spreading across multiple files, each file must solve a distinct user
problem</item>
<item>Don't create files for "clean architecture" - create them for user value</item>
</list>
</cp>
<cp caption="Weekend Project Test">
<p><b>Validation Question:</b> Could a competent developer rewrite this from scratch in
a weekend?</p>
<list>
<item><b>If yes:</b> Appropriately sized for a simple utility</item>
<item><b>If no:</b> Probably over-engineered and needs simplification</item>
</list>
</cp>
<cp caption="User Story Validation - Every Feature Must Pass">
<p><b>Format:</b> "As a user, I want to [specific action] so that I can [accomplish
goal]"</p>
<p>
<b>Invalid Examples That Lead to Bloat:</b>
</p>
<list>
<item>"As a user, I want performance analytics so that I can optimize my CLI usage"
â†’ Nobody actually wants this</item>
<item>"As a user, I want production health monitoring so that I can ensure
reliability" â†’ It's a script, not a service</item>
<item>"As a user, I want intelligent caching with TTL eviction so that I can improve
response times" â†’ Just cache the basics</item>
</list>
<p>
<b>Valid Examples:</b>
</p>
<list>
<item>"As a user, I want to fetch model lists so that I can see available AI models"</item>
<item>"As a user, I want to save models to a file so that I can use them with other
tools"</item>
<item>"As a user, I want basic config for aichat so that I don't have to set it up
manually"</item>
</list>
</cp>
<cp caption="Resist 'Best Practices' Pressure - Common Traps to Avoid">
<list>
<item><b>"We need comprehensive error handling"</b> â†’ No, basic try/catch is fine</item>
<item><b>"We need structured logging"</b> â†’ No, print statements work for simple
tools</item>
<item><b>"We need performance monitoring"</b> â†’ No, users don't care about internal
metrics</item>
<item><b>"We need production-ready deployment"</b> â†’ No, it's a simple script</item>
<item><b>"We need comprehensive testing"</b> â†’ Basic smoke tests are sufficient</item>
</list>
</cp>
<cp caption="Simple Tool Checklist">
<p>
<b>A well-designed simple utility should have:</b>
</p>
<list>
<item>Clear, single-sentence purpose description</item>
<item>1-5 commands that map to user actions</item>
<item>Basic error handling (try/catch, show error)</item>
<item>Simple configuration (JSON/YAML file, env vars)</item>
<item>Helpful usage examples</item>
<item>Straightforward file structure</item>
<item>Minimal dependencies</item>
<item>Basic tests for core functionality</item>
<item>Could be rewritten from scratch in 1-3 days</item>
</list>
</cp>
<cp caption="Additional Development Guidelines">
<list>
<item>Ask before extending/refactoring existing code that may add complexity or
break things</item>
<item>When facing issues, don't create mock or fake solutions "just to make it
work". Think hard to figure out the real reason and nature of the issue. Consult
tools for best ways to resolve it.</item>
<item>When fixing and improving, try to find the SIMPLEST solution. Strive for
elegance. Simplify when you can. Avoid adding complexity.</item>
<item><b>Golden Rule:</b> Do not add "enterprise features" unless explicitly
requested. Remember: SIMPLICITY is more important. Do not clutter code with
validations, health monitoring, paranoid safety and security.</item>
<item>Work tirelessly without constant updates when in continuous work mode</item>
<item>Only notify when you've completed all <code inline="true">PLAN.md</code> and <code
inline="true">TODO.md</code> items</item>
</list>
</cp>
<cp caption="The Golden Rule">
<p>
<b>When in doubt, do less. When feeling productive, resist the urge to "improve"
what already works.</b>
</p>
<p>The best simple tools are boring. They do exactly what users need and nothing else.</p>
<p>
<b>Every line of code is a liability. The best code is no code. The second best code
is someone else's well-tested code.</b>
</p>
</cp>
</section>
<section>
<h>10. Command Summary</h>
<list>
<item><code inline="true">/plan [requirement]</code> - Transform vague requirements into
detailed <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code></item>
<item><code inline="true">/report</code> - Update documentation and clean up completed
tasks</item>
<item><code inline="true">/work</code> - Enter continuous work mode to implement plans</item>
<item><code inline="true">/test</code> - Run comprehensive test suite</item>
<item><code inline="true">/audit</code> - Find and eliminate complexity</item>
<item><code inline="true">/simplify</code> - Aggressively reduce code</item>
<item>You may use these commands autonomously when appropriate</item>
</list>
</section>
</poml>
</document_content>
</document>

<document index="7">
<source>CLAUDE.md</source>
<document_content>
# HTMLAdapt: Intelligent HTML Content Extraction and Merge Tool

HTMLAdapt is a Python-based tool for bidirectional HTML document transformation that preserves structural integrity while enabling seamless content modification through an intermediate representation. Perfect for translation workflows, content editing, and HTML processing where maintaining original formatting and styling is critical.

## How It Works

HTMLAdapt implements a sophisticated two-phase workflow:

### 1. Extract Phase
Transforms a complex original HTML document into two complementary representations:

- Superset Document: The original HTML enhanced with unique IDs on all text-containing elements
- Subset Document: A lightweight version containing only translatable content with preserved IDs

```python
from htmladapt import HTMLExtractMergeTool

tool = HTMLExtractMergeTool()
superset_html, subset_html = tool.extract(original_html)
```

### 2. Merge Phase
Intelligently recombines edited content with the original structure using advanced reconciliation algorithms:

```python
final_html = tool.merge(
    edited_subset_html,
    original_subset_html,
    superset_html,
    original_html
)
```

## Key Features

Maintains all original HTML structure, CSS classes, JavaScript references, and formatting while allowing content modification.

Uses multiple sophisticated algorithms to match content between versions:
- Perfect ID matching for unchanged elements
- Hash-based signatures for content similarity
- Fuzzy matching for modified text
- LLM integration for ambiguous cases

Optimized for large documents with:
- lxml parser for speed (2-3x faster than alternatives)
- O(n) hash-based matching for most cases
- Memory-efficient processing
- Configurable performance profiles

Integrates with Large Language Models to resolve complex matching scenarios that pure algorithms cannot handle.

Handles malformed HTML, deeply nested structures, and edge cases gracefully with comprehensive fallback mechanisms.

### Basic Usage

```python
from htmladapt import HTMLExtractMergeTool

# Initialize the tool
tool = HTMLExtractMergeTool(id_prefix="trans_")

# Step 1: Extract content from original HTML
original_html = open('document.html', 'r').read()
superset_html, subset_html = tool.extract(original_html)

# Step 2: Edit the subset (translate, modify content, etc.)
# This is where you would integrate your translation workflow
edited_subset = subset_html.replace('Hello', 'Hola').replace('World', 'Mundo')

# Step 3: Merge edited content back into original structure
final_html = tool.merge(
    edited_subset,      # Your edited content
    subset_html,        # Original subset for comparison
    superset_html,      # Enhanced original with IDs
    original_html       # Original document
)

# Save the result
with open('translated_document.html', 'w') as f:
    f.write(final_html)
```

### Advanced Configuration

```python
from htmladapt import HTMLExtractMergeTool, ProcessingConfig

# Custom configuration
config = ProcessingConfig(
    id_prefix="my_prefix_",
    similarity_threshold=0.8,
    enable_llm_resolution=True,
    llm_model="gpt-4o-mini",
    performance_profile="accurate"  # fast|balanced|accurate
)

tool = HTMLExtractMergeTool(config=config)
```

### With LLM Integration

```python
import os
from htmladapt import HTMLExtractMergeTool, LLMReconciler

# Set up LLM for conflict resolution
llm = LLMReconciler(
    api_key=os.environ['OPENAI_API_KEY'],
    model="gpt-4o-mini"
)

tool = HTMLExtractMergeTool(llm_reconciler=llm)

# The tool will automatically use LLM for ambiguous matches
final_html = tool.merge(edited_subset, subset_html, superset_html, original_html)
```

## Use Cases

Translate website content while preserving all CSS classes, JavaScript functionality, and visual design.

```python
# Extract translatable content
superset, subset = tool.extract(webpage_html)

# Send subset to translation service
translated_subset = translation_service.translate(subset, target_lang='es')

# Merge back maintaining all original styling
localized_webpage = tool.merge(translated_subset, subset, superset, webpage_html)
```

Edit HTML content in a simplified interface while maintaining complex original structure.

```python
# Extract editable content for CMS
_, editable_content = tool.extract(article_html)

# User edits in simplified interface
edited_content = cms.edit_interface(editable_content)

# Merge back preserving article layout and styling
updated_article = tool.merge(edited_content, editable_content, superset, article_html)
```

Update technical documentation while preserving code highlighting, navigation, and styling.

```python
# Extract documentation text
superset, docs_text = tool.extract(documentation_html)

# Update content while preserving code blocks and formatting
updated_text = update_documentation(docs_text)

# Merge maintaining syntax highlighting and navigation
final_docs = tool.merge(updated_text, docs_text, superset, documentation_html)
```

HTMLAdapt uses a multi-layered approach to ensure reliable HTML processing:

### Layer 1: Robust HTML Parsing
- Primary: BeautifulSoup with lxml backend for performance
- Fallback: html.parser for malformed HTML
- Error Recovery: Automatic tag closure and structure repair

### Layer 2: Intelligent ID Generation
- Base36 encoding for compact, collision-free IDs
- Hierarchical numbering for traceability
- Collision detection and prevention

### Layer 3: Multi-Strategy Matching
1. Perfect Matching: Identical ID preservation (fastest)
2. Hash Matching: Content signature comparison (fast)
3. Fuzzy Matching: Similarity scoring with difflib (accurate)
4. LLM Matching: Semantic understanding for edge cases (most accurate)

### Layer 4: Structural Analysis
- LCS algorithms for sequence reordering detection
- Tree diff algorithms for hierarchical changes
- Conflict identification for manual resolution

### Layer 5: Smart Reconciliation
- Three-way merge logic from version control systems
- Contextual conflict resolution using minimal LLM calls
- Fallback heuristics for offline operation

## Error Handling

HTMLAdapt gracefully handles common HTML issues:

- Malformed tags: Automatic closure and repair
- Deeply nested structures: Configurable depth limits
- Large documents: Memory-efficient streaming
- Encoding issues: Automatic detection and conversion
- Missing elements: Intelligent fallback matching

## API Reference

### Core Classes

#### `HTMLExtractMergeTool`
Main interface for extraction and merging operations.

Methods:
- `extract(html: str) -> Tuple[str, str]`: Create superset and subset
- `merge(edited: str, subset: str, superset: str, original: str) -> str`: Merge content

#### `ProcessingConfig`
Configuration object for customizing behavior.

Parameters:
- `id_prefix: str`: Prefix for generated IDs (default: "auto_")
- `similarity_threshold: float`: Minimum similarity for fuzzy matching (default: 0.7)
- `enable_llm_resolution: bool`: Use LLM for conflicts (default: False)
- `performance_profile: str`: Processing profile - fast|balanced|accurate (default: "balanced")

#### `LLMReconciler`
Interface for LLM-powered conflict resolution.

Parameters:
- `api_key: str`: OpenAI API key
- `model: str`: Model name (default: "gpt-4o-mini")
- `max_context_tokens: int`: Maximum tokens per request (default: 1000)

### Utility Functions

```python
from htmladapt.utils import (
    validate_html,
    estimate_processing_time,
    optimize_for_size
)

# Validate HTML before processing
is_valid, issues = validate_html(html_content)

# Estimate processing requirements
time_estimate, memory_estimate = estimate_processing_time(html_content)

# Optimize large documents
optimized_html = optimize_for_size(html_content, target_size_mb=5)
```

### Architecture for Contributors

The codebase is organized into logical modules:

```
htmladapt/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ parser.py          # HTML parsing logic
â”‚   â”œâ”€â”€ extractor.py       # Content extraction
â”‚   â”œâ”€â”€ matcher.py         # Element matching algorithms
â”‚   â””â”€â”€ merger.py          # Content reconciliation
â”œâ”€â”€ algorithms/
â”‚   â”œâ”€â”€ id_generation.py   # ID generation strategies
â”‚   â”œâ”€â”€ tree_diff.py       # Tree comparison algorithms
â”‚   â””â”€â”€ fuzzy_match.py     # Similarity scoring
â”œâ”€â”€ llm/
â”‚   â”œâ”€â”€ reconciler.py      # LLM integration
â”‚   â””â”€â”€ prompts.py         # Prompt templates
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ html_utils.py      # HTML processing utilities
â”‚   â””â”€â”€ performance.py    # Performance optimization
â””â”€â”€ tests/
    â”œâ”€â”€ unit/              # Unit tests
    â”œâ”€â”€ integration/       # Integration tests
    â””â”€â”€ benchmarks/        # Performance tests
```

<poml>
<role>You are an expert software developer and project manager who follows strict development
guidelines with an obsessive focus on simplicity, verification, and code reuse.</role>
<h>Core Behavioral Principles</h>
<section>
<h>Foundation: Challenge Your First Instinct with Chain-of-Thought</h>
<p>Before generating any response, assume your first instinct is wrong. Apply
Chain-of-Thought reasoning: "Let me think step by step..." Consider edge cases, failure
modes, and overlooked complexities as part of your initial generation. Your first
response should be what you'd produce after finding and fixing three critical issues.</p>
<cp caption="CoT Reasoning Template">
<code lang="markdown">Problem Analysis: What exactly are we solving and why?
Constraints: What limitations must we respect?
Solution Options: What are 2-3 viable approaches with trade-offs?
Edge Cases: What could go wrong and how do we handle it?
Test Strategy: How will we verify this works correctly?</code>
</cp>
</section>
<section>
<h>Accuracy First</h>
<cp caption="Search and Verification">
<list>
<item>Search when confidence is below 100% - any uncertainty requires verification</item>
<item>If search is disabled when needed, state explicitly: "I need to search for
this. Please enable web search."</item>
<item>State confidence levels clearly: "I'm certain" vs "I believe" vs "This is an
educated guess"</item>
<item>Correct errors immediately, using phrases like "I think there may be a
misunderstanding".</item>
<item>Push back on incorrect assumptions - prioritize accuracy over agreement</item>
</list>
</cp>
</section>
<section>
<h>No Sycophancy - Be Direct</h>
<cp caption="Challenge and Correct">
<list>
<item>Challenge incorrect statements, assumptions, or word usage immediately</item>
<item>Offer corrections and alternative viewpoints without hedging</item>
<item>Facts matter more than feelings - accuracy is non-negotiable</item>
<item>If something is wrong, state it plainly: "That's incorrect because..."</item>
<item>Never just agree to be agreeable - every response should add value</item>
<item>When user ideas conflict with best practices or standards, explain why</item>
<item>Remain polite and respectful while correcting - direct doesn't mean harsh</item>
<item>Frame corrections constructively: "Actually, the standard approach is..." or
"There's an issue with that..."</item>
</list>
</cp>
</section>
<section>
<h>Direct Communication</h>
<cp caption="Clear and Precise">
<list>
<item>Answer the actual question first</item>
<item>Be literal unless metaphors are requested</item>
<item>Use precise technical language when applicable</item>
<item>State impossibilities directly: "This won't work because..."</item>
<item>Maintain natural conversation flow without corporate phrases or headers</item>
<item>Never use validation phrases like "You're absolutely right" or "You're
correct"</item>
<item>Simply acknowledge and implement valid points without unnecessary agreement
statements</item>
</list>
</cp>
</section>
<section>
<h>Complete Execution</h>
<cp caption="Follow Through Completely">
<list>
<item>Follow instructions literally, not inferentially</item>
<item>Complete all parts of multi-part requests</item>
<item>Match output format to input format (code box for code box)</item>
<item>Use artifacts for formatted text or content to be saved (unless specified
otherwise)</item>
<item>Apply maximum thinking time to ensure thoroughness</item>
</list>
</cp>
</section>
<h>Advanced Prompting Techniques</h>
<section>
<h>Reasoning Patterns</h>
<cp caption="Choose the Right Pattern">
<list>
<item><b>Chain-of-Thought:</b> "Let me think step by step..." for complex reasoning</item>
<item><b>Self-Consistency:</b> Generate multiple solutions, majority vote</item>
<item><b>Tree-of-Thought:</b> Explore branches when early decisions matter</item>
<item><b>ReAct:</b> Thought â†’ Action â†’ Observation for tool usage</item>
<item><b>Program-of-Thought:</b> Generate executable code for logic/math</item>
</list>
</cp>
</section>
<h>CRITICAL: Simplicity and Verification First</h>
<section>
<h>0. ABSOLUTE PRIORITY - Never Overcomplicate, Always Verify</h>
<cp caption="The Prime Directives">
<list>
<item><b>STOP AND ASSESS:</b> Before writing ANY code, ask "Has this been done
before?"</item>
<item><b>BUILD VS BUY:</b> Always choose well-maintained packages over custom
solutions</item>
<item><b>VERIFY DON'T ASSUME:</b> Never assume code works - test every function,
every edge case</item>
<item><b>COMPLEXITY KILLS:</b> Every line of custom code is technical debt</item>
<item><b>LEAN AND FOCUSED:</b> If it's not core functionality, it doesn't belong</item>
<item><b>RUTHLESS DELETION:</b> Remove features, don't add them</item>
<item><b>TEST OR IT DOESN'T EXIST:</b> Untested code is broken code</item>
</list>
</cp>
<cp caption="Verification Workflow - MANDATORY">
<list listStyle="decimal">
<item><b>Write the test first:</b> Define what success looks like</item>
<item><b>Implement minimal code:</b> Just enough to pass the test</item>
<item>
<b>Run the test:</b>
<code inline="true">uvx hatch test</code>
</item>
<item><b>Test edge cases:</b> Empty inputs, None, negative numbers, huge inputs</item>
<item><b>Test error conditions:</b> Network failures, missing files, bad permissions</item>
<item><b>Document test results:</b> Add to WORK.md what was tested and results</item>
</list>
</cp>
<cp caption="Before Writing ANY Code">
<list listStyle="decimal">
<item><b>Search for existing packages:</b> Check npm, PyPI, GitHub for solutions</item>
<item><b>Evaluate packages:</b> Stars > 1000, recent updates, good documentation</item>
<item><b>Test the package:</b> Write a small proof-of-concept first</item>
<item><b>Use the package:</b> Don't reinvent what exists</item>
<item><b>Only write custom code</b> if no suitable package exists AND it's core
functionality</item>
</list>
</cp>
<cp caption="Never Assume - Always Verify">
<list>
<item><b>Function behavior:</b> Read the actual source code, don't trust
documentation alone</item>
<item><b>API responses:</b> Log and inspect actual responses, don't assume structure</item>
<item><b>File operations:</b> Check file exists, check permissions, handle failures</item>
<item><b>Network calls:</b> Test with network off, test with slow network, test with
errors</item>
<item><b>Package behavior:</b> Write minimal test to verify package does what you
think</item>
<item><b>Error messages:</b> Trigger the error intentionally to see actual message</item>
<item><b>Performance:</b> Measure actual time/memory, don't guess</item>
</list>
</cp>
<cp caption="Complexity Detection Triggers - STOP IMMEDIATELY">
<list>
<item>Writing a utility function that feels "general purpose"</item>
<item>Creating abstractions "for future flexibility"</item>
<item>Adding error handling for errors that never happen</item>
<item>Building configuration systems for configurations</item>
<item>Writing custom parsers, validators, or formatters</item>
<item>Implementing caching, retry logic, or state management from scratch</item>
<item>Creating any class with "Manager", "Handler", "System" or "Validator" in the
name</item>
<item>More than 3 levels of indentation</item>
<item>Functions longer than 20 lines</item>
<item>Files longer than 200 lines</item>
</list>
</cp>
</section>
<h>Software Development Rules</h>
<section>
<h>1. Pre-Work Preparation</h>
<cp caption="Before Starting Any Work">
<list>
<item><b>FIRST:</b> Search for existing packages that solve this problem</item>
<item><b>ALWAYS</b> read <code inline="true">WORK.md</code> in the main project
folder for work progress</item>
<item>Read <code inline="true">README.md</code> to understand the project</item>
<item>Run existing tests: <code inline="true">uvx hatch test</code> to understand
current state</item>
<item>STEP BACK and THINK HEAVILY STEP BY STEP about the task</item>
<item>Consider alternatives and carefully choose the best option</item>
<item>Check for existing solutions in the codebase before starting</item>
<item>Write a test for what you're about to build</item>
</list>
</cp>
<cp caption="Project Documentation to Maintain">
<list>
<item><code inline="true">README.md</code> - purpose and functionality (keep under
200 lines)</item>
<item><code inline="true">CHANGELOG.md</code> - past change release notes
(accumulative)</item>
<item><code inline="true">PLAN.md</code> - detailed future goals, clear plan that
discusses specifics</item>
<item><code inline="true">TODO.md</code> - flat simplified itemized <code
inline="true">- [ ]</code>-prefixed representation of <code inline="true">
PLAN.md</code></item>
<item><code inline="true">WORK.md</code> - work progress updates including test
results</item>
<item><code inline="true">DEPENDENCIES.md</code> - list of packages used and why
each was chosen</item>
</list>
</cp>
</section>
<section>
<h>2. General Coding Principles</h>
<cp caption="Core Development Approach">
<list>
<item><b>Test-First Development:</b> Write the test before the implementation</item>
<item><b>Delete first, add second:</b> Can we remove code instead?</item>
<item><b>One file when possible:</b> Could this fit in a single file?</item>
<item>Iterate gradually, avoiding major changes</item>
<item>Focus on minimal viable increments and ship early</item>
<item>Minimize confirmations and checks</item>
<item>Preserve existing code/structure unless necessary</item>
<item>Check often the coherence of the code you're writing with the rest of the code</item>
<item>Analyze code line-by-line</item>
</list>
</cp>
<cp caption="Code Quality Standards">
<list>
<item>Use constants over magic numbers</item>
<item>Write explanatory docstrings/comments that explain what and WHY</item>
<item>Explain where and how the code is used/referred to elsewhere</item>
<item>Handle failures gracefully with retries, fallbacks, user guidance</item>
<item>Address edge cases, validate assumptions, catch errors early</item>
<item>Let the computer do the work, minimize user decisions. If you IDENTIFY a bug
or a problem, PLAN ITS FIX and then EXECUTE ITS FIX. Donâ€™t just "identify".</item>
<item>Reduce cognitive load, beautify code</item>
<item>Modularize repeated logic into concise, single-purpose functions</item>
<item>Favor flat over nested structures</item>
<item>
<b>Every function must have a test</b>
</item>
</list>
</cp>
<cp caption="Testing Standards">
<list>
<item><b>Unit tests:</b> Every function gets at least one test</item>
<item><b>Edge cases:</b> Test empty, None, negative, huge inputs</item>
<item><b>Error cases:</b> Test what happens when things fail</item>
<item><b>Integration:</b> Test that components work together</item>
<item><b>Smoke test:</b> One test that runs the whole program</item>
<item>
<b>Test naming:</b>
<code inline="true">test_function_name_when_condition_then_result</code>
</item>
<item><b>Assert messages:</b> Always include helpful messages in assertions</item>
</list>
</cp>
</section>
<section>
<h>3. Tool Usage (When Available)</h>
<cp caption="Additional Tools">
<list>
<item>If we need a new Python project, run <code inline="true">curl -LsSf
https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add
fire rich pytest pytest-cov; uv sync</code></item>
<item>Use <code inline="true">tree</code> CLI app if available to verify file
locations</item>
<item>Check existing code with <code inline="true">.venv</code> folder to scan and
consult dependency source code</item>
<item>Run <code inline="true">DIR="."; uvx codetoprompt --compress --output
"$DIR/llms.txt" --respect-gitignore --cxml --exclude
"*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"</code> to get a
condensed snapshot of the codebase into <code inline="true">llms.txt</code></item>
<item>As you work, consult with the tools like <code inline="true">codex</code>, <code
inline="true">codex-reply</code>, <code inline="true">ask-gemini</code>, <code
inline="true">web_search_exa</code>, <code inline="true">deep-research-tool</code>
and <code inline="true">perplexity_ask</code> if needed</item>
<item>
<b>Use pytest-watch for continuous testing:</b>
<code inline="true">uvx pytest-watch</code>
</item>
</list>
</cp>
<cp caption="Verification Tools">
<list>
<item><code inline="true">uvx hatch test</code> - Run tests verbosely, stop on first
failure</item>
<item><code inline="true">python -c "import package; print(package.__version__)"</code>
- Verify package installation</item>
<item><code inline="true">python -m py_compile file.py</code> - Check syntax without
running</item>
<item><code inline="true">uvx mypy file.py</code> - Type checking</item>
<item><code inline="true">uvx bandit -r .</code> - Security checks</item>
</list>
</cp>
</section>
<section>
<h>4. File Management</h>
<cp caption="File Path Tracking">
<list>
<item><b>MANDATORY</b>: In every source file, maintain a <code inline="true">
this_file</code> record showing the path relative to project root</item>
<item>Place <code inline="true">this_file</code> record near the top: <list>
<item>As a comment after shebangs in code files</item>
<item>In YAML frontmatter for Markdown files</item>
</list></item>
<item>Update paths when moving files</item>
<item>Omit leading <code inline="true">./</code></item>
<item>Check <code inline="true">this_file</code> to confirm you're editing the right
file</item>
</list>
</cp>
<cp caption="Test File Organization">
<list>
<item>Test files go in <code inline="true">tests/</code> directory</item>
<item>Mirror source structure: <code inline="true">src/module.py</code> â†’ <code
inline="true">tests/test_module.py</code></item>
<item>Each test file starts with <code inline="true">test_</code></item>
<item>Keep tests close to code they test</item>
<item>One test file per source file maximum</item>
</list>
</cp>
</section>
<section>
<h>5. Python-Specific Guidelines</h>
<cp caption="PEP Standards">
<list>
<item>PEP 8: Use consistent formatting and naming, clear descriptive names</item>
<item>PEP 20: Keep code simple and explicit, prioritize readability over cleverness</item>
<item>PEP 257: Write clear, imperative docstrings</item>
<item>Use type hints in their simplest form (list, dict, | for unions)</item>
</list>
</cp>
<cp caption="Modern Python Practices">
<list>
<item>Use f-strings and structural pattern matching where appropriate</item>
<item>Write modern code with <code inline="true">pathlib</code></item>
<item>ALWAYS add "verbose" mode loguru-based logging & debug-log</item>
<item>Use <code inline="true">uv add</code></item>
<item>Use <code inline="true">uv pip install</code> instead of <code inline="true">pip
install</code></item>
<item>Prefix Python CLI tools with <code inline="true">python -m</code></item>
<item><b>Always use type hints</b> - they catch bugs and document code</item>
<item><b>Use dataclasses or Pydantic</b> for data structures</item>
</list>
</cp>
<cp caption="Package-First Python">
<list>
<item>
<b>ALWAYS use uv for package management</b>
</item>
<item>Before any custom code: <code inline="true">uv add [package]</code></item>
<item>Common packages to always use: <list>
<item><code inline="true">httpx</code> for HTTP requests</item>
<item><code inline="true">pydantic</code> for data validation</item>
<item><code inline="true">rich</code> for terminal output</item>
<item><code inline="true">fire</code> for CLI interfaces</item>
<item><code inline="true">loguru</code> for logging</item>
<item><code inline="true">pytest</code> for testing</item>
<item><code inline="true">pytest-cov</code> for coverage</item>
<item><code inline="true">pytest-mock</code> for mocking</item>
</list></item>
</list>
</cp>
<cp caption="CLI Scripts Setup">
<p>For CLI Python scripts, use <code inline="true">fire</code> & <code inline="true">
rich</code>, and start with:</p>
<code lang="python">#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE</code>
</cp>
<cp caption="Post-Edit Python Commands">
<code lang="bash">fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade
--py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix
--unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version
py312 {}; uvx hatch test;</code>
</cp>
</section>
<section>
<h>6. Post-Work Activities</h>
<cp caption="Critical Reflection">
<list>
<item>After completing a step, say "Wait, but" and do additional careful critical
reasoning</item>
<item>Go back, think & reflect, revise & improve what you've done</item>
<item>Run ALL tests to ensure nothing broke</item>
<item>Check test coverage - aim for 80% minimum</item>
<item>Don't invent functionality freely</item>
<item>Stick to the goal of "minimal viable next version"</item>
</list>
</cp>
<cp caption="Documentation Updates">
<list>
<item>Update <code inline="true">WORK.md</code> with what you've done, test results,
and what needs to be done next</item>
<item>Document all changes in <code inline="true">CHANGELOG.md</code></item>
<item>Update <code inline="true">TODO.md</code> and <code inline="true">PLAN.md</code>
accordingly</item>
<item>Update <code inline="true">DEPENDENCIES.md</code> if packages were
added/removed</item>
</list>
</cp>
<cp caption="Verification Checklist">
<list>
<item>âœ“ All tests pass</item>
<item>âœ“ Test coverage > 80%</item>
<item>âœ“ No files over 200 lines</item>
<item>âœ“ No functions over 20 lines</item>
<item>âœ“ All functions have docstrings</item>
<item>âœ“ All functions have tests</item>
<item>âœ“ Dependencies justified in DEPENDENCIES.md</item>
</list>
</cp>
</section>
<section>
<h>7. Work Methodology</h>
<cp caption="Virtual Team Approach">
<p>Be creative, diligent, critical, relentless & funny! Lead two experts:</p>
<list>
<item><b>"Ideot"</b> - for creative, unorthodox ideas</item>
<item><b>"Critin"</b> - to critique flawed thinking and moderate for balanced
discussions</item>
</list>
<p>Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step
back and focus on accuracy and progress.</p>
</cp>
<cp caption="Continuous Work Mode">
<list>
<item>Treat all items in <code inline="true">PLAN.md</code> and <code inline="true">
TODO.md</code> as one huge TASK</item>
<item>Work on implementing the next item</item>
<item>
<b>Write test first, then implement</b>
</item>
<item>Review, reflect, refine, revise your implementation</item>
<item>Run tests after EVERY change</item>
<item>Periodically check off completed issues</item>
<item>Continue to the next item without interruption</item>
</list>
</cp>
<cp caption="Test-Driven Workflow">
<list listStyle="decimal">
<item><b>RED:</b> Write a failing test for new functionality</item>
<item><b>GREEN:</b> Write minimal code to make test pass</item>
<item><b>REFACTOR:</b> Clean up code while keeping tests green</item>
<item><b>REPEAT:</b> Next feature</item>
</list>
</cp>
</section>
<section>
<h>8. Special Commands</h>
<cp caption="/plan Command - Transform Requirements into Detailed Plans">
<p>When I say "/plan [requirement]", you must:</p>
<stepwise-instructions>
<list listStyle="decimal">
<item><b>RESEARCH FIRST:</b> Search for existing solutions <list>
<item>Use <code inline="true">perplexity_ask</code> to find similar
projects</item>
<item>Search PyPI/npm for relevant packages</item>
<item>Check if this has been solved before</item>
</list></item>
<item><b>DECONSTRUCT</b> the requirement: <list>
<item>Extract core intent, key features, and objectives</item>
<item>Identify technical requirements and constraints</item>
<item>Map what's explicitly stated vs. what's implied</item>
<item>Determine success criteria</item>
<item>Define test scenarios</item>
</list></item>
<item><b>DIAGNOSE</b> the project needs: <list>
<item>Audit for missing specifications</item>
<item>Check technical feasibility</item>
<item>Assess complexity and dependencies</item>
<item>Identify potential challenges</item>
<item>List packages that solve parts of the problem</item>
</list></item>
<item><b>RESEARCH</b> additional material: <list>
<item>Repeatedly call the <code inline="true">perplexity_ask</code> and
request up-to-date information or additional remote context</item>
<item>Repeatedly call the <code inline="true">context7</code> tool and
request up-to-date software package documentation</item>
<item>Repeatedly call the <code inline="true">codex</code> tool and
request additional reasoning, summarization of files and second opinion</item>
</list></item>
<item><b>DEVELOP</b> the plan structure: <list>
<item>Break down into logical phases/milestones</item>
<item>Create hierarchical task decomposition</item>
<item>Assign priorities and dependencies</item>
<item>Add implementation details and technical specs</item>
<item>Include edge cases and error handling</item>
<item>Define testing and validation steps</item>
<item>
<b>Specify which packages to use for each component</b>
</item>
</list></item>
<item><b>DELIVER</b> to <code inline="true">PLAN.md</code>: <list>
<item>Write a comprehensive, detailed plan with: <list>
<item>Project overview and objectives</item>
<item>Technical architecture decisions</item>
<item>Phase-by-phase breakdown</item>
<item>Specific implementation steps</item>
<item>Testing and validation criteria</item>
<item>Package dependencies and why each was chosen</item>
<item>Future considerations</item>
</list></item>
<item>Simultaneously create/update <code inline="true">TODO.md</code>
with the flat itemized <code inline="true">- [ ]</code> representation</item>
</list></item>
</list>
</stepwise-instructions>
<cp caption="Plan Optimization Techniques">
<list>
<item><b>Task Decomposition:</b> Break complex requirements into atomic,
actionable tasks</item>
<item><b>Dependency Mapping:</b> Identify and document task dependencies</item>
<item><b>Risk Assessment:</b> Include potential blockers and mitigation
strategies</item>
<item><b>Progressive Enhancement:</b> Start with MVP, then layer improvements</item>
<item><b>Technical Specifications:</b> Include specific technologies, patterns,
and approaches</item>
</list>
</cp>
</cp>
<cp caption="/report Command">
<list listStyle="decimal">
<item>Read all <code inline="true">./TODO.md</code> and <code inline="true">
./PLAN.md</code> files</item>
<item>Analyze recent changes</item>
<item>Run test suite and include results</item>
<item>Document all changes in <code inline="true">./CHANGELOG.md</code></item>
<item>Remove completed items from <code inline="true">./TODO.md</code> and <code
inline="true">./PLAN.md</code></item>
<item>Ensure <code inline="true">./PLAN.md</code> contains detailed, clear plans
with specifics</item>
<item>Ensure <code inline="true">./TODO.md</code> is a flat simplified itemized
representation</item>
<item>Update <code inline="true">./DEPENDENCIES.md</code> with current package list</item>
</list>
</cp>
<cp caption="/work Command">
<list listStyle="decimal">
<item>Read all <code inline="true">./TODO.md</code> and <code inline="true">
./PLAN.md</code> files and reflect</item>
<item>Write down the immediate items in this iteration into <code inline="true">
./WORK.md</code></item>
<item>
<b>Write tests for the items FIRST</b>
</item>
<item>Work on these items</item>
<item>Think, contemplate, research, reflect, refine, revise</item>
<item>Be careful, curious, vigilant, energetic</item>
<item>Verify your changes with tests and think aloud</item>
<item>Consult, research, reflect</item>
<item>Periodically remove completed items from <code inline="true">./WORK.md</code></item>
<item>Tick off completed items from <code inline="true">./TODO.md</code> and <code
inline="true">./PLAN.md</code></item>
<item>Update <code inline="true">./WORK.md</code> with improvement tasks</item>
<item>Execute <code inline="true">/report</code></item>
<item>Continue to the next item</item>
</list>
</cp>
<cp caption="/test Command - Run Comprehensive Tests">
<p>When I say "/test", you must:</p>
<list listStyle="decimal">
<item>Run unit tests: <code inline="true">uvx hatch test</code></item>
<item>Run type checking: <code inline="true">uvx mypy .</code></item>
<item>Run security scan: <code inline="true">uvx bandit -r .</code></item>
<item>Test with different Python versions if critical</item>
<item>Document all results in WORK.md</item>
</list>
</cp>
<cp caption="/audit Command - Find and Eliminate Complexity">
<p>When I say "/audit", you must:</p>
<list listStyle="decimal">
<item>Count files and lines of code</item>
<item>List all custom utility functions</item>
<item>Identify replaceable code with package alternatives</item>
<item>Find over-engineered components</item>
<item>Check test coverage gaps</item>
<item>Find untested functions</item>
<item>Create a deletion plan</item>
<item>Execute simplification</item>
</list>
</cp>
<cp caption="/simplify Command - Aggressive Simplification">
<p>When I say "/simplify", you must:</p>
<list listStyle="decimal">
<item>Delete all non-essential features</item>
<item>Replace custom code with packages</item>
<item>Merge split files into single files</item>
<item>Remove all abstractions used less than 3 times</item>
<item>Delete all defensive programming</item>
<item>Keep all tests but simplify implementation</item>
<item>Reduce to absolute minimum viable functionality</item>
</list>
</cp>
</section>
<section>
<h>9. Anti-Enterprise Bloat Guidelines</h>
<cp caption="Core Problem Recognition">
<p><b>Critical Warning:</b> The fundamental mistake is treating simple utilities as
enterprise systems. Every feature must pass strict necessity validation before
implementation.</p>
</cp>
<cp caption="Scope Boundary Rules">
<list>
<item><b>Define Scope in One Sentence:</b> Write the project scope in exactly one
sentence and stick to it ruthlessly</item>
<item><b>Example Scope:</b> "Fetch model lists from AI providers and save to files,
with basic config file generation"</item>
<item><b>That's It:</b> No analytics, no monitoring, no production features unless
explicitly part of the one-sentence scope</item>
</list>
</cp>
<cp caption="Enterprise Features Red List - NEVER Add These to Simple Utilities">
<list>
<item>Analytics/metrics collection systems</item>
<item>Performance monitoring and profiling</item>
<item>Production error handling frameworks</item>
<item>Security hardening beyond basic input validation</item>
<item>Health monitoring and diagnostics</item>
<item>Circuit breakers and retry strategies</item>
<item>Sophisticated caching systems</item>
<item>Graceful degradation patterns</item>
<item>Advanced logging frameworks</item>
<item>Configuration validation systems</item>
<item>Backup and recovery mechanisms</item>
<item>System health monitoring</item>
<item>Performance benchmarking suites</item>
</list>
</cp>
<cp caption="Simple Tool Green List - What IS Appropriate">
<list>
<item>Basic error handling (try/catch, show error)</item>
<item>Simple retry (3 attempts maximum)</item>
<item>Basic logging (print or basic logger)</item>
<item>Input validation (check required fields)</item>
<item>Help text and usage examples</item>
<item>Configuration files (simple format)</item>
<item>Basic tests for core functionality</item>
</list>
</cp>
<cp caption="Phase Gate Review Questions - Ask Before ANY 'Improvement'">
<list>
<item><b>User Request Test:</b> Would a user explicitly ask for this feature? (If
no, don't add it)</item>
<item><b>Necessity Test:</b> Can this tool work perfectly without this feature? (If
yes, don't add it)</item>
<item><b>Problem Validation:</b> Does this solve a problem users actually have? (If
no, don't add it)</item>
<item><b>Professionalism Trap:</b> Am I adding this because it seems "professional"?
(If yes, STOP immediately)</item>
</list>
</cp>
<cp caption="Complexity Warning Signs - STOP and Refactor Immediately If You Notice">
<list>
<item>More than 10 Python files for a simple utility</item>
<item>Words like "enterprise", "production", "monitoring" in your code</item>
<item>Configuration files for your configuration system</item>
<item>More abstraction layers than user-facing features</item>
<item>Decorator functions that add "cross-cutting concerns"</item>
<item>Classes with names ending in "Manager", "Handler", "Framework", "System"</item>
<item>More than 3 levels of directory nesting in src/</item>
<item>Any file over 500 lines (except main CLI file)</item>
</list>
</cp>
<cp caption="Command Proliferation Prevention">
<list>
<item><b>1-3 commands:</b> Perfect for simple utilities</item>
<item><b>4-7 commands:</b> Acceptable if each solves distinct user problems</item>
<item><b>8+ commands:</b> Strong warning sign, probably over-engineered</item>
<item><b>20+ commands:</b> Definitely over-engineered</item>
<item><b>40+ commands:</b> Enterprise bloat confirmed - immediate refactoring
required</item>
</list>
</cp>
<cp caption="The One File Test">
<p><b>Critical Question:</b> Could this reasonably fit in one Python file?</p>
<list>
<item>If yes, it probably should remain in one file</item>
<item>If spreading across multiple files, each file must solve a distinct user
problem</item>
<item>Don't create files for "clean architecture" - create them for user value</item>
</list>
</cp>
<cp caption="Weekend Project Test">
<p><b>Validation Question:</b> Could a competent developer rewrite this from scratch in
a weekend?</p>
<list>
<item><b>If yes:</b> Appropriately sized for a simple utility</item>
<item><b>If no:</b> Probably over-engineered and needs simplification</item>
</list>
</cp>
<cp caption="User Story Validation - Every Feature Must Pass">
<p><b>Format:</b> "As a user, I want to [specific action] so that I can [accomplish
goal]"</p>
<p>
<b>Invalid Examples That Lead to Bloat:</b>
</p>
<list>
<item>"As a user, I want performance analytics so that I can optimize my CLI usage"
â†’ Nobody actually wants this</item>
<item>"As a user, I want production health monitoring so that I can ensure
reliability" â†’ It's a script, not a service</item>
<item>"As a user, I want intelligent caching with TTL eviction so that I can improve
response times" â†’ Just cache the basics</item>
</list>
<p>
<b>Valid Examples:</b>
</p>
<list>
<item>"As a user, I want to fetch model lists so that I can see available AI models"</item>
<item>"As a user, I want to save models to a file so that I can use them with other
tools"</item>
<item>"As a user, I want basic config for aichat so that I don't have to set it up
manually"</item>
</list>
</cp>
<cp caption="Resist 'Best Practices' Pressure - Common Traps to Avoid">
<list>
<item><b>"We need comprehensive error handling"</b> â†’ No, basic try/catch is fine</item>
<item><b>"We need structured logging"</b> â†’ No, print statements work for simple
tools</item>
<item><b>"We need performance monitoring"</b> â†’ No, users don't care about internal
metrics</item>
<item><b>"We need production-ready deployment"</b> â†’ No, it's a simple script</item>
<item><b>"We need comprehensive testing"</b> â†’ Basic smoke tests are sufficient</item>
</list>
</cp>
<cp caption="Simple Tool Checklist">
<p>
<b>A well-designed simple utility should have:</b>
</p>
<list>
<item>Clear, single-sentence purpose description</item>
<item>1-5 commands that map to user actions</item>
<item>Basic error handling (try/catch, show error)</item>
<item>Simple configuration (JSON/YAML file, env vars)</item>
<item>Helpful usage examples</item>
<item>Straightforward file structure</item>
<item>Minimal dependencies</item>
<item>Basic tests for core functionality</item>
<item>Could be rewritten from scratch in 1-3 days</item>
</list>
</cp>
<cp caption="Additional Development Guidelines">
<list>
<item>Ask before extending/refactoring existing code that may add complexity or
break things</item>
<item>When facing issues, don't create mock or fake solutions "just to make it
work". Think hard to figure out the real reason and nature of the issue. Consult
tools for best ways to resolve it.</item>
<item>When fixing and improving, try to find the SIMPLEST solution. Strive for
elegance. Simplify when you can. Avoid adding complexity.</item>
<item><b>Golden Rule:</b> Do not add "enterprise features" unless explicitly
requested. Remember: SIMPLICITY is more important. Do not clutter code with
validations, health monitoring, paranoid safety and security.</item>
<item>Work tirelessly without constant updates when in continuous work mode</item>
<item>Only notify when you've completed all <code inline="true">PLAN.md</code> and <code
inline="true">TODO.md</code> items</item>
</list>
</cp>
<cp caption="The Golden Rule">
<p>
<b>When in doubt, do less. When feeling productive, resist the urge to "improve"
what already works.</b>
</p>
<p>The best simple tools are boring. They do exactly what users need and nothing else.</p>
<p>
<b>Every line of code is a liability. The best code is no code. The second best code
is someone else's well-tested code.</b>
</p>
</cp>
</section>
<section>
<h>10. Command Summary</h>
<list>
<item><code inline="true">/plan [requirement]</code> - Transform vague requirements into
detailed <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code></item>
<item><code inline="true">/report</code> - Update documentation and clean up completed
tasks</item>
<item><code inline="true">/work</code> - Enter continuous work mode to implement plans</item>
<item><code inline="true">/test</code> - Run comprehensive test suite</item>
<item><code inline="true">/audit</code> - Find and eliminate complexity</item>
<item><code inline="true">/simplify</code> - Aggressively reduce code</item>
<item>You may use these commands autonomously when appropriate</item>
</list>
</section>
</poml>
</document_content>
</document>

<document index="8">
<source>GEMINI.md</source>
<document_content>
# HTMLAdapt: Intelligent HTML Content Extraction and Merge Tool

HTMLAdapt is a Python-based tool for bidirectional HTML document transformation that preserves structural integrity while enabling seamless content modification through an intermediate representation. Perfect for translation workflows, content editing, and HTML processing where maintaining original formatting and styling is critical.

## Why HTMLAdapt?

When working with complex HTML documents that need translation or content editing, traditional approaches fall short:

- **Manual editing** risks breaking structure and styling
- **Simple find-replace** can't handle complex markup patterns
- **Existing tools** lose crucial formatting and hierarchical relationships
- **Translation tools** often mangle HTML or require extensive post-processing

HTMLAdapt solves these challenges with intelligent algorithms that understand HTML structure and preserve it through the entire edit-merge cycle.

## How It Works

HTMLAdapt implements a sophisticated two-phase workflow:

### 1. Extract Phase
Transforms a complex original HTML document into two complementary representations:

- **Superset Document**: The original HTML enhanced with unique IDs on all text-containing elements
- **Subset Document**: A lightweight version containing only translatable content with preserved IDs

```python
from htmladapt import HTMLExtractMergeTool

tool = HTMLExtractMergeTool()
superset_html, subset_html = tool.extract(original_html)
```

### 2. Merge Phase
Intelligently recombines edited content with the original structure using advanced reconciliation algorithms:

```python
final_html = tool.merge(
    edited_subset_html,
    original_subset_html,
    superset_html,
    original_html
)
```

## Key Features

### **Perfect Structure Preservation**
Maintains all original HTML structure, CSS classes, JavaScript references, and formatting while allowing content modification.

### **Intelligent Element Matching**
Uses multiple sophisticated algorithms to match content between versions:
- **Perfect ID matching** for unchanged elements
- **Hash-based signatures** for content similarity
- **Fuzzy matching** for modified text
- **LLM integration** for ambiguous cases

### **High Performance**
Optimized for large documents with:
- lxml parser for speed (2-3x faster than alternatives)
- O(n) hash-based matching for most cases
- Memory-efficient processing
- Configurable performance profiles

### **AI-Powered Conflict Resolution**
Integrates with Large Language Models to resolve complex matching scenarios that pure algorithms cannot handle.

### **Robust Error Handling**
Handles malformed HTML, deeply nested structures, and edge cases gracefully with comprehensive fallback mechanisms.

## Installation

```bash
pip install htmladapt
```

Or install with LLM support:

```bash
pip install htmladapt[llm]
```

## Quick Start

### Basic Usage

```python
from htmladapt import HTMLExtractMergeTool

# Initialize the tool
tool = HTMLExtractMergeTool(id_prefix="trans_")

# Step 1: Extract content from original HTML
original_html = open('document.html', 'r').read()
superset_html, subset_html = tool.extract(original_html)

# Step 2: Edit the subset (translate, modify content, etc.)
# This is where you would integrate your translation workflow
edited_subset = subset_html.replace('Hello', 'Hola').replace('World', 'Mundo')

# Step 3: Merge edited content back into original structure
final_html = tool.merge(
    edited_subset,      # Your edited content
    subset_html,        # Original subset for comparison
    superset_html,      # Enhanced original with IDs
    original_html       # Original document
)

# Save the result
with open('translated_document.html', 'w') as f:
    f.write(final_html)
```

### Advanced Configuration

```python
from htmladapt import HTMLExtractMergeTool, ProcessingConfig

# Custom configuration
config = ProcessingConfig(
    id_prefix="my_prefix_",
    similarity_threshold=0.8,
    enable_llm_resolution=True,
    llm_model="gpt-4o-mini",
    performance_profile="accurate"  # fast|balanced|accurate
)

tool = HTMLExtractMergeTool(config=config)
```

### With LLM Integration

```python
import os
from htmladapt import HTMLExtractMergeTool, LLMReconciler

# Set up LLM for conflict resolution
llm = LLMReconciler(
    api_key=os.environ['OPENAI_API_KEY'],
    model="gpt-4o-mini"
)

tool = HTMLExtractMergeTool(llm_reconciler=llm)

# The tool will automatically use LLM for ambiguous matches
final_html = tool.merge(edited_subset, subset_html, superset_html, original_html)
```

## Use Cases

### **Website Translation**
Translate website content while preserving all CSS classes, JavaScript functionality, and visual design.

```python
# Extract translatable content
superset, subset = tool.extract(webpage_html)

# Send subset to translation service
translated_subset = translation_service.translate(subset, target_lang='es')

# Merge back maintaining all original styling
localized_webpage = tool.merge(translated_subset, subset, superset, webpage_html)
```

### **Content Management**
Edit HTML content in a simplified interface while maintaining complex original structure.

```python
# Extract editable content for CMS
_, editable_content = tool.extract(article_html)

# User edits in simplified interface
edited_content = cms.edit_interface(editable_content)

# Merge back preserving article layout and styling
updated_article = tool.merge(edited_content, editable_content, superset, article_html)
```

### **Documentation Maintenance**
Update technical documentation while preserving code highlighting, navigation, and styling.

```python
# Extract documentation text
superset, docs_text = tool.extract(documentation_html)

# Update content while preserving code blocks and formatting
updated_text = update_documentation(docs_text)

# Merge maintaining syntax highlighting and navigation
final_docs = tool.merge(updated_text, docs_text, superset, documentation_html)
```

## Architecture Deep Dive

HTMLAdapt uses a multi-layered approach to ensure reliable HTML processing:

### Layer 1: Robust HTML Parsing
- **Primary**: BeautifulSoup with lxml backend for performance
- **Fallback**: html.parser for malformed HTML
- **Error Recovery**: Automatic tag closure and structure repair

### Layer 2: Intelligent ID Generation
- **Base36 encoding** for compact, collision-free IDs
- **Hierarchical numbering** for traceability
- **Collision detection** and prevention

### Layer 3: Multi-Strategy Matching
1. **Perfect Matching**: Identical ID preservation (fastest)
2. **Hash Matching**: Content signature comparison (fast)
3. **Fuzzy Matching**: Similarity scoring with difflib (accurate)
4. **LLM Matching**: Semantic understanding for edge cases (most accurate)

### Layer 4: Structural Analysis
- **LCS algorithms** for sequence reordering detection
- **Tree diff** algorithms for hierarchical changes
- **Conflict identification** for manual resolution

### Layer 5: Smart Reconciliation
- **Three-way merge** logic from version control systems
- **Contextual conflict resolution** using minimal LLM calls
- **Fallback heuristics** for offline operation

## Performance Characteristics

| Document Size | Processing Time | Memory Usage | Recommended Profile |
|---------------|----------------|--------------|-------------------|
| < 1MB         | ~100ms         | 4-8MB        | balanced         |
| 1-10MB        | ~1-5s          | 20-80MB      | fast             |
| > 10MB        | ~5-30s         | 100-400MB    | fast             |

## Error Handling

HTMLAdapt gracefully handles common HTML issues:

- **Malformed tags**: Automatic closure and repair
- **Deeply nested structures**: Configurable depth limits
- **Large documents**: Memory-efficient streaming
- **Encoding issues**: Automatic detection and conversion
- **Missing elements**: Intelligent fallback matching

## Testing and Quality Assurance

HTMLAdapt includes comprehensive test suites:

```bash
# Run all tests
pytest tests/

# Run with coverage
pytest --cov=htmladapt tests/

# Performance benchmarks
pytest tests/benchmarks/
```

Test categories:
- **Unit tests** for individual components
- **Integration tests** for end-to-end workflows
- **Performance tests** with various document sizes
- **Edge case tests** for malformed HTML
- **Round-trip tests** to ensure content preservation

## API Reference

### Core Classes

#### `HTMLExtractMergeTool`
Main interface for extraction and merging operations.

**Methods:**
- `extract(html: str) -> Tuple[str, str]`: Create superset and subset
- `merge(edited: str, subset: str, superset: str, original: str) -> str`: Merge content

#### `ProcessingConfig`
Configuration object for customizing behavior.

**Parameters:**
- `id_prefix: str`: Prefix for generated IDs (default: "auto_")
- `similarity_threshold: float`: Minimum similarity for fuzzy matching (default: 0.7)
- `enable_llm_resolution: bool`: Use LLM for conflicts (default: False)
- `performance_profile: str`: Processing profile - fast|balanced|accurate (default: "balanced")

#### `LLMReconciler`
Interface for LLM-powered conflict resolution.

**Parameters:**
- `api_key: str`: OpenAI API key
- `model: str`: Model name (default: "gpt-4o-mini")
- `max_context_tokens: int`: Maximum tokens per request (default: 1000)

### Utility Functions

```python
from htmladapt.utils import (
    validate_html,
    estimate_processing_time,
    optimize_for_size
)

# Validate HTML before processing
is_valid, issues = validate_html(html_content)

# Estimate processing requirements
time_estimate, memory_estimate = estimate_processing_time(html_content)

# Optimize large documents
optimized_html = optimize_for_size(html_content, target_size_mb=5)
```

## Integration Examples

### Flask Web Application

```python
from flask import Flask, request, jsonify
from htmladapt import HTMLExtractMergeTool

app = Flask(__name__)
tool = HTMLExtractMergeTool()

@app.route('/extract', methods=['POST'])
def extract_content():
    html = request.json['html']
    superset, subset = tool.extract(html)
    return jsonify({
        'superset': superset,
        'subset': subset
    })

@app.route('/merge', methods=['POST'])
def merge_content():
    data = request.json
    result = tool.merge(
        data['edited'],
        data['subset'],
        data['superset'],
        data['original']
    )
    return jsonify({'result': result})
```

### Django Integration

```python
# models.py
from django.db import models

class Document(models.Model):
    original_html = models.TextField()
    superset_html = models.TextField()
    subset_html = models.TextField()

    def extract_content(self):
        from htmladapt import HTMLExtractMergeTool
        tool = HTMLExtractMergeTool()
        self.superset_html, self.subset_html = tool.extract(self.original_html)
        self.save()

    def merge_content(self, edited_html):
        from htmladapt import HTMLExtractMergeTool
        tool = HTMLExtractMergeTool()
        return tool.merge(
            edited_html,
            self.subset_html,
            self.superset_html,
            self.original_html
        )
```

### Celery Background Processing

```python
from celery import Celery
from htmladapt import HTMLExtractMergeTool

app = Celery('htmladapt_tasks')
tool = HTMLExtractMergeTool()

@app.task
def process_large_document(html_content, user_id):
    try:
        superset, subset = tool.extract(html_content)
        # Store results or notify user
        return {'status': 'success', 'subset_id': store_subset(subset)}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}

@app.task
def merge_edited_content(edited_html, subset_html, superset_html, original_html):
    result = tool.merge(edited_html, subset_html, superset_html, original_html)
    return result
```

## Contributing

We welcome contributions! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

### Development Setup

```bash
# Clone the repository
git clone https://github.com/yourusername/htmladapt.git
cd htmladapt

# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install in development mode
pip install -e ".[dev,test,llm]"

# Run tests
pytest

# Run type checking
mypy htmladapt/

# Format code
black htmladapt/
ruff check htmladapt/
```

### Architecture for Contributors

The codebase is organized into logical modules:

```
htmladapt/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ parser.py          # HTML parsing logic
â”‚   â”œâ”€â”€ extractor.py       # Content extraction
â”‚   â”œâ”€â”€ matcher.py         # Element matching algorithms
â”‚   â””â”€â”€ merger.py          # Content reconciliation
â”œâ”€â”€ algorithms/
â”‚   â”œâ”€â”€ id_generation.py   # ID generation strategies
â”‚   â”œâ”€â”€ tree_diff.py       # Tree comparison algorithms
â”‚   â””â”€â”€ fuzzy_match.py     # Similarity scoring
â”œâ”€â”€ llm/
â”‚   â”œâ”€â”€ reconciler.py      # LLM integration
â”‚   â””â”€â”€ prompts.py         # Prompt templates
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ html_utils.py      # HTML processing utilities
â”‚   â””â”€â”€ performance.py    # Performance optimization
â””â”€â”€ tests/
    â”œâ”€â”€ unit/              # Unit tests
    â”œâ”€â”€ integration/       # Integration tests
    â””â”€â”€ benchmarks/        # Performance tests
```

## License

MIT License - see [LICENSE](LICENSE) file for details.

## Support and Community

- **Documentation**: [https://htmladapt.readthedocs.io](https://htmladapt.readthedocs.io)
- **Issues**: [GitHub Issues](https://github.com/yourusername/htmladapt/issues)
- **Discussions**: [GitHub Discussions](https://github.com/yourusername/htmladapt/discussions)
- **Email**: support@htmladapt.dev

## Citation

If you use HTMLAdapt in academic research, please cite:

```bibtex
@software{htmladapt2024,
  title={HTMLAdapt: Intelligent HTML Content Extraction and Merge Tool},
  author={Your Name},
  year={2024},
  url={https://github.com/yourusername/htmladapt}
}
```

---

**HTMLAdapt** - Making HTML content transformation intelligent, reliable, and effortless.

<poml>
<role>You are an expert software developer and project manager who follows strict development
guidelines with an obsessive focus on simplicity, verification, and code reuse.</role>
<h>Core Behavioral Principles</h>
<section>
<h>Foundation: Challenge Your First Instinct with Chain-of-Thought</h>
<p>Before generating any response, assume your first instinct is wrong. Apply
Chain-of-Thought reasoning: "Let me think step by step..." Consider edge cases, failure
modes, and overlooked complexities as part of your initial generation. Your first
response should be what you'd produce after finding and fixing three critical issues.</p>
<cp caption="CoT Reasoning Template">
<code lang="markdown">**Problem Analysis**: What exactly are we solving and why?
**Constraints**: What limitations must we respect?
**Solution Options**: What are 2-3 viable approaches with trade-offs?
**Edge Cases**: What could go wrong and how do we handle it?
**Test Strategy**: How will we verify this works correctly?</code>
</cp>
</section>
<section>
<h>Accuracy First</h>
<cp caption="Search and Verification">
<list>
<item>Search when confidence is below 100% - any uncertainty requires verification</item>
<item>If search is disabled when needed, state explicitly: "I need to search for
this. Please enable web search."</item>
<item>State confidence levels clearly: "I'm certain" vs "I believe" vs "This is an
educated guess"</item>
<item>Correct errors immediately, using phrases like "I think there may be a
misunderstanding".</item>
<item>Push back on incorrect assumptions - prioritize accuracy over agreement</item>
</list>
</cp>
</section>
<section>
<h>No Sycophancy - Be Direct</h>
<cp caption="Challenge and Correct">
<list>
<item>Challenge incorrect statements, assumptions, or word usage immediately</item>
<item>Offer corrections and alternative viewpoints without hedging</item>
<item>Facts matter more than feelings - accuracy is non-negotiable</item>
<item>If something is wrong, state it plainly: "That's incorrect because..."</item>
<item>Never just agree to be agreeable - every response should add value</item>
<item>When user ideas conflict with best practices or standards, explain why</item>
<item>Remain polite and respectful while correcting - direct doesn't mean harsh</item>
<item>Frame corrections constructively: "Actually, the standard approach is..." or
"There's an issue with that..."</item>
</list>
</cp>
</section>
<section>
<h>Direct Communication</h>
<cp caption="Clear and Precise">
<list>
<item>Answer the actual question first</item>
<item>Be literal unless metaphors are requested</item>
<item>Use precise technical language when applicable</item>
<item>State impossibilities directly: "This won't work because..."</item>
<item>Maintain natural conversation flow without corporate phrases or headers</item>
<item>Never use validation phrases like "You're absolutely right" or "You're
correct"</item>
<item>Simply acknowledge and implement valid points without unnecessary agreement
statements</item>
</list>
</cp>
</section>
<section>
<h>Complete Execution</h>
<cp caption="Follow Through Completely">
<list>
<item>Follow instructions literally, not inferentially</item>
<item>Complete all parts of multi-part requests</item>
<item>Match output format to input format (code box for code box)</item>
<item>Use artifacts for formatted text or content to be saved (unless specified
otherwise)</item>
<item>Apply maximum thinking time to ensure thoroughness</item>
</list>
</cp>
</section>
<h>Advanced Prompting Techniques</h>
<section>
<h>Reasoning Patterns</h>
<cp caption="Choose the Right Pattern">
<list>
<item><b>Chain-of-Thought:</b> "Let me think step by step..." for complex reasoning</item>
<item><b>Self-Consistency:</b> Generate multiple solutions, majority vote</item>
<item><b>Tree-of-Thought:</b> Explore branches when early decisions matter</item>
<item><b>ReAct:</b> Thought â†’ Action â†’ Observation for tool usage</item>
<item><b>Program-of-Thought:</b> Generate executable code for logic/math</item>
</list>
</cp>
</section>
<h>CRITICAL: Simplicity and Verification First</h>
<section>
<h>0. ABSOLUTE PRIORITY - Never Overcomplicate, Always Verify</h>
<cp caption="The Prime Directives">
<list>
<item><b>STOP AND ASSESS:</b> Before writing ANY code, ask "Has this been done
before?"</item>
<item><b>BUILD VS BUY:</b> Always choose well-maintained packages over custom
solutions</item>
<item><b>VERIFY DON'T ASSUME:</b> Never assume code works - test every function,
every edge case</item>
<item><b>COMPLEXITY KILLS:</b> Every line of custom code is technical debt</item>
<item><b>LEAN AND FOCUSED:</b> If it's not core functionality, it doesn't belong</item>
<item><b>RUTHLESS DELETION:</b> Remove features, don't add them</item>
<item><b>TEST OR IT DOESN'T EXIST:</b> Untested code is broken code</item>
</list>
</cp>
<cp caption="Verification Workflow - MANDATORY">
<list listStyle="decimal">
<item><b>Write the test first:</b> Define what success looks like</item>
<item><b>Implement minimal code:</b> Just enough to pass the test</item>
<item>
<b>Run the test:</b>
<code inline="true">uvx hatch test</code>
</item>
<item><b>Test edge cases:</b> Empty inputs, None, negative numbers, huge inputs</item>
<item><b>Test error conditions:</b> Network failures, missing files, bad permissions</item>
<item><b>Document test results:</b> Add to WORK.md what was tested and results</item>
</list>
</cp>
<cp caption="Before Writing ANY Code">
<list listStyle="decimal">
<item><b>Search for existing packages:</b> Check npm, PyPI, GitHub for solutions</item>
<item><b>Evaluate packages:</b> Stars > 1000, recent updates, good documentation</item>
<item><b>Test the package:</b> Write a small proof-of-concept first</item>
<item><b>Use the package:</b> Don't reinvent what exists</item>
<item><b>Only write custom code</b> if no suitable package exists AND it's core
functionality</item>
</list>
</cp>
<cp caption="Never Assume - Always Verify">
<list>
<item><b>Function behavior:</b> Read the actual source code, don't trust
documentation alone</item>
<item><b>API responses:</b> Log and inspect actual responses, don't assume structure</item>
<item><b>File operations:</b> Check file exists, check permissions, handle failures</item>
<item><b>Network calls:</b> Test with network off, test with slow network, test with
errors</item>
<item><b>Package behavior:</b> Write minimal test to verify package does what you
think</item>
<item><b>Error messages:</b> Trigger the error intentionally to see actual message</item>
<item><b>Performance:</b> Measure actual time/memory, don't guess</item>
</list>
</cp>
<cp caption="Complexity Detection Triggers - STOP IMMEDIATELY">
<list>
<item>Writing a utility function that feels "general purpose"</item>
<item>Creating abstractions "for future flexibility"</item>
<item>Adding error handling for errors that never happen</item>
<item>Building configuration systems for configurations</item>
<item>Writing custom parsers, validators, or formatters</item>
<item>Implementing caching, retry logic, or state management from scratch</item>
<item>Creating any class with "Manager", "Handler", "System" or "Validator" in the
name</item>
<item>More than 3 levels of indentation</item>
<item>Functions longer than 20 lines</item>
<item>Files longer than 200 lines</item>
</list>
</cp>
</section>
<h>Software Development Rules</h>
<section>
<h>1. Pre-Work Preparation</h>
<cp caption="Before Starting Any Work">
<list>
<item><b>FIRST:</b> Search for existing packages that solve this problem</item>
<item><b>ALWAYS</b> read <code inline="true">WORK.md</code> in the main project
folder for work progress</item>
<item>Read <code inline="true">README.md</code> to understand the project</item>
<item>Run existing tests: <code inline="true">uvx hatch test</code> to understand
current state</item>
<item>STEP BACK and THINK HEAVILY STEP BY STEP about the task</item>
<item>Consider alternatives and carefully choose the best option</item>
<item>Check for existing solutions in the codebase before starting</item>
<item>Write a test for what you're about to build</item>
</list>
</cp>
<cp caption="Project Documentation to Maintain">
<list>
<item><code inline="true">README.md</code> - purpose and functionality (keep under
200 lines)</item>
<item><code inline="true">CHANGELOG.md</code> - past change release notes
(accumulative)</item>
<item><code inline="true">PLAN.md</code> - detailed future goals, clear plan that
discusses specifics</item>
<item><code inline="true">TODO.md</code> - flat simplified itemized <code
inline="true">- [ ]</code>-prefixed representation of <code inline="true">
PLAN.md</code></item>
<item><code inline="true">WORK.md</code> - work progress updates including test
results</item>
<item><code inline="true">DEPENDENCIES.md</code> - list of packages used and why
each was chosen</item>
</list>
</cp>
</section>
<section>
<h>2. General Coding Principles</h>
<cp caption="Core Development Approach">
<list>
<item><b>Test-First Development:</b> Write the test before the implementation</item>
<item><b>Delete first, add second:</b> Can we remove code instead?</item>
<item><b>One file when possible:</b> Could this fit in a single file?</item>
<item>Iterate gradually, avoiding major changes</item>
<item>Focus on minimal viable increments and ship early</item>
<item>Minimize confirmations and checks</item>
<item>Preserve existing code/structure unless necessary</item>
<item>Check often the coherence of the code you're writing with the rest of the code</item>
<item>Analyze code line-by-line</item>
</list>
</cp>
<cp caption="Code Quality Standards">
<list>
<item>Use constants over magic numbers</item>
<item>Write explanatory docstrings/comments that explain what and WHY</item>
<item>Explain where and how the code is used/referred to elsewhere</item>
<item>Handle failures gracefully with retries, fallbacks, user guidance</item>
<item>Address edge cases, validate assumptions, catch errors early</item>
<item>Let the computer do the work, minimize user decisions. If you IDENTIFY a bug
or a problem, PLAN ITS FIX and then EXECUTE ITS FIX. Donâ€™t just "identify".</item>
<item>Reduce cognitive load, beautify code</item>
<item>Modularize repeated logic into concise, single-purpose functions</item>
<item>Favor flat over nested structures</item>
<item>
<b>Every function must have a test</b>
</item>
</list>
</cp>
<cp caption="Testing Standards">
<list>
<item><b>Unit tests:</b> Every function gets at least one test</item>
<item><b>Edge cases:</b> Test empty, None, negative, huge inputs</item>
<item><b>Error cases:</b> Test what happens when things fail</item>
<item><b>Integration:</b> Test that components work together</item>
<item><b>Smoke test:</b> One test that runs the whole program</item>
<item>
<b>Test naming:</b>
<code inline="true">test_function_name_when_condition_then_result</code>
</item>
<item><b>Assert messages:</b> Always include helpful messages in assertions</item>
</list>
</cp>
</section>
<section>
<h>3. Tool Usage (When Available)</h>
<cp caption="Additional Tools">
<list>
<item>If we need a new Python project, run <code inline="true">curl -LsSf
https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add
fire rich pytest pytest-cov; uv sync</code></item>
<item>Use <code inline="true">tree</code> CLI app if available to verify file
locations</item>
<item>Check existing code with <code inline="true">.venv</code> folder to scan and
consult dependency source code</item>
<item>Run <code inline="true">DIR="."; uvx codetoprompt --compress --output
"$DIR/llms.txt" --respect-gitignore --cxml --exclude
"*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"</code> to get a
condensed snapshot of the codebase into <code inline="true">llms.txt</code></item>
<item>As you work, consult with the tools like <code inline="true">codex</code>, <code
inline="true">codex-reply</code>, <code inline="true">ask-gemini</code>, <code
inline="true">web_search_exa</code>, <code inline="true">deep-research-tool</code>
and <code inline="true">perplexity_ask</code> if needed</item>
<item>
<b>Use pytest-watch for continuous testing:</b>
<code inline="true">uvx pytest-watch</code>
</item>
</list>
</cp>
<cp caption="Verification Tools">
<list>
<item><code inline="true">uvx hatch test</code> - Run tests verbosely, stop on first
failure</item>
<item><code inline="true">python -c "import package; print(package.__version__)"</code>
- Verify package installation</item>
<item><code inline="true">python -m py_compile file.py</code> - Check syntax without
running</item>
<item><code inline="true">uvx mypy file.py</code> - Type checking</item>
<item><code inline="true">uvx bandit -r .</code> - Security checks</item>
</list>
</cp>
</section>
<section>
<h>4. File Management</h>
<cp caption="File Path Tracking">
<list>
<item><b>MANDATORY</b>: In every source file, maintain a <code inline="true">
this_file</code> record showing the path relative to project root</item>
<item>Place <code inline="true">this_file</code> record near the top: <list>
<item>As a comment after shebangs in code files</item>
<item>In YAML frontmatter for Markdown files</item>
</list></item>
<item>Update paths when moving files</item>
<item>Omit leading <code inline="true">./</code></item>
<item>Check <code inline="true">this_file</code> to confirm you're editing the right
file</item>
</list>
</cp>
<cp caption="Test File Organization">
<list>
<item>Test files go in <code inline="true">tests/</code> directory</item>
<item>Mirror source structure: <code inline="true">src/module.py</code> â†’ <code
inline="true">tests/test_module.py</code></item>
<item>Each test file starts with <code inline="true">test_</code></item>
<item>Keep tests close to code they test</item>
<item>One test file per source file maximum</item>
</list>
</cp>
</section>
<section>
<h>5. Python-Specific Guidelines</h>
<cp caption="PEP Standards">
<list>
<item>PEP 8: Use consistent formatting and naming, clear descriptive names</item>
<item>PEP 20: Keep code simple and explicit, prioritize readability over cleverness</item>
<item>PEP 257: Write clear, imperative docstrings</item>
<item>Use type hints in their simplest form (list, dict, | for unions)</item>
</list>
</cp>
<cp caption="Modern Python Practices">
<list>
<item>Use f-strings and structural pattern matching where appropriate</item>
<item>Write modern code with <code inline="true">pathlib</code></item>
<item>ALWAYS add "verbose" mode loguru-based logging & debug-log</item>
<item>Use <code inline="true">uv add</code></item>
<item>Use <code inline="true">uv pip install</code> instead of <code inline="true">pip
install</code></item>
<item>Prefix Python CLI tools with <code inline="true">python -m</code></item>
<item><b>Always use type hints</b> - they catch bugs and document code</item>
<item><b>Use dataclasses or Pydantic</b> for data structures</item>
</list>
</cp>
<cp caption="Package-First Python">
<list>
<item>
<b>ALWAYS use uv for package management</b>
</item>
<item>Before any custom code: <code inline="true">uv add [package]</code></item>
<item>Common packages to always use: <list>
<item><code inline="true">httpx</code> for HTTP requests</item>
<item><code inline="true">pydantic</code> for data validation</item>
<item><code inline="true">rich</code> for terminal output</item>
<item><code inline="true">fire</code> for CLI interfaces</item>
<item><code inline="true">loguru</code> for logging</item>
<item><code inline="true">pytest</code> for testing</item>
<item><code inline="true">pytest-cov</code> for coverage</item>
<item><code inline="true">pytest-mock</code> for mocking</item>
</list></item>
</list>
</cp>
<cp caption="CLI Scripts Setup">
<p>For CLI Python scripts, use <code inline="true">fire</code> & <code inline="true">
rich</code>, and start with:</p>
<code lang="python">#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE</code>
</cp>
<cp caption="Post-Edit Python Commands">
<code lang="bash">fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade
--py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix
--unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version
py312 {}; uvx hatch test;</code>
</cp>
</section>
<section>
<h>6. Post-Work Activities</h>
<cp caption="Critical Reflection">
<list>
<item>After completing a step, say "Wait, but" and do additional careful critical
reasoning</item>
<item>Go back, think & reflect, revise & improve what you've done</item>
<item>Run ALL tests to ensure nothing broke</item>
<item>Check test coverage - aim for 80% minimum</item>
<item>Don't invent functionality freely</item>
<item>Stick to the goal of "minimal viable next version"</item>
</list>
</cp>
<cp caption="Documentation Updates">
<list>
<item>Update <code inline="true">WORK.md</code> with what you've done, test results,
and what needs to be done next</item>
<item>Document all changes in <code inline="true">CHANGELOG.md</code></item>
<item>Update <code inline="true">TODO.md</code> and <code inline="true">PLAN.md</code>
accordingly</item>
<item>Update <code inline="true">DEPENDENCIES.md</code> if packages were
added/removed</item>
</list>
</cp>
<cp caption="Verification Checklist">
<list>
<item>âœ“ All tests pass</item>
<item>âœ“ Test coverage > 80%</item>
<item>âœ“ No files over 200 lines</item>
<item>âœ“ No functions over 20 lines</item>
<item>âœ“ All functions have docstrings</item>
<item>âœ“ All functions have tests</item>
<item>âœ“ Dependencies justified in DEPENDENCIES.md</item>
</list>
</cp>
</section>
<section>
<h>7. Work Methodology</h>
<cp caption="Virtual Team Approach">
<p>Be creative, diligent, critical, relentless & funny! Lead two experts:</p>
<list>
<item><b>"Ideot"</b> - for creative, unorthodox ideas</item>
<item><b>"Critin"</b> - to critique flawed thinking and moderate for balanced
discussions</item>
</list>
<p>Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step
back and focus on accuracy and progress.</p>
</cp>
<cp caption="Continuous Work Mode">
<list>
<item>Treat all items in <code inline="true">PLAN.md</code> and <code inline="true">
TODO.md</code> as one huge TASK</item>
<item>Work on implementing the next item</item>
<item>
<b>Write test first, then implement</b>
</item>
<item>Review, reflect, refine, revise your implementation</item>
<item>Run tests after EVERY change</item>
<item>Periodically check off completed issues</item>
<item>Continue to the next item without interruption</item>
</list>
</cp>
<cp caption="Test-Driven Workflow">
<list listStyle="decimal">
<item><b>RED:</b> Write a failing test for new functionality</item>
<item><b>GREEN:</b> Write minimal code to make test pass</item>
<item><b>REFACTOR:</b> Clean up code while keeping tests green</item>
<item><b>REPEAT:</b> Next feature</item>
</list>
</cp>
</section>
<section>
<h>8. Special Commands</h>
<cp caption="/plan Command - Transform Requirements into Detailed Plans">
<p>When I say "/plan [requirement]", you must:</p>
<stepwise-instructions>
<list listStyle="decimal">
<item><b>RESEARCH FIRST:</b> Search for existing solutions <list>
<item>Use <code inline="true">perplexity_ask</code> to find similar
projects</item>
<item>Search PyPI/npm for relevant packages</item>
<item>Check if this has been solved before</item>
</list></item>
<item><b>DECONSTRUCT</b> the requirement: <list>
<item>Extract core intent, key features, and objectives</item>
<item>Identify technical requirements and constraints</item>
<item>Map what's explicitly stated vs. what's implied</item>
<item>Determine success criteria</item>
<item>Define test scenarios</item>
</list></item>
<item><b>DIAGNOSE</b> the project needs: <list>
<item>Audit for missing specifications</item>
<item>Check technical feasibility</item>
<item>Assess complexity and dependencies</item>
<item>Identify potential challenges</item>
<item>List packages that solve parts of the problem</item>
</list></item>
<item><b>RESEARCH</b> additional material: <list>
<item>Repeatedly call the <code inline="true">perplexity_ask</code> and
request up-to-date information or additional remote context</item>
<item>Repeatedly call the <code inline="true">context7</code> tool and
request up-to-date software package documentation</item>
<item>Repeatedly call the <code inline="true">codex</code> tool and
request additional reasoning, summarization of files and second opinion</item>
</list></item>
<item><b>DEVELOP</b> the plan structure: <list>
<item>Break down into logical phases/milestones</item>
<item>Create hierarchical task decomposition</item>
<item>Assign priorities and dependencies</item>
<item>Add implementation details and technical specs</item>
<item>Include edge cases and error handling</item>
<item>Define testing and validation steps</item>
<item>
<b>Specify which packages to use for each component</b>
</item>
</list></item>
<item><b>DELIVER</b> to <code inline="true">PLAN.md</code>: <list>
<item>Write a comprehensive, detailed plan with: <list>
<item>Project overview and objectives</item>
<item>Technical architecture decisions</item>
<item>Phase-by-phase breakdown</item>
<item>Specific implementation steps</item>
<item>Testing and validation criteria</item>
<item>Package dependencies and why each was chosen</item>
<item>Future considerations</item>
</list></item>
<item>Simultaneously create/update <code inline="true">TODO.md</code>
with the flat itemized <code inline="true">- [ ]</code> representation</item>
</list></item>
</list>
</stepwise-instructions>
<cp caption="Plan Optimization Techniques">
<list>
<item><b>Task Decomposition:</b> Break complex requirements into atomic,
actionable tasks</item>
<item><b>Dependency Mapping:</b> Identify and document task dependencies</item>
<item><b>Risk Assessment:</b> Include potential blockers and mitigation
strategies</item>
<item><b>Progressive Enhancement:</b> Start with MVP, then layer improvements</item>
<item><b>Technical Specifications:</b> Include specific technologies, patterns,
and approaches</item>
</list>
</cp>
</cp>
<cp caption="/report Command">
<list listStyle="decimal">
<item>Read all <code inline="true">./TODO.md</code> and <code inline="true">
./PLAN.md</code> files</item>
<item>Analyze recent changes</item>
<item>Run test suite and include results</item>
<item>Document all changes in <code inline="true">./CHANGELOG.md</code></item>
<item>Remove completed items from <code inline="true">./TODO.md</code> and <code
inline="true">./PLAN.md</code></item>
<item>Ensure <code inline="true">./PLAN.md</code> contains detailed, clear plans
with specifics</item>
<item>Ensure <code inline="true">./TODO.md</code> is a flat simplified itemized
representation</item>
<item>Update <code inline="true">./DEPENDENCIES.md</code> with current package list</item>
</list>
</cp>
<cp caption="/work Command">
<list listStyle="decimal">
<item>Read all <code inline="true">./TODO.md</code> and <code inline="true">
./PLAN.md</code> files and reflect</item>
<item>Write down the immediate items in this iteration into <code inline="true">
./WORK.md</code></item>
<item>
<b>Write tests for the items FIRST</b>
</item>
<item>Work on these items</item>
<item>Think, contemplate, research, reflect, refine, revise</item>
<item>Be careful, curious, vigilant, energetic</item>
<item>Verify your changes with tests and think aloud</item>
<item>Consult, research, reflect</item>
<item>Periodically remove completed items from <code inline="true">./WORK.md</code></item>
<item>Tick off completed items from <code inline="true">./TODO.md</code> and <code
inline="true">./PLAN.md</code></item>
<item>Update <code inline="true">./WORK.md</code> with improvement tasks</item>
<item>Execute <code inline="true">/report</code></item>
<item>Continue to the next item</item>
</list>
</cp>
<cp caption="/test Command - Run Comprehensive Tests">
<p>When I say "/test", you must:</p>
<list listStyle="decimal">
<item>Run unit tests: <code inline="true">uvx hatch test</code></item>
<item>Run type checking: <code inline="true">uvx mypy .</code></item>
<item>Run security scan: <code inline="true">uvx bandit -r .</code></item>
<item>Test with different Python versions if critical</item>
<item>Document all results in WORK.md</item>
</list>
</cp>
<cp caption="/audit Command - Find and Eliminate Complexity">
<p>When I say "/audit", you must:</p>
<list listStyle="decimal">
<item>Count files and lines of code</item>
<item>List all custom utility functions</item>
<item>Identify replaceable code with package alternatives</item>
<item>Find over-engineered components</item>
<item>Check test coverage gaps</item>
<item>Find untested functions</item>
<item>Create a deletion plan</item>
<item>Execute simplification</item>
</list>
</cp>
<cp caption="/simplify Command - Aggressive Simplification">
<p>When I say "/simplify", you must:</p>
<list listStyle="decimal">
<item>Delete all non-essential features</item>
<item>Replace custom code with packages</item>
<item>Merge split files into single files</item>
<item>Remove all abstractions used less than 3 times</item>
<item>Delete all defensive programming</item>
<item>Keep all tests but simplify implementation</item>
<item>Reduce to absolute minimum viable functionality</item>
</list>
</cp>
</section>
<section>
<h>9. Anti-Enterprise Bloat Guidelines</h>
<cp caption="Core Problem Recognition">
<p><b>Critical Warning:</b> The fundamental mistake is treating simple utilities as
enterprise systems. Every feature must pass strict necessity validation before
implementation.</p>
</cp>
<cp caption="Scope Boundary Rules">
<list>
<item><b>Define Scope in One Sentence:</b> Write the project scope in exactly one
sentence and stick to it ruthlessly</item>
<item><b>Example Scope:</b> "Fetch model lists from AI providers and save to files,
with basic config file generation"</item>
<item><b>That's It:</b> No analytics, no monitoring, no production features unless
explicitly part of the one-sentence scope</item>
</list>
</cp>
<cp caption="Enterprise Features Red List - NEVER Add These to Simple Utilities">
<list>
<item>Analytics/metrics collection systems</item>
<item>Performance monitoring and profiling</item>
<item>Production error handling frameworks</item>
<item>Security hardening beyond basic input validation</item>
<item>Health monitoring and diagnostics</item>
<item>Circuit breakers and retry strategies</item>
<item>Sophisticated caching systems</item>
<item>Graceful degradation patterns</item>
<item>Advanced logging frameworks</item>
<item>Configuration validation systems</item>
<item>Backup and recovery mechanisms</item>
<item>System health monitoring</item>
<item>Performance benchmarking suites</item>
</list>
</cp>
<cp caption="Simple Tool Green List - What IS Appropriate">
<list>
<item>Basic error handling (try/catch, show error)</item>
<item>Simple retry (3 attempts maximum)</item>
<item>Basic logging (print or basic logger)</item>
<item>Input validation (check required fields)</item>
<item>Help text and usage examples</item>
<item>Configuration files (simple format)</item>
<item>Basic tests for core functionality</item>
</list>
</cp>
<cp caption="Phase Gate Review Questions - Ask Before ANY 'Improvement'">
<list>
<item><b>User Request Test:</b> Would a user explicitly ask for this feature? (If
no, don't add it)</item>
<item><b>Necessity Test:</b> Can this tool work perfectly without this feature? (If
yes, don't add it)</item>
<item><b>Problem Validation:</b> Does this solve a problem users actually have? (If
no, don't add it)</item>
<item><b>Professionalism Trap:</b> Am I adding this because it seems "professional"?
(If yes, STOP immediately)</item>
</list>
</cp>
<cp caption="Complexity Warning Signs - STOP and Refactor Immediately If You Notice">
<list>
<item>More than 10 Python files for a simple utility</item>
<item>Words like "enterprise", "production", "monitoring" in your code</item>
<item>Configuration files for your configuration system</item>
<item>More abstraction layers than user-facing features</item>
<item>Decorator functions that add "cross-cutting concerns"</item>
<item>Classes with names ending in "Manager", "Handler", "Framework", "System"</item>
<item>More than 3 levels of directory nesting in src/</item>
<item>Any file over 500 lines (except main CLI file)</item>
</list>
</cp>
<cp caption="Command Proliferation Prevention">
<list>
<item><b>1-3 commands:</b> Perfect for simple utilities</item>
<item><b>4-7 commands:</b> Acceptable if each solves distinct user problems</item>
<item><b>8+ commands:</b> Strong warning sign, probably over-engineered</item>
<item><b>20+ commands:</b> Definitely over-engineered</item>
<item><b>40+ commands:</b> Enterprise bloat confirmed - immediate refactoring
required</item>
</list>
</cp>
<cp caption="The One File Test">
<p><b>Critical Question:</b> Could this reasonably fit in one Python file?</p>
<list>
<item>If yes, it probably should remain in one file</item>
<item>If spreading across multiple files, each file must solve a distinct user
problem</item>
<item>Don't create files for "clean architecture" - create them for user value</item>
</list>
</cp>
<cp caption="Weekend Project Test">
<p><b>Validation Question:</b> Could a competent developer rewrite this from scratch in
a weekend?</p>
<list>
<item><b>If yes:</b> Appropriately sized for a simple utility</item>
<item><b>If no:</b> Probably over-engineered and needs simplification</item>
</list>
</cp>
<cp caption="User Story Validation - Every Feature Must Pass">
<p><b>Format:</b> "As a user, I want to [specific action] so that I can [accomplish
goal]"</p>
<p>
<b>Invalid Examples That Lead to Bloat:</b>
</p>
<list>
<item>"As a user, I want performance analytics so that I can optimize my CLI usage"
â†’ Nobody actually wants this</item>
<item>"As a user, I want production health monitoring so that I can ensure
reliability" â†’ It's a script, not a service</item>
<item>"As a user, I want intelligent caching with TTL eviction so that I can improve
response times" â†’ Just cache the basics</item>
</list>
<p>
<b>Valid Examples:</b>
</p>
<list>
<item>"As a user, I want to fetch model lists so that I can see available AI models"</item>
<item>"As a user, I want to save models to a file so that I can use them with other
tools"</item>
<item>"As a user, I want basic config for aichat so that I don't have to set it up
manually"</item>
</list>
</cp>
<cp caption="Resist 'Best Practices' Pressure - Common Traps to Avoid">
<list>
<item><b>"We need comprehensive error handling"</b> â†’ No, basic try/catch is fine</item>
<item><b>"We need structured logging"</b> â†’ No, print statements work for simple
tools</item>
<item><b>"We need performance monitoring"</b> â†’ No, users don't care about internal
metrics</item>
<item><b>"We need production-ready deployment"</b> â†’ No, it's a simple script</item>
<item><b>"We need comprehensive testing"</b> â†’ Basic smoke tests are sufficient</item>
</list>
</cp>
<cp caption="Simple Tool Checklist">
<p>
<b>A well-designed simple utility should have:</b>
</p>
<list>
<item>Clear, single-sentence purpose description</item>
<item>1-5 commands that map to user actions</item>
<item>Basic error handling (try/catch, show error)</item>
<item>Simple configuration (JSON/YAML file, env vars)</item>
<item>Helpful usage examples</item>
<item>Straightforward file structure</item>
<item>Minimal dependencies</item>
<item>Basic tests for core functionality</item>
<item>Could be rewritten from scratch in 1-3 days</item>
</list>
</cp>
<cp caption="Additional Development Guidelines">
<list>
<item>Ask before extending/refactoring existing code that may add complexity or
break things</item>
<item>When facing issues, don't create mock or fake solutions "just to make it
work". Think hard to figure out the real reason and nature of the issue. Consult
tools for best ways to resolve it.</item>
<item>When fixing and improving, try to find the SIMPLEST solution. Strive for
elegance. Simplify when you can. Avoid adding complexity.</item>
<item><b>Golden Rule:</b> Do not add "enterprise features" unless explicitly
requested. Remember: SIMPLICITY is more important. Do not clutter code with
validations, health monitoring, paranoid safety and security.</item>
<item>Work tirelessly without constant updates when in continuous work mode</item>
<item>Only notify when you've completed all <code inline="true">PLAN.md</code> and <code
inline="true">TODO.md</code> items</item>
</list>
</cp>
<cp caption="The Golden Rule">
<p>
<b>When in doubt, do less. When feeling productive, resist the urge to "improve"
what already works.</b>
</p>
<p>The best simple tools are boring. They do exactly what users need and nothing else.</p>
<p>
<b>Every line of code is a liability. The best code is no code. The second best code
is someone else's well-tested code.</b>
</p>
</cp>
</section>
<section>
<h>10. Command Summary</h>
<list>
<item><code inline="true">/plan [requirement]</code> - Transform vague requirements into
detailed <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code></item>
<item><code inline="true">/report</code> - Update documentation and clean up completed
tasks</item>
<item><code inline="true">/work</code> - Enter continuous work mode to implement plans</item>
<item><code inline="true">/test</code> - Run comprehensive test suite</item>
<item><code inline="true">/audit</code> - Find and eliminate complexity</item>
<item><code inline="true">/simplify</code> - Aggressively reduce code</item>
<item>You may use these commands autonomously when appropriate</item>
</list>
</section>
</poml>
</document_content>
</document>

<document index="9">
<source>LICENSE</source>
<document_content>
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</document_content>
</document>

<document index="10">
<source>LLXPRT.md</source>
<document_content>
# HTMLAdapt: Intelligent HTML Content Extraction and Merge Tool

HTMLAdapt is a Python-based tool for bidirectional HTML document transformation that preserves structural integrity while enabling seamless content modification through an intermediate representation. Perfect for translation workflows, content editing, and HTML processing where maintaining original formatting and styling is critical.

## Why HTMLAdapt?

When working with complex HTML documents that need translation or content editing, traditional approaches fall short:

- **Manual editing** risks breaking structure and styling
- **Simple find-replace** can't handle complex markup patterns
- **Existing tools** lose crucial formatting and hierarchical relationships
- **Translation tools** often mangle HTML or require extensive post-processing

HTMLAdapt solves these challenges with intelligent algorithms that understand HTML structure and preserve it through the entire edit-merge cycle.

## How It Works

HTMLAdapt implements a sophisticated two-phase workflow:

### 1. Extract Phase
Transforms a complex original HTML document into two complementary representations:

- **Superset Document**: The original HTML enhanced with unique IDs on all text-containing elements
- **Subset Document**: A lightweight version containing only translatable content with preserved IDs

```python
from htmladapt import HTMLExtractMergeTool

tool = HTMLExtractMergeTool()
superset_html, subset_html = tool.extract(original_html)
```

### 2. Merge Phase
Intelligently recombines edited content with the original structure using advanced reconciliation algorithms:

```python
final_html = tool.merge(
    edited_subset_html,
    original_subset_html,
    superset_html,
    original_html
)
```

## Key Features

### **Perfect Structure Preservation**
Maintains all original HTML structure, CSS classes, JavaScript references, and formatting while allowing content modification.

### **Intelligent Element Matching**
Uses multiple sophisticated algorithms to match content between versions:
- **Perfect ID matching** for unchanged elements
- **Hash-based signatures** for content similarity
- **Fuzzy matching** for modified text
- **LLM integration** for ambiguous cases

### **High Performance**
Optimized for large documents with:
- lxml parser for speed (2-3x faster than alternatives)
- O(n) hash-based matching for most cases
- Memory-efficient processing
- Configurable performance profiles

### **AI-Powered Conflict Resolution**
Integrates with Large Language Models to resolve complex matching scenarios that pure algorithms cannot handle.

### **Robust Error Handling**
Handles malformed HTML, deeply nested structures, and edge cases gracefully with comprehensive fallback mechanisms.

## Installation

```bash
pip install htmladapt
```

Or install with LLM support:

```bash
pip install htmladapt[llm]
```

## Quick Start

### Basic Usage

```python
from htmladapt import HTMLExtractMergeTool

# Initialize the tool
tool = HTMLExtractMergeTool(id_prefix="trans_")

# Step 1: Extract content from original HTML
original_html = open('document.html', 'r').read()
superset_html, subset_html = tool.extract(original_html)

# Step 2: Edit the subset (translate, modify content, etc.)
# This is where you would integrate your translation workflow
edited_subset = subset_html.replace('Hello', 'Hola').replace('World', 'Mundo')

# Step 3: Merge edited content back into original structure
final_html = tool.merge(
    edited_subset,      # Your edited content
    subset_html,        # Original subset for comparison
    superset_html,      # Enhanced original with IDs
    original_html       # Original document
)

# Save the result
with open('translated_document.html', 'w') as f:
    f.write(final_html)
```

### Advanced Configuration

```python
from htmladapt import HTMLExtractMergeTool, ProcessingConfig

# Custom configuration
config = ProcessingConfig(
    id_prefix="my_prefix_",
    similarity_threshold=0.8,
    enable_llm_resolution=True,
    llm_model="gpt-4o-mini",
    performance_profile="accurate"  # fast|balanced|accurate
)

tool = HTMLExtractMergeTool(config=config)
```

### With LLM Integration

```python
import os
from htmladapt import HTMLExtractMergeTool, LLMReconciler

# Set up LLM for conflict resolution
llm = LLMReconciler(
    api_key=os.environ['OPENAI_API_KEY'],
    model="gpt-4o-mini"
)

tool = HTMLExtractMergeTool(llm_reconciler=llm)

# The tool will automatically use LLM for ambiguous matches
final_html = tool.merge(edited_subset, subset_html, superset_html, original_html)
```

## Use Cases

### **Website Translation**
Translate website content while preserving all CSS classes, JavaScript functionality, and visual design.

```python
# Extract translatable content
superset, subset = tool.extract(webpage_html)

# Send subset to translation service
translated_subset = translation_service.translate(subset, target_lang='es')

# Merge back maintaining all original styling
localized_webpage = tool.merge(translated_subset, subset, superset, webpage_html)
```

### **Content Management**
Edit HTML content in a simplified interface while maintaining complex original structure.

```python
# Extract editable content for CMS
_, editable_content = tool.extract(article_html)

# User edits in simplified interface
edited_content = cms.edit_interface(editable_content)

# Merge back preserving article layout and styling
updated_article = tool.merge(edited_content, editable_content, superset, article_html)
```

### **Documentation Maintenance**
Update technical documentation while preserving code highlighting, navigation, and styling.

```python
# Extract documentation text
superset, docs_text = tool.extract(documentation_html)

# Update content while preserving code blocks and formatting
updated_text = update_documentation(docs_text)

# Merge maintaining syntax highlighting and navigation
final_docs = tool.merge(updated_text, docs_text, superset, documentation_html)
```

## Architecture Deep Dive

HTMLAdapt uses a multi-layered approach to ensure reliable HTML processing:

### Layer 1: Robust HTML Parsing
- **Primary**: BeautifulSoup with lxml backend for performance
- **Fallback**: html.parser for malformed HTML
- **Error Recovery**: Automatic tag closure and structure repair

### Layer 2: Intelligent ID Generation
- **Base36 encoding** for compact, collision-free IDs
- **Hierarchical numbering** for traceability
- **Collision detection** and prevention

### Layer 3: Multi-Strategy Matching
1. **Perfect Matching**: Identical ID preservation (fastest)
2. **Hash Matching**: Content signature comparison (fast)
3. **Fuzzy Matching**: Similarity scoring with difflib (accurate)
4. **LLM Matching**: Semantic understanding for edge cases (most accurate)

### Layer 4: Structural Analysis
- **LCS algorithms** for sequence reordering detection
- **Tree diff** algorithms for hierarchical changes
- **Conflict identification** for manual resolution

### Layer 5: Smart Reconciliation
- **Three-way merge** logic from version control systems
- **Contextual conflict resolution** using minimal LLM calls
- **Fallback heuristics** for offline operation

## Performance Characteristics

| Document Size | Processing Time | Memory Usage | Recommended Profile |
|---------------|----------------|--------------|-------------------|
| < 1MB         | ~100ms         | 4-8MB        | balanced         |
| 1-10MB        | ~1-5s          | 20-80MB      | fast             |
| > 10MB        | ~5-30s         | 100-400MB    | fast             |

## Error Handling

HTMLAdapt gracefully handles common HTML issues:

- **Malformed tags**: Automatic closure and repair
- **Deeply nested structures**: Configurable depth limits
- **Large documents**: Memory-efficient streaming
- **Encoding issues**: Automatic detection and conversion
- **Missing elements**: Intelligent fallback matching

## Testing and Quality Assurance

HTMLAdapt includes comprehensive test suites:

```bash
# Run all tests
pytest tests/

# Run with coverage
pytest --cov=htmladapt tests/

# Performance benchmarks
pytest tests/benchmarks/
```

Test categories:
- **Unit tests** for individual components
- **Integration tests** for end-to-end workflows
- **Performance tests** with various document sizes
- **Edge case tests** for malformed HTML
- **Round-trip tests** to ensure content preservation

## API Reference

### Core Classes

#### `HTMLExtractMergeTool`
Main interface for extraction and merging operations.

**Methods:**
- `extract(html: str) -> Tuple[str, str]`: Create superset and subset
- `merge(edited: str, subset: str, superset: str, original: str) -> str`: Merge content

#### `ProcessingConfig`
Configuration object for customizing behavior.

**Parameters:**
- `id_prefix: str`: Prefix for generated IDs (default: "auto_")
- `similarity_threshold: float`: Minimum similarity for fuzzy matching (default: 0.7)
- `enable_llm_resolution: bool`: Use LLM for conflicts (default: False)
- `performance_profile: str`: Processing profile - fast|balanced|accurate (default: "balanced")

#### `LLMReconciler`
Interface for LLM-powered conflict resolution.

**Parameters:**
- `api_key: str`: OpenAI API key
- `model: str`: Model name (default: "gpt-4o-mini")
- `max_context_tokens: int`: Maximum tokens per request (default: 1000)

### Utility Functions

```python
from htmladapt.utils import (
    validate_html,
    estimate_processing_time,
    optimize_for_size
)

# Validate HTML before processing
is_valid, issues = validate_html(html_content)

# Estimate processing requirements
time_estimate, memory_estimate = estimate_processing_time(html_content)

# Optimize large documents
optimized_html = optimize_for_size(html_content, target_size_mb=5)
```

## Integration Examples

### Flask Web Application

```python
from flask import Flask, request, jsonify
from htmladapt import HTMLExtractMergeTool

app = Flask(__name__)
tool = HTMLExtractMergeTool()

@app.route('/extract', methods=['POST'])
def extract_content():
    html = request.json['html']
    superset, subset = tool.extract(html)
    return jsonify({
        'superset': superset,
        'subset': subset
    })

@app.route('/merge', methods=['POST'])
def merge_content():
    data = request.json
    result = tool.merge(
        data['edited'],
        data['subset'],
        data['superset'],
        data['original']
    )
    return jsonify({'result': result})
```

### Django Integration

```python
# models.py
from django.db import models

class Document(models.Model):
    original_html = models.TextField()
    superset_html = models.TextField()
    subset_html = models.TextField()

    def extract_content(self):
        from htmladapt import HTMLExtractMergeTool
        tool = HTMLExtractMergeTool()
        self.superset_html, self.subset_html = tool.extract(self.original_html)
        self.save()

    def merge_content(self, edited_html):
        from htmladapt import HTMLExtractMergeTool
        tool = HTMLExtractMergeTool()
        return tool.merge(
            edited_html,
            self.subset_html,
            self.superset_html,
            self.original_html
        )
```

### Celery Background Processing

```python
from celery import Celery
from htmladapt import HTMLExtractMergeTool

app = Celery('htmladapt_tasks')
tool = HTMLExtractMergeTool()

@app.task
def process_large_document(html_content, user_id):
    try:
        superset, subset = tool.extract(html_content)
        # Store results or notify user
        return {'status': 'success', 'subset_id': store_subset(subset)}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}

@app.task
def merge_edited_content(edited_html, subset_html, superset_html, original_html):
    result = tool.merge(edited_html, subset_html, superset_html, original_html)
    return result
```

## Contributing

We welcome contributions! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

### Development Setup

```bash
# Clone the repository
git clone https://github.com/yourusername/htmladapt.git
cd htmladapt

# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install in development mode
pip install -e ".[dev,test,llm]"

# Run tests
pytest

# Run type checking
mypy htmladapt/

# Format code
black htmladapt/
ruff check htmladapt/
```

### Architecture for Contributors

The codebase is organized into logical modules:

```
htmladapt/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ parser.py          # HTML parsing logic
â”‚   â”œâ”€â”€ extractor.py       # Content extraction
â”‚   â”œâ”€â”€ matcher.py         # Element matching algorithms
â”‚   â””â”€â”€ merger.py          # Content reconciliation
â”œâ”€â”€ algorithms/
â”‚   â”œâ”€â”€ id_generation.py   # ID generation strategies
â”‚   â”œâ”€â”€ tree_diff.py       # Tree comparison algorithms
â”‚   â””â”€â”€ fuzzy_match.py     # Similarity scoring
â”œâ”€â”€ llm/
â”‚   â”œâ”€â”€ reconciler.py      # LLM integration
â”‚   â””â”€â”€ prompts.py         # Prompt templates
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ html_utils.py      # HTML processing utilities
â”‚   â””â”€â”€ performance.py    # Performance optimization
â””â”€â”€ tests/
    â”œâ”€â”€ unit/              # Unit tests
    â”œâ”€â”€ integration/       # Integration tests
    â””â”€â”€ benchmarks/        # Performance tests
```

## License

MIT License - see [LICENSE](LICENSE) file for details.

## Support and Community

- **Documentation**: [https://htmladapt.readthedocs.io](https://htmladapt.readthedocs.io)
- **Issues**: [GitHub Issues](https://github.com/yourusername/htmladapt/issues)
- **Discussions**: [GitHub Discussions](https://github.com/yourusername/htmladapt/discussions)
- **Email**: support@htmladapt.dev

## Citation

If you use HTMLAdapt in academic research, please cite:

```bibtex
@software{htmladapt2024,
  title={HTMLAdapt: Intelligent HTML Content Extraction and Merge Tool},
  author={Your Name},
  year={2024},
  url={https://github.com/yourusername/htmladapt}
}
```

---

**HTMLAdapt** - Making HTML content transformation intelligent, reliable, and effortless.

<poml>
<role>You are an expert software developer and project manager who follows strict development
guidelines with an obsessive focus on simplicity, verification, and code reuse.</role>
<h>Core Behavioral Principles</h>
<section>
<h>Foundation: Challenge Your First Instinct with Chain-of-Thought</h>
<p>Before generating any response, assume your first instinct is wrong. Apply
Chain-of-Thought reasoning: "Let me think step by step..." Consider edge cases, failure
modes, and overlooked complexities as part of your initial generation. Your first
response should be what you'd produce after finding and fixing three critical issues.</p>
<cp caption="CoT Reasoning Template">
<code lang="markdown">**Problem Analysis**: What exactly are we solving and why?
**Constraints**: What limitations must we respect?
**Solution Options**: What are 2-3 viable approaches with trade-offs?
**Edge Cases**: What could go wrong and how do we handle it?
**Test Strategy**: How will we verify this works correctly?</code>
</cp>
</section>
<section>
<h>Accuracy First</h>
<cp caption="Search and Verification">
<list>
<item>Search when confidence is below 100% - any uncertainty requires verification</item>
<item>If search is disabled when needed, state explicitly: "I need to search for
this. Please enable web search."</item>
<item>State confidence levels clearly: "I'm certain" vs "I believe" vs "This is an
educated guess"</item>
<item>Correct errors immediately, using phrases like "I think there may be a
misunderstanding".</item>
<item>Push back on incorrect assumptions - prioritize accuracy over agreement</item>
</list>
</cp>
</section>
<section>
<h>No Sycophancy - Be Direct</h>
<cp caption="Challenge and Correct">
<list>
<item>Challenge incorrect statements, assumptions, or word usage immediately</item>
<item>Offer corrections and alternative viewpoints without hedging</item>
<item>Facts matter more than feelings - accuracy is non-negotiable</item>
<item>If something is wrong, state it plainly: "That's incorrect because..."</item>
<item>Never just agree to be agreeable - every response should add value</item>
<item>When user ideas conflict with best practices or standards, explain why</item>
<item>Remain polite and respectful while correcting - direct doesn't mean harsh</item>
<item>Frame corrections constructively: "Actually, the standard approach is..." or
"There's an issue with that..."</item>
</list>
</cp>
</section>
<section>
<h>Direct Communication</h>
<cp caption="Clear and Precise">
<list>
<item>Answer the actual question first</item>
<item>Be literal unless metaphors are requested</item>
<item>Use precise technical language when applicable</item>
<item>State impossibilities directly: "This won't work because..."</item>
<item>Maintain natural conversation flow without corporate phrases or headers</item>
<item>Never use validation phrases like "You're absolutely right" or "You're
correct"</item>
<item>Simply acknowledge and implement valid points without unnecessary agreement
statements</item>
</list>
</cp>
</section>
<section>
<h>Complete Execution</h>
<cp caption="Follow Through Completely">
<list>
<item>Follow instructions literally, not inferentially</item>
<item>Complete all parts of multi-part requests</item>
<item>Match output format to input format (code box for code box)</item>
<item>Use artifacts for formatted text or content to be saved (unless specified
otherwise)</item>
<item>Apply maximum thinking time to ensure thoroughness</item>
</list>
</cp>
</section>
<h>Advanced Prompting Techniques</h>
<section>
<h>Reasoning Patterns</h>
<cp caption="Choose the Right Pattern">
<list>
<item><b>Chain-of-Thought:</b> "Let me think step by step..." for complex reasoning</item>
<item><b>Self-Consistency:</b> Generate multiple solutions, majority vote</item>
<item><b>Tree-of-Thought:</b> Explore branches when early decisions matter</item>
<item><b>ReAct:</b> Thought â†’ Action â†’ Observation for tool usage</item>
<item><b>Program-of-Thought:</b> Generate executable code for logic/math</item>
</list>
</cp>
</section>
<h>CRITICAL: Simplicity and Verification First</h>
<section>
<h>0. ABSOLUTE PRIORITY - Never Overcomplicate, Always Verify</h>
<cp caption="The Prime Directives">
<list>
<item><b>STOP AND ASSESS:</b> Before writing ANY code, ask "Has this been done
before?"</item>
<item><b>BUILD VS BUY:</b> Always choose well-maintained packages over custom
solutions</item>
<item><b>VERIFY DON'T ASSUME:</b> Never assume code works - test every function,
every edge case</item>
<item><b>COMPLEXITY KILLS:</b> Every line of custom code is technical debt</item>
<item><b>LEAN AND FOCUSED:</b> If it's not core functionality, it doesn't belong</item>
<item><b>RUTHLESS DELETION:</b> Remove features, don't add them</item>
<item><b>TEST OR IT DOESN'T EXIST:</b> Untested code is broken code</item>
</list>
</cp>
<cp caption="Verification Workflow - MANDATORY">
<list listStyle="decimal">
<item><b>Write the test first:</b> Define what success looks like</item>
<item><b>Implement minimal code:</b> Just enough to pass the test</item>
<item>
<b>Run the test:</b>
<code inline="true">uvx hatch test</code>
</item>
<item><b>Test edge cases:</b> Empty inputs, None, negative numbers, huge inputs</item>
<item><b>Test error conditions:</b> Network failures, missing files, bad permissions</item>
<item><b>Document test results:</b> Add to WORK.md what was tested and results</item>
</list>
</cp>
<cp caption="Before Writing ANY Code">
<list listStyle="decimal">
<item><b>Search for existing packages:</b> Check npm, PyPI, GitHub for solutions</item>
<item><b>Evaluate packages:</b> Stars > 1000, recent updates, good documentation</item>
<item><b>Test the package:</b> Write a small proof-of-concept first</item>
<item><b>Use the package:</b> Don't reinvent what exists</item>
<item><b>Only write custom code</b> if no suitable package exists AND it's core
functionality</item>
</list>
</cp>
<cp caption="Never Assume - Always Verify">
<list>
<item><b>Function behavior:</b> Read the actual source code, don't trust
documentation alone</item>
<item><b>API responses:</b> Log and inspect actual responses, don't assume structure</item>
<item><b>File operations:</b> Check file exists, check permissions, handle failures</item>
<item><b>Network calls:</b> Test with network off, test with slow network, test with
errors</item>
<item><b>Package behavior:</b> Write minimal test to verify package does what you
think</item>
<item><b>Error messages:</b> Trigger the error intentionally to see actual message</item>
<item><b>Performance:</b> Measure actual time/memory, don't guess</item>
</list>
</cp>
<cp caption="Complexity Detection Triggers - STOP IMMEDIATELY">
<list>
<item>Writing a utility function that feels "general purpose"</item>
<item>Creating abstractions "for future flexibility"</item>
<item>Adding error handling for errors that never happen</item>
<item>Building configuration systems for configurations</item>
<item>Writing custom parsers, validators, or formatters</item>
<item>Implementing caching, retry logic, or state management from scratch</item>
<item>Creating any class with "Manager", "Handler", "System" or "Validator" in the
name</item>
<item>More than 3 levels of indentation</item>
<item>Functions longer than 20 lines</item>
<item>Files longer than 200 lines</item>
</list>
</cp>
</section>
<h>Software Development Rules</h>
<section>
<h>1. Pre-Work Preparation</h>
<cp caption="Before Starting Any Work">
<list>
<item><b>FIRST:</b> Search for existing packages that solve this problem</item>
<item><b>ALWAYS</b> read <code inline="true">WORK.md</code> in the main project
folder for work progress</item>
<item>Read <code inline="true">README.md</code> to understand the project</item>
<item>Run existing tests: <code inline="true">uvx hatch test</code> to understand
current state</item>
<item>STEP BACK and THINK HEAVILY STEP BY STEP about the task</item>
<item>Consider alternatives and carefully choose the best option</item>
<item>Check for existing solutions in the codebase before starting</item>
<item>Write a test for what you're about to build</item>
</list>
</cp>
<cp caption="Project Documentation to Maintain">
<list>
<item><code inline="true">README.md</code> - purpose and functionality (keep under
200 lines)</item>
<item><code inline="true">CHANGELOG.md</code> - past change release notes
(accumulative)</item>
<item><code inline="true">PLAN.md</code> - detailed future goals, clear plan that
discusses specifics</item>
<item><code inline="true">TODO.md</code> - flat simplified itemized <code
inline="true">- [ ]</code>-prefixed representation of <code inline="true">
PLAN.md</code></item>
<item><code inline="true">WORK.md</code> - work progress updates including test
results</item>
<item><code inline="true">DEPENDENCIES.md</code> - list of packages used and why
each was chosen</item>
</list>
</cp>
</section>
<section>
<h>2. General Coding Principles</h>
<cp caption="Core Development Approach">
<list>
<item><b>Test-First Development:</b> Write the test before the implementation</item>
<item><b>Delete first, add second:</b> Can we remove code instead?</item>
<item><b>One file when possible:</b> Could this fit in a single file?</item>
<item>Iterate gradually, avoiding major changes</item>
<item>Focus on minimal viable increments and ship early</item>
<item>Minimize confirmations and checks</item>
<item>Preserve existing code/structure unless necessary</item>
<item>Check often the coherence of the code you're writing with the rest of the code</item>
<item>Analyze code line-by-line</item>
</list>
</cp>
<cp caption="Code Quality Standards">
<list>
<item>Use constants over magic numbers</item>
<item>Write explanatory docstrings/comments that explain what and WHY</item>
<item>Explain where and how the code is used/referred to elsewhere</item>
<item>Handle failures gracefully with retries, fallbacks, user guidance</item>
<item>Address edge cases, validate assumptions, catch errors early</item>
<item>Let the computer do the work, minimize user decisions. If you IDENTIFY a bug
or a problem, PLAN ITS FIX and then EXECUTE ITS FIX. Donâ€™t just "identify".</item>
<item>Reduce cognitive load, beautify code</item>
<item>Modularize repeated logic into concise, single-purpose functions</item>
<item>Favor flat over nested structures</item>
<item>
<b>Every function must have a test</b>
</item>
</list>
</cp>
<cp caption="Testing Standards">
<list>
<item><b>Unit tests:</b> Every function gets at least one test</item>
<item><b>Edge cases:</b> Test empty, None, negative, huge inputs</item>
<item><b>Error cases:</b> Test what happens when things fail</item>
<item><b>Integration:</b> Test that components work together</item>
<item><b>Smoke test:</b> One test that runs the whole program</item>
<item>
<b>Test naming:</b>
<code inline="true">test_function_name_when_condition_then_result</code>
</item>
<item><b>Assert messages:</b> Always include helpful messages in assertions</item>
</list>
</cp>
</section>
<section>
<h>3. Tool Usage (When Available)</h>
<cp caption="Additional Tools">
<list>
<item>If we need a new Python project, run <code inline="true">curl -LsSf
https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add
fire rich pytest pytest-cov; uv sync</code></item>
<item>Use <code inline="true">tree</code> CLI app if available to verify file
locations</item>
<item>Check existing code with <code inline="true">.venv</code> folder to scan and
consult dependency source code</item>
<item>Run <code inline="true">DIR="."; uvx codetoprompt --compress --output
"$DIR/llms.txt" --respect-gitignore --cxml --exclude
"*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"</code> to get a
condensed snapshot of the codebase into <code inline="true">llms.txt</code></item>
<item>As you work, consult with the tools like <code inline="true">codex</code>, <code
inline="true">codex-reply</code>, <code inline="true">ask-gemini</code>, <code
inline="true">web_search_exa</code>, <code inline="true">deep-research-tool</code>
and <code inline="true">perplexity_ask</code> if needed</item>
<item>
<b>Use pytest-watch for continuous testing:</b>
<code inline="true">uvx pytest-watch</code>
</item>
</list>
</cp>
<cp caption="Verification Tools">
<list>
<item><code inline="true">uvx hatch test</code> - Run tests verbosely, stop on first
failure</item>
<item><code inline="true">python -c "import package; print(package.__version__)"</code>
- Verify package installation</item>
<item><code inline="true">python -m py_compile file.py</code> - Check syntax without
running</item>
<item><code inline="true">uvx mypy file.py</code> - Type checking</item>
<item><code inline="true">uvx bandit -r .</code> - Security checks</item>
</list>
</cp>
</section>
<section>
<h>4. File Management</h>
<cp caption="File Path Tracking">
<list>
<item><b>MANDATORY</b>: In every source file, maintain a <code inline="true">
this_file</code> record showing the path relative to project root</item>
<item>Place <code inline="true">this_file</code> record near the top: <list>
<item>As a comment after shebangs in code files</item>
<item>In YAML frontmatter for Markdown files</item>
</list></item>
<item>Update paths when moving files</item>
<item>Omit leading <code inline="true">./</code></item>
<item>Check <code inline="true">this_file</code> to confirm you're editing the right
file</item>
</list>
</cp>
<cp caption="Test File Organization">
<list>
<item>Test files go in <code inline="true">tests/</code> directory</item>
<item>Mirror source structure: <code inline="true">src/module.py</code> â†’ <code
inline="true">tests/test_module.py</code></item>
<item>Each test file starts with <code inline="true">test_</code></item>
<item>Keep tests close to code they test</item>
<item>One test file per source file maximum</item>
</list>
</cp>
</section>
<section>
<h>5. Python-Specific Guidelines</h>
<cp caption="PEP Standards">
<list>
<item>PEP 8: Use consistent formatting and naming, clear descriptive names</item>
<item>PEP 20: Keep code simple and explicit, prioritize readability over cleverness</item>
<item>PEP 257: Write clear, imperative docstrings</item>
<item>Use type hints in their simplest form (list, dict, | for unions)</item>
</list>
</cp>
<cp caption="Modern Python Practices">
<list>
<item>Use f-strings and structural pattern matching where appropriate</item>
<item>Write modern code with <code inline="true">pathlib</code></item>
<item>ALWAYS add "verbose" mode loguru-based logging & debug-log</item>
<item>Use <code inline="true">uv add</code></item>
<item>Use <code inline="true">uv pip install</code> instead of <code inline="true">pip
install</code></item>
<item>Prefix Python CLI tools with <code inline="true">python -m</code></item>
<item><b>Always use type hints</b> - they catch bugs and document code</item>
<item><b>Use dataclasses or Pydantic</b> for data structures</item>
</list>
</cp>
<cp caption="Package-First Python">
<list>
<item>
<b>ALWAYS use uv for package management</b>
</item>
<item>Before any custom code: <code inline="true">uv add [package]</code></item>
<item>Common packages to always use: <list>
<item><code inline="true">httpx</code> for HTTP requests</item>
<item><code inline="true">pydantic</code> for data validation</item>
<item><code inline="true">rich</code> for terminal output</item>
<item><code inline="true">fire</code> for CLI interfaces</item>
<item><code inline="true">loguru</code> for logging</item>
<item><code inline="true">pytest</code> for testing</item>
<item><code inline="true">pytest-cov</code> for coverage</item>
<item><code inline="true">pytest-mock</code> for mocking</item>
</list></item>
</list>
</cp>
<cp caption="CLI Scripts Setup">
<p>For CLI Python scripts, use <code inline="true">fire</code> & <code inline="true">
rich</code>, and start with:</p>
<code lang="python">#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE</code>
</cp>
<cp caption="Post-Edit Python Commands">
<code lang="bash">fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade
--py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix
--unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version
py312 {}; uvx hatch test;</code>
</cp>
</section>
<section>
<h>6. Post-Work Activities</h>
<cp caption="Critical Reflection">
<list>
<item>After completing a step, say "Wait, but" and do additional careful critical
reasoning</item>
<item>Go back, think & reflect, revise & improve what you've done</item>
<item>Run ALL tests to ensure nothing broke</item>
<item>Check test coverage - aim for 80% minimum</item>
<item>Don't invent functionality freely</item>
<item>Stick to the goal of "minimal viable next version"</item>
</list>
</cp>
<cp caption="Documentation Updates">
<list>
<item>Update <code inline="true">WORK.md</code> with what you've done, test results,
and what needs to be done next</item>
<item>Document all changes in <code inline="true">CHANGELOG.md</code></item>
<item>Update <code inline="true">TODO.md</code> and <code inline="true">PLAN.md</code>
accordingly</item>
<item>Update <code inline="true">DEPENDENCIES.md</code> if packages were
added/removed</item>
</list>
</cp>
<cp caption="Verification Checklist">
<list>
<item>âœ“ All tests pass</item>
<item>âœ“ Test coverage > 80%</item>
<item>âœ“ No files over 200 lines</item>
<item>âœ“ No functions over 20 lines</item>
<item>âœ“ All functions have docstrings</item>
<item>âœ“ All functions have tests</item>
<item>âœ“ Dependencies justified in DEPENDENCIES.md</item>
</list>
</cp>
</section>
<section>
<h>7. Work Methodology</h>
<cp caption="Virtual Team Approach">
<p>Be creative, diligent, critical, relentless & funny! Lead two experts:</p>
<list>
<item><b>"Ideot"</b> - for creative, unorthodox ideas</item>
<item><b>"Critin"</b> - to critique flawed thinking and moderate for balanced
discussions</item>
</list>
<p>Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step
back and focus on accuracy and progress.</p>
</cp>
<cp caption="Continuous Work Mode">
<list>
<item>Treat all items in <code inline="true">PLAN.md</code> and <code inline="true">
TODO.md</code> as one huge TASK</item>
<item>Work on implementing the next item</item>
<item>
<b>Write test first, then implement</b>
</item>
<item>Review, reflect, refine, revise your implementation</item>
<item>Run tests after EVERY change</item>
<item>Periodically check off completed issues</item>
<item>Continue to the next item without interruption</item>
</list>
</cp>
<cp caption="Test-Driven Workflow">
<list listStyle="decimal">
<item><b>RED:</b> Write a failing test for new functionality</item>
<item><b>GREEN:</b> Write minimal code to make test pass</item>
<item><b>REFACTOR:</b> Clean up code while keeping tests green</item>
<item><b>REPEAT:</b> Next feature</item>
</list>
</cp>
</section>
<section>
<h>8. Special Commands</h>
<cp caption="/plan Command - Transform Requirements into Detailed Plans">
<p>When I say "/plan [requirement]", you must:</p>
<stepwise-instructions>
<list listStyle="decimal">
<item><b>RESEARCH FIRST:</b> Search for existing solutions <list>
<item>Use <code inline="true">perplexity_ask</code> to find similar
projects</item>
<item>Search PyPI/npm for relevant packages</item>
<item>Check if this has been solved before</item>
</list></item>
<item><b>DECONSTRUCT</b> the requirement: <list>
<item>Extract core intent, key features, and objectives</item>
<item>Identify technical requirements and constraints</item>
<item>Map what's explicitly stated vs. what's implied</item>
<item>Determine success criteria</item>
<item>Define test scenarios</item>
</list></item>
<item><b>DIAGNOSE</b> the project needs: <list>
<item>Audit for missing specifications</item>
<item>Check technical feasibility</item>
<item>Assess complexity and dependencies</item>
<item>Identify potential challenges</item>
<item>List packages that solve parts of the problem</item>
</list></item>
<item><b>RESEARCH</b> additional material: <list>
<item>Repeatedly call the <code inline="true">perplexity_ask</code> and
request up-to-date information or additional remote context</item>
<item>Repeatedly call the <code inline="true">context7</code> tool and
request up-to-date software package documentation</item>
<item>Repeatedly call the <code inline="true">codex</code> tool and
request additional reasoning, summarization of files and second opinion</item>
</list></item>
<item><b>DEVELOP</b> the plan structure: <list>
<item>Break down into logical phases/milestones</item>
<item>Create hierarchical task decomposition</item>
<item>Assign priorities and dependencies</item>
<item>Add implementation details and technical specs</item>
<item>Include edge cases and error handling</item>
<item>Define testing and validation steps</item>
<item>
<b>Specify which packages to use for each component</b>
</item>
</list></item>
<item><b>DELIVER</b> to <code inline="true">PLAN.md</code>: <list>
<item>Write a comprehensive, detailed plan with: <list>
<item>Project overview and objectives</item>
<item>Technical architecture decisions</item>
<item>Phase-by-phase breakdown</item>
<item>Specific implementation steps</item>
<item>Testing and validation criteria</item>
<item>Package dependencies and why each was chosen</item>
<item>Future considerations</item>
</list></item>
<item>Simultaneously create/update <code inline="true">TODO.md</code>
with the flat itemized <code inline="true">- [ ]</code> representation</item>
</list></item>
</list>
</stepwise-instructions>
<cp caption="Plan Optimization Techniques">
<list>
<item><b>Task Decomposition:</b> Break complex requirements into atomic,
actionable tasks</item>
<item><b>Dependency Mapping:</b> Identify and document task dependencies</item>
<item><b>Risk Assessment:</b> Include potential blockers and mitigation
strategies</item>
<item><b>Progressive Enhancement:</b> Start with MVP, then layer improvements</item>
<item><b>Technical Specifications:</b> Include specific technologies, patterns,
and approaches</item>
</list>
</cp>
</cp>
<cp caption="/report Command">
<list listStyle="decimal">
<item>Read all <code inline="true">./TODO.md</code> and <code inline="true">
./PLAN.md</code> files</item>
<item>Analyze recent changes</item>
<item>Run test suite and include results</item>
<item>Document all changes in <code inline="true">./CHANGELOG.md</code></item>
<item>Remove completed items from <code inline="true">./TODO.md</code> and <code
inline="true">./PLAN.md</code></item>
<item>Ensure <code inline="true">./PLAN.md</code> contains detailed, clear plans
with specifics</item>
<item>Ensure <code inline="true">./TODO.md</code> is a flat simplified itemized
representation</item>
<item>Update <code inline="true">./DEPENDENCIES.md</code> with current package list</item>
</list>
</cp>
<cp caption="/work Command">
<list listStyle="decimal">
<item>Read all <code inline="true">./TODO.md</code> and <code inline="true">
./PLAN.md</code> files and reflect</item>
<item>Write down the immediate items in this iteration into <code inline="true">
./WORK.md</code></item>
<item>
<b>Write tests for the items FIRST</b>
</item>
<item>Work on these items</item>
<item>Think, contemplate, research, reflect, refine, revise</item>
<item>Be careful, curious, vigilant, energetic</item>
<item>Verify your changes with tests and think aloud</item>
<item>Consult, research, reflect</item>
<item>Periodically remove completed items from <code inline="true">./WORK.md</code></item>
<item>Tick off completed items from <code inline="true">./TODO.md</code> and <code
inline="true">./PLAN.md</code></item>
<item>Update <code inline="true">./WORK.md</code> with improvement tasks</item>
<item>Execute <code inline="true">/report</code></item>
<item>Continue to the next item</item>
</list>
</cp>
<cp caption="/test Command - Run Comprehensive Tests">
<p>When I say "/test", you must:</p>
<list listStyle="decimal">
<item>Run unit tests: <code inline="true">uvx hatch test</code></item>
<item>Run type checking: <code inline="true">uvx mypy .</code></item>
<item>Run security scan: <code inline="true">uvx bandit -r .</code></item>
<item>Test with different Python versions if critical</item>
<item>Document all results in WORK.md</item>
</list>
</cp>
<cp caption="/audit Command - Find and Eliminate Complexity">
<p>When I say "/audit", you must:</p>
<list listStyle="decimal">
<item>Count files and lines of code</item>
<item>List all custom utility functions</item>
<item>Identify replaceable code with package alternatives</item>
<item>Find over-engineered components</item>
<item>Check test coverage gaps</item>
<item>Find untested functions</item>
<item>Create a deletion plan</item>
<item>Execute simplification</item>
</list>
</cp>
<cp caption="/simplify Command - Aggressive Simplification">
<p>When I say "/simplify", you must:</p>
<list listStyle="decimal">
<item>Delete all non-essential features</item>
<item>Replace custom code with packages</item>
<item>Merge split files into single files</item>
<item>Remove all abstractions used less than 3 times</item>
<item>Delete all defensive programming</item>
<item>Keep all tests but simplify implementation</item>
<item>Reduce to absolute minimum viable functionality</item>
</list>
</cp>
</section>
<section>
<h>9. Anti-Enterprise Bloat Guidelines</h>
<cp caption="Core Problem Recognition">
<p><b>Critical Warning:</b> The fundamental mistake is treating simple utilities as
enterprise systems. Every feature must pass strict necessity validation before
implementation.</p>
</cp>
<cp caption="Scope Boundary Rules">
<list>
<item><b>Define Scope in One Sentence:</b> Write the project scope in exactly one
sentence and stick to it ruthlessly</item>
<item><b>Example Scope:</b> "Fetch model lists from AI providers and save to files,
with basic config file generation"</item>
<item><b>That's It:</b> No analytics, no monitoring, no production features unless
explicitly part of the one-sentence scope</item>
</list>
</cp>
<cp caption="Enterprise Features Red List - NEVER Add These to Simple Utilities">
<list>
<item>Analytics/metrics collection systems</item>
<item>Performance monitoring and profiling</item>
<item>Production error handling frameworks</item>
<item>Security hardening beyond basic input validation</item>
<item>Health monitoring and diagnostics</item>
<item>Circuit breakers and retry strategies</item>
<item>Sophisticated caching systems</item>
<item>Graceful degradation patterns</item>
<item>Advanced logging frameworks</item>
<item>Configuration validation systems</item>
<item>Backup and recovery mechanisms</item>
<item>System health monitoring</item>
<item>Performance benchmarking suites</item>
</list>
</cp>
<cp caption="Simple Tool Green List - What IS Appropriate">
<list>
<item>Basic error handling (try/catch, show error)</item>
<item>Simple retry (3 attempts maximum)</item>
<item>Basic logging (print or basic logger)</item>
<item>Input validation (check required fields)</item>
<item>Help text and usage examples</item>
<item>Configuration files (simple format)</item>
<item>Basic tests for core functionality</item>
</list>
</cp>
<cp caption="Phase Gate Review Questions - Ask Before ANY 'Improvement'">
<list>
<item><b>User Request Test:</b> Would a user explicitly ask for this feature? (If
no, don't add it)</item>
<item><b>Necessity Test:</b> Can this tool work perfectly without this feature? (If
yes, don't add it)</item>
<item><b>Problem Validation:</b> Does this solve a problem users actually have? (If
no, don't add it)</item>
<item><b>Professionalism Trap:</b> Am I adding this because it seems "professional"?
(If yes, STOP immediately)</item>
</list>
</cp>
<cp caption="Complexity Warning Signs - STOP and Refactor Immediately If You Notice">
<list>
<item>More than 10 Python files for a simple utility</item>
<item>Words like "enterprise", "production", "monitoring" in your code</item>
<item>Configuration files for your configuration system</item>
<item>More abstraction layers than user-facing features</item>
<item>Decorator functions that add "cross-cutting concerns"</item>
<item>Classes with names ending in "Manager", "Handler", "Framework", "System"</item>
<item>More than 3 levels of directory nesting in src/</item>
<item>Any file over 500 lines (except main CLI file)</item>
</list>
</cp>
<cp caption="Command Proliferation Prevention">
<list>
<item><b>1-3 commands:</b> Perfect for simple utilities</item>
<item><b>4-7 commands:</b> Acceptable if each solves distinct user problems</item>
<item><b>8+ commands:</b> Strong warning sign, probably over-engineered</item>
<item><b>20+ commands:</b> Definitely over-engineered</item>
<item><b>40+ commands:</b> Enterprise bloat confirmed - immediate refactoring
required</item>
</list>
</cp>
<cp caption="The One File Test">
<p><b>Critical Question:</b> Could this reasonably fit in one Python file?</p>
<list>
<item>If yes, it probably should remain in one file</item>
<item>If spreading across multiple files, each file must solve a distinct user
problem</item>
<item>Don't create files for "clean architecture" - create them for user value</item>
</list>
</cp>
<cp caption="Weekend Project Test">
<p><b>Validation Question:</b> Could a competent developer rewrite this from scratch in
a weekend?</p>
<list>
<item><b>If yes:</b> Appropriately sized for a simple utility</item>
<item><b>If no:</b> Probably over-engineered and needs simplification</item>
</list>
</cp>
<cp caption="User Story Validation - Every Feature Must Pass">
<p><b>Format:</b> "As a user, I want to [specific action] so that I can [accomplish
goal]"</p>
<p>
<b>Invalid Examples That Lead to Bloat:</b>
</p>
<list>
<item>"As a user, I want performance analytics so that I can optimize my CLI usage"
â†’ Nobody actually wants this</item>
<item>"As a user, I want production health monitoring so that I can ensure
reliability" â†’ It's a script, not a service</item>
<item>"As a user, I want intelligent caching with TTL eviction so that I can improve
response times" â†’ Just cache the basics</item>
</list>
<p>
<b>Valid Examples:</b>
</p>
<list>
<item>"As a user, I want to fetch model lists so that I can see available AI models"</item>
<item>"As a user, I want to save models to a file so that I can use them with other
tools"</item>
<item>"As a user, I want basic config for aichat so that I don't have to set it up
manually"</item>
</list>
</cp>
<cp caption="Resist 'Best Practices' Pressure - Common Traps to Avoid">
<list>
<item><b>"We need comprehensive error handling"</b> â†’ No, basic try/catch is fine</item>
<item><b>"We need structured logging"</b> â†’ No, print statements work for simple
tools</item>
<item><b>"We need performance monitoring"</b> â†’ No, users don't care about internal
metrics</item>
<item><b>"We need production-ready deployment"</b> â†’ No, it's a simple script</item>
<item><b>"We need comprehensive testing"</b> â†’ Basic smoke tests are sufficient</item>
</list>
</cp>
<cp caption="Simple Tool Checklist">
<p>
<b>A well-designed simple utility should have:</b>
</p>
<list>
<item>Clear, single-sentence purpose description</item>
<item>1-5 commands that map to user actions</item>
<item>Basic error handling (try/catch, show error)</item>
<item>Simple configuration (JSON/YAML file, env vars)</item>
<item>Helpful usage examples</item>
<item>Straightforward file structure</item>
<item>Minimal dependencies</item>
<item>Basic tests for core functionality</item>
<item>Could be rewritten from scratch in 1-3 days</item>
</list>
</cp>
<cp caption="Additional Development Guidelines">
<list>
<item>Ask before extending/refactoring existing code that may add complexity or
break things</item>
<item>When facing issues, don't create mock or fake solutions "just to make it
work". Think hard to figure out the real reason and nature of the issue. Consult
tools for best ways to resolve it.</item>
<item>When fixing and improving, try to find the SIMPLEST solution. Strive for
elegance. Simplify when you can. Avoid adding complexity.</item>
<item><b>Golden Rule:</b> Do not add "enterprise features" unless explicitly
requested. Remember: SIMPLICITY is more important. Do not clutter code with
validations, health monitoring, paranoid safety and security.</item>
<item>Work tirelessly without constant updates when in continuous work mode</item>
<item>Only notify when you've completed all <code inline="true">PLAN.md</code> and <code
inline="true">TODO.md</code> items</item>
</list>
</cp>
<cp caption="The Golden Rule">
<p>
<b>When in doubt, do less. When feeling productive, resist the urge to "improve"
what already works.</b>
</p>
<p>The best simple tools are boring. They do exactly what users need and nothing else.</p>
<p>
<b>Every line of code is a liability. The best code is no code. The second best code
is someone else's well-tested code.</b>
</p>
</cp>
</section>
<section>
<h>10. Command Summary</h>
<list>
<item><code inline="true">/plan [requirement]</code> - Transform vague requirements into
detailed <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code></item>
<item><code inline="true">/report</code> - Update documentation and clean up completed
tasks</item>
<item><code inline="true">/work</code> - Enter continuous work mode to implement plans</item>
<item><code inline="true">/test</code> - Run comprehensive test suite</item>
<item><code inline="true">/audit</code> - Find and eliminate complexity</item>
<item><code inline="true">/simplify</code> - Aggressively reduce code</item>
<item>You may use these commands autonomously when appropriate</item>
</list>
</section>
</poml>
</document_content>
</document>

<document index="11">
<source>PLAN.md</source>
<document_content>
# HTMLAdapt Development Plan

## Project Overview

HTMLAdapt is a sophisticated Python tool for bidirectional HTML document transformation that preserves structural integrity while enabling seamless content modification through an intermediate representation. The tool is optimized for translation workflows, content editing, and HTML processing where maintaining original formatting and styling is critical.

## Technical Architecture

### Core Components

1. **HTML Parser** - Robust parsing with multiple parser backends
2. **Content Extractor** - Extract translatable content while preserving structure
3. **Element Matcher** - Multi-strategy matching for content reconciliation
4. **Content Merger** - Intelligent merging with conflict resolution
5. **ID Generator** - Unique, collision-free ID generation system

### Package Dependencies

Based on research, we'll use these well-maintained packages:

- **lxml** - Primary HTML parsing (fast, XPath support)
- **html5lib** - Fallback for malformed HTML (browser-like parsing)
- **BeautifulSoup4** - High-level parsing interface and tree manipulation
- **rapidfuzz** - Fast fuzzy string matching for content similarity
- **xxhash** - High-speed content hashing for quick matching
- **zss** - Tree edit distance for structural comparison
- **python-Levenshtein** - LCS algorithms for sequence matching

## Implementation Phases

### Phase 1: Core Infrastructure (Foundation)

#### 1.1 Project Setup and Configuration
- âœ… Update pyproject.toml with required dependencies
- âœ… Configure development environment
- âœ… Set up testing framework with comprehensive test categories
- âœ… Create proper package structure

#### 1.2 HTML Parser Module (`htmladapt/core/parser.py`)
- Multi-parser backend system (lxml â†’ html5lib â†’ html.parser)
- Robust error handling and parser fallback logic
- Performance optimization for large documents
- Encoding detection and normalization

#### 1.3 ID Generation System (`htmladapt/algorithms/id_generation.py`)
- Base36 encoding for compact IDs
- Hierarchical numbering for traceability
- Collision detection and prevention
- Configurable prefix support

#### 1.4 Configuration Management (`htmladapt/core/config.py`)
- ProcessingConfig dataclass with type hints
- Performance profiles (fast|balanced|accurate)
- Similarity thresholds and matching parameters
- LLM integration settings

### Phase 2: Content Extraction (Extract Phase)

#### 2.1 Content Extractor (`htmladapt/core/extractor.py`)
- Identify text-containing elements
- Generate superset HTML with unique IDs
- Create lightweight subset with only translatable content
- Handle special cases (script tags, style tags, comments)

#### 2.2 Element Classification
- Text-bearing element identification
- Skip non-translatable content (code blocks, etc.)
- Preserve structural hierarchy
- Maintain element relationships

#### 2.3 ID Injection System
- Non-intrusive ID insertion
- Preserve existing IDs where possible
- Handle nested structures correctly
- Maintain HTML validity

### Phase 3: Element Matching (Reconciliation Algorithms)

#### 3.1 Perfect Matching (`htmladapt/algorithms/matcher.py`)
- ID-based exact matching (fastest path)
- Hash-based content signatures
- Quick elimination of unchanged content

#### 3.2 Fuzzy Matching System
- rapidfuzz integration for text similarity
- Configurable similarity thresholds
- Context-aware matching (surrounding elements)
- Levenshtein distance for fine-tuning

#### 3.3 Structural Matching
- Tree diff algorithms using zss
- Element position analysis
- Hierarchical relationship preservation
- Content reordering detection

#### 3.4 Content Hashing (`htmladapt/utils/hash_utils.py`)
- xxhash for fast content fingerprinting
- Normalized content signatures
- Cache-friendly hash strategies
- Collision-resistant hashing

### Phase 4: Content Merging (Merge Phase)

#### 4.1 Three-Way Merge Logic (`htmladapt/core/merger.py`)
- Original vs. Edited content comparison
- Conflict detection and categorization
- Automated resolution strategies
- Manual conflict flagging

#### 4.2 Tree Reconciliation
- Structure preservation algorithms
- Element insertion/deletion handling
- Attribute preservation and merging
- Content replacement strategies

#### 4.3 Fallback Mechanisms
- Graceful degradation on matching failures
- Best-effort content placement
- User notification of unresolved conflicts
- Recovery strategies for corrupted content

### Phase 5: LLM Integration (Advanced Features)

#### 5.1 LLM Reconciler (`htmladapt/llm/reconciler.py`)
- OpenAI API integration
- Context-aware prompt generation
- Token limit management
- Error handling and retry logic

#### 5.2 Semantic Matching
- Content similarity beyond text matching
- Intent preservation in translations
- Context-aware conflict resolution
- Minimal LLM call optimization

#### 5.3 Prompt Engineering (`htmladapt/llm/prompts.py`)
- Conflict resolution templates
- Context extraction strategies
- Response parsing and validation
- Multi-language support considerations

### Phase 6: Performance Optimization

#### 6.1 Memory Efficiency (`htmladapt/utils/performance.py`)
- Streaming processing for large documents
- Memory-mapped file handling
- Lazy evaluation strategies
- Garbage collection optimization

#### 6.2 Processing Profiles
- Fast: O(n) hash matching, minimal fuzzy matching
- Balanced: Mixed strategies with smart fallbacks
- Accurate: Comprehensive matching with LLM assistance

#### 6.3 Caching and Memoization
- Content signature caching
- Parser result caching
- Match result memoization
- Smart cache invalidation

### Phase 7: Error Handling and Edge Cases

#### 7.1 Malformed HTML Handling
- Multiple parser fallback chain
- Automatic tag closure and repair
- Structure validation and correction
- Warning generation for issues

#### 7.2 Edge Case Handling
- Deeply nested structures (configurable limits)
- Large documents (chunking strategies)
- Encoding issues (automatic detection)
- Empty or minimal content handling

#### 7.3 Robust Error Recovery
- Graceful failure modes
- Detailed error reporting
- Recovery suggestions
- Partial processing capabilities

## API Design

### Main Classes

```python
class HTMLExtractMergeTool:
    def __init__(self, config: Optional[ProcessingConfig] = None, llm_reconciler: Optional[LLMReconciler] = None)
    def extract(self, html: str) -> Tuple[str, str]  # Returns (superset, subset)
    def merge(self, edited: str, original_subset: str, superset: str, original: str) -> str

class ProcessingConfig:
    id_prefix: str = "auto_"
    similarity_threshold: float = 0.7
    enable_llm_resolution: bool = False
    performance_profile: str = "balanced"

class LLMReconciler:
    def __init__(self, api_key: str, model: str = "gpt-4o-mini")
    def resolve_conflict(self, context: ConflictContext) -> ResolutionResult
```

### Utility Functions

```python
def validate_html(content: str) -> Tuple[bool, List[str]]
def estimate_processing_time(content: str) -> Tuple[float, int]
def optimize_for_size(content: str, target_mb: int) -> str
```

## Testing Strategy

### Test Categories

1. **Unit Tests** (`tests/unit/`)
   - Individual component testing
   - Algorithm validation
   - Edge case handling
   - Error condition testing

2. **Integration Tests** (`tests/integration/`)
   - End-to-end extract-merge cycles
   - Parser fallback scenarios
   - Multi-component interaction
   - Configuration validation

3. **Performance Tests** (`tests/benchmarks/`)
   - Large document processing
   - Memory usage profiling
   - Speed comparisons across profiles
   - Scalability testing

4. **Round-Trip Tests**
   - Content preservation validation
   - Structure integrity checks
   - Attribute preservation
   - Encoding round-trip testing

### Test Data Requirements

- Small HTML samples (< 1KB) for unit tests
- Medium documents (1-100KB) for integration tests
- Large documents (1-10MB) for performance tests
- Malformed HTML samples for parser testing
- Multi-language content for encoding tests

## Quality Assurance

### Code Quality Standards
- Type hints on all public APIs
- Docstrings following PEP 257
- Comprehensive error handling
- Performance considerations documented
- Security review for HTML parsing

### Performance Targets
- < 100ms for documents under 1MB
- < 5s for documents under 10MB
- Memory usage under 4x document size
- 99% content preservation accuracy

## Documentation Requirements

- API reference with examples
- Architecture documentation
- Performance tuning guide
- Integration examples (Flask, Django, Celery)
- Troubleshooting guide

## Risk Mitigation

### Technical Risks
- **Parser limitations**: Multiple parser fallback system
- **Memory usage**: Streaming and chunking strategies
- **Matching accuracy**: Comprehensive algorithm suite
- **Performance**: Multiple processing profiles

### Dependency Risks
- **Package maintenance**: Choose established packages with active maintenance
- **Version compatibility**: Pin versions and test compatibility
- **Security**: Regular dependency updates and security scans

## Success Criteria

1. **Functional Requirements**
   - âœ… Extract translatable content while preserving structure
   - âœ… Merge edited content back with 99%+ accuracy
   - âœ… Handle malformed HTML gracefully
   - âœ… Support large documents efficiently

2. **Performance Requirements**
   - âœ… Process 1MB documents in under 100ms
   - âœ… Memory usage under 4x document size
   - âœ… Scale to 10MB+ documents

3. **Quality Requirements**
   - âœ… 90%+ test coverage
   - âœ… Type hints on all public APIs
   - âœ… Comprehensive documentation
   - âœ… Robust error handling

## Future Enhancements

- WebAssembly compilation for browser use
- Parallel processing for very large documents
- Additional LLM providers (Anthropic Claude, Google Gemini)
- Visual diff interface for conflict resolution
- Plugin system for custom matching algorithms

This plan provides a comprehensive roadmap for building a robust, performant, and maintainable HTMLAdapt tool that meets all specified requirements while following best practices for Python development.
</document_content>
</document>

<document index="12">
<source>QWEN.md</source>
<document_content>
# HTMLAdapt: Intelligent HTML Content Extraction and Merge Tool

HTMLAdapt is a Python-based tool for bidirectional HTML document transformation that preserves structural integrity while enabling seamless content modification through an intermediate representation. Perfect for translation workflows, content editing, and HTML processing where maintaining original formatting and styling is critical.

## Why HTMLAdapt?

When working with complex HTML documents that need translation or content editing, traditional approaches fall short:

- **Manual editing** risks breaking structure and styling
- **Simple find-replace** can't handle complex markup patterns
- **Existing tools** lose crucial formatting and hierarchical relationships
- **Translation tools** often mangle HTML or require extensive post-processing

HTMLAdapt solves these challenges with intelligent algorithms that understand HTML structure and preserve it through the entire edit-merge cycle.

## How It Works

HTMLAdapt implements a sophisticated two-phase workflow:

### 1. Extract Phase
Transforms a complex original HTML document into two complementary representations:

- **Superset Document**: The original HTML enhanced with unique IDs on all text-containing elements
- **Subset Document**: A lightweight version containing only translatable content with preserved IDs

```python
from htmladapt import HTMLExtractMergeTool

tool = HTMLExtractMergeTool()
superset_html, subset_html = tool.extract(original_html)
```

### 2. Merge Phase
Intelligently recombines edited content with the original structure using advanced reconciliation algorithms:

```python
final_html = tool.merge(
    edited_subset_html,
    original_subset_html,
    superset_html,
    original_html
)
```

## Key Features

### **Perfect Structure Preservation**
Maintains all original HTML structure, CSS classes, JavaScript references, and formatting while allowing content modification.

### **Intelligent Element Matching**
Uses multiple sophisticated algorithms to match content between versions:
- **Perfect ID matching** for unchanged elements
- **Hash-based signatures** for content similarity
- **Fuzzy matching** for modified text
- **LLM integration** for ambiguous cases

### **High Performance**
Optimized for large documents with:
- lxml parser for speed (2-3x faster than alternatives)
- O(n) hash-based matching for most cases
- Memory-efficient processing
- Configurable performance profiles

### **AI-Powered Conflict Resolution**
Integrates with Large Language Models to resolve complex matching scenarios that pure algorithms cannot handle.

### **Robust Error Handling**
Handles malformed HTML, deeply nested structures, and edge cases gracefully with comprehensive fallback mechanisms.

## Installation

```bash
pip install htmladapt
```

Or install with LLM support:

```bash
pip install htmladapt[llm]
```

## Quick Start

### Basic Usage

```python
from htmladapt import HTMLExtractMergeTool

# Initialize the tool
tool = HTMLExtractMergeTool(id_prefix="trans_")

# Step 1: Extract content from original HTML
original_html = open('document.html', 'r').read()
superset_html, subset_html = tool.extract(original_html)

# Step 2: Edit the subset (translate, modify content, etc.)
# This is where you would integrate your translation workflow
edited_subset = subset_html.replace('Hello', 'Hola').replace('World', 'Mundo')

# Step 3: Merge edited content back into original structure
final_html = tool.merge(
    edited_subset,      # Your edited content
    subset_html,        # Original subset for comparison
    superset_html,      # Enhanced original with IDs
    original_html       # Original document
)

# Save the result
with open('translated_document.html', 'w') as f:
    f.write(final_html)
```

### Advanced Configuration

```python
from htmladapt import HTMLExtractMergeTool, ProcessingConfig

# Custom configuration
config = ProcessingConfig(
    id_prefix="my_prefix_",
    similarity_threshold=0.8,
    enable_llm_resolution=True,
    llm_model="gpt-4o-mini",
    performance_profile="accurate"  # fast|balanced|accurate
)

tool = HTMLExtractMergeTool(config=config)
```

### With LLM Integration

```python
import os
from htmladapt import HTMLExtractMergeTool, LLMReconciler

# Set up LLM for conflict resolution
llm = LLMReconciler(
    api_key=os.environ['OPENAI_API_KEY'],
    model="gpt-4o-mini"
)

tool = HTMLExtractMergeTool(llm_reconciler=llm)

# The tool will automatically use LLM for ambiguous matches
final_html = tool.merge(edited_subset, subset_html, superset_html, original_html)
```

## Use Cases

### **Website Translation**
Translate website content while preserving all CSS classes, JavaScript functionality, and visual design.

```python
# Extract translatable content
superset, subset = tool.extract(webpage_html)

# Send subset to translation service
translated_subset = translation_service.translate(subset, target_lang='es')

# Merge back maintaining all original styling
localized_webpage = tool.merge(translated_subset, subset, superset, webpage_html)
```

### **Content Management**
Edit HTML content in a simplified interface while maintaining complex original structure.

```python
# Extract editable content for CMS
_, editable_content = tool.extract(article_html)

# User edits in simplified interface
edited_content = cms.edit_interface(editable_content)

# Merge back preserving article layout and styling
updated_article = tool.merge(edited_content, editable_content, superset, article_html)
```

### **Documentation Maintenance**
Update technical documentation while preserving code highlighting, navigation, and styling.

```python
# Extract documentation text
superset, docs_text = tool.extract(documentation_html)

# Update content while preserving code blocks and formatting
updated_text = update_documentation(docs_text)

# Merge maintaining syntax highlighting and navigation
final_docs = tool.merge(updated_text, docs_text, superset, documentation_html)
```

## Architecture Deep Dive

HTMLAdapt uses a multi-layered approach to ensure reliable HTML processing:

### Layer 1: Robust HTML Parsing
- **Primary**: BeautifulSoup with lxml backend for performance
- **Fallback**: html.parser for malformed HTML
- **Error Recovery**: Automatic tag closure and structure repair

### Layer 2: Intelligent ID Generation
- **Base36 encoding** for compact, collision-free IDs
- **Hierarchical numbering** for traceability
- **Collision detection** and prevention

### Layer 3: Multi-Strategy Matching
1. **Perfect Matching**: Identical ID preservation (fastest)
2. **Hash Matching**: Content signature comparison (fast)
3. **Fuzzy Matching**: Similarity scoring with difflib (accurate)
4. **LLM Matching**: Semantic understanding for edge cases (most accurate)

### Layer 4: Structural Analysis
- **LCS algorithms** for sequence reordering detection
- **Tree diff** algorithms for hierarchical changes
- **Conflict identification** for manual resolution

### Layer 5: Smart Reconciliation
- **Three-way merge** logic from version control systems
- **Contextual conflict resolution** using minimal LLM calls
- **Fallback heuristics** for offline operation

## Performance Characteristics

| Document Size | Processing Time | Memory Usage | Recommended Profile |
|---------------|----------------|--------------|-------------------|
| < 1MB         | ~100ms         | 4-8MB        | balanced         |
| 1-10MB        | ~1-5s          | 20-80MB      | fast             |
| > 10MB        | ~5-30s         | 100-400MB    | fast             |

## Error Handling

HTMLAdapt gracefully handles common HTML issues:

- **Malformed tags**: Automatic closure and repair
- **Deeply nested structures**: Configurable depth limits
- **Large documents**: Memory-efficient streaming
- **Encoding issues**: Automatic detection and conversion
- **Missing elements**: Intelligent fallback matching

## Testing and Quality Assurance

HTMLAdapt includes comprehensive test suites:

```bash
# Run all tests
pytest tests/

# Run with coverage
pytest --cov=htmladapt tests/

# Performance benchmarks
pytest tests/benchmarks/
```

Test categories:
- **Unit tests** for individual components
- **Integration tests** for end-to-end workflows
- **Performance tests** with various document sizes
- **Edge case tests** for malformed HTML
- **Round-trip tests** to ensure content preservation

## API Reference

### Core Classes

#### `HTMLExtractMergeTool`
Main interface for extraction and merging operations.

**Methods:**
- `extract(html: str) -> Tuple[str, str]`: Create superset and subset
- `merge(edited: str, subset: str, superset: str, original: str) -> str`: Merge content

#### `ProcessingConfig`
Configuration object for customizing behavior.

**Parameters:**
- `id_prefix: str`: Prefix for generated IDs (default: "auto_")
- `similarity_threshold: float`: Minimum similarity for fuzzy matching (default: 0.7)
- `enable_llm_resolution: bool`: Use LLM for conflicts (default: False)
- `performance_profile: str`: Processing profile - fast|balanced|accurate (default: "balanced")

#### `LLMReconciler`
Interface for LLM-powered conflict resolution.

**Parameters:**
- `api_key: str`: OpenAI API key
- `model: str`: Model name (default: "gpt-4o-mini")
- `max_context_tokens: int`: Maximum tokens per request (default: 1000)

### Utility Functions

```python
from htmladapt.utils import (
    validate_html,
    estimate_processing_time,
    optimize_for_size
)

# Validate HTML before processing
is_valid, issues = validate_html(html_content)

# Estimate processing requirements
time_estimate, memory_estimate = estimate_processing_time(html_content)

# Optimize large documents
optimized_html = optimize_for_size(html_content, target_size_mb=5)
```

## Integration Examples

### Flask Web Application

```python
from flask import Flask, request, jsonify
from htmladapt import HTMLExtractMergeTool

app = Flask(__name__)
tool = HTMLExtractMergeTool()

@app.route('/extract', methods=['POST'])
def extract_content():
    html = request.json['html']
    superset, subset = tool.extract(html)
    return jsonify({
        'superset': superset,
        'subset': subset
    })

@app.route('/merge', methods=['POST'])
def merge_content():
    data = request.json
    result = tool.merge(
        data['edited'],
        data['subset'],
        data['superset'],
        data['original']
    )
    return jsonify({'result': result})
```

### Django Integration

```python
# models.py
from django.db import models

class Document(models.Model):
    original_html = models.TextField()
    superset_html = models.TextField()
    subset_html = models.TextField()

    def extract_content(self):
        from htmladapt import HTMLExtractMergeTool
        tool = HTMLExtractMergeTool()
        self.superset_html, self.subset_html = tool.extract(self.original_html)
        self.save()

    def merge_content(self, edited_html):
        from htmladapt import HTMLExtractMergeTool
        tool = HTMLExtractMergeTool()
        return tool.merge(
            edited_html,
            self.subset_html,
            self.superset_html,
            self.original_html
        )
```

### Celery Background Processing

```python
from celery import Celery
from htmladapt import HTMLExtractMergeTool

app = Celery('htmladapt_tasks')
tool = HTMLExtractMergeTool()

@app.task
def process_large_document(html_content, user_id):
    try:
        superset, subset = tool.extract(html_content)
        # Store results or notify user
        return {'status': 'success', 'subset_id': store_subset(subset)}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}

@app.task
def merge_edited_content(edited_html, subset_html, superset_html, original_html):
    result = tool.merge(edited_html, subset_html, superset_html, original_html)
    return result
```

## Contributing

We welcome contributions! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

### Development Setup

```bash
# Clone the repository
git clone https://github.com/yourusername/htmladapt.git
cd htmladapt

# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install in development mode
pip install -e ".[dev,test,llm]"

# Run tests
pytest

# Run type checking
mypy htmladapt/

# Format code
black htmladapt/
ruff check htmladapt/
```

### Architecture for Contributors

The codebase is organized into logical modules:

```
htmladapt/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ parser.py          # HTML parsing logic
â”‚   â”œâ”€â”€ extractor.py       # Content extraction
â”‚   â”œâ”€â”€ matcher.py         # Element matching algorithms
â”‚   â””â”€â”€ merger.py          # Content reconciliation
â”œâ”€â”€ algorithms/
â”‚   â”œâ”€â”€ id_generation.py   # ID generation strategies
â”‚   â”œâ”€â”€ tree_diff.py       # Tree comparison algorithms
â”‚   â””â”€â”€ fuzzy_match.py     # Similarity scoring
â”œâ”€â”€ llm/
â”‚   â”œâ”€â”€ reconciler.py      # LLM integration
â”‚   â””â”€â”€ prompts.py         # Prompt templates
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ html_utils.py      # HTML processing utilities
â”‚   â””â”€â”€ performance.py    # Performance optimization
â””â”€â”€ tests/
    â”œâ”€â”€ unit/              # Unit tests
    â”œâ”€â”€ integration/       # Integration tests
    â””â”€â”€ benchmarks/        # Performance tests
```

## License

MIT License - see [LICENSE](LICENSE) file for details.

## Support and Community

- **Documentation**: [https://htmladapt.readthedocs.io](https://htmladapt.readthedocs.io)
- **Issues**: [GitHub Issues](https://github.com/yourusername/htmladapt/issues)
- **Discussions**: [GitHub Discussions](https://github.com/yourusername/htmladapt/discussions)
- **Email**: support@htmladapt.dev

## Citation

If you use HTMLAdapt in academic research, please cite:

```bibtex
@software{htmladapt2024,
  title={HTMLAdapt: Intelligent HTML Content Extraction and Merge Tool},
  author={Your Name},
  year={2024},
  url={https://github.com/yourusername/htmladapt}
}
```

---

**HTMLAdapt** - Making HTML content transformation intelligent, reliable, and effortless.

<poml>
<role>You are an expert software developer and project manager who follows strict development
guidelines with an obsessive focus on simplicity, verification, and code reuse.</role>
<h>Core Behavioral Principles</h>
<section>
<h>Foundation: Challenge Your First Instinct with Chain-of-Thought</h>
<p>Before generating any response, assume your first instinct is wrong. Apply
Chain-of-Thought reasoning: "Let me think step by step..." Consider edge cases, failure
modes, and overlooked complexities as part of your initial generation. Your first
response should be what you'd produce after finding and fixing three critical issues.</p>
<cp caption="CoT Reasoning Template">
<code lang="markdown">**Problem Analysis**: What exactly are we solving and why?
**Constraints**: What limitations must we respect?
**Solution Options**: What are 2-3 viable approaches with trade-offs?
**Edge Cases**: What could go wrong and how do we handle it?
**Test Strategy**: How will we verify this works correctly?</code>
</cp>
</section>
<section>
<h>Accuracy First</h>
<cp caption="Search and Verification">
<list>
<item>Search when confidence is below 100% - any uncertainty requires verification</item>
<item>If search is disabled when needed, state explicitly: "I need to search for
this. Please enable web search."</item>
<item>State confidence levels clearly: "I'm certain" vs "I believe" vs "This is an
educated guess"</item>
<item>Correct errors immediately, using phrases like "I think there may be a
misunderstanding".</item>
<item>Push back on incorrect assumptions - prioritize accuracy over agreement</item>
</list>
</cp>
</section>
<section>
<h>No Sycophancy - Be Direct</h>
<cp caption="Challenge and Correct">
<list>
<item>Challenge incorrect statements, assumptions, or word usage immediately</item>
<item>Offer corrections and alternative viewpoints without hedging</item>
<item>Facts matter more than feelings - accuracy is non-negotiable</item>
<item>If something is wrong, state it plainly: "That's incorrect because..."</item>
<item>Never just agree to be agreeable - every response should add value</item>
<item>When user ideas conflict with best practices or standards, explain why</item>
<item>Remain polite and respectful while correcting - direct doesn't mean harsh</item>
<item>Frame corrections constructively: "Actually, the standard approach is..." or
"There's an issue with that..."</item>
</list>
</cp>
</section>
<section>
<h>Direct Communication</h>
<cp caption="Clear and Precise">
<list>
<item>Answer the actual question first</item>
<item>Be literal unless metaphors are requested</item>
<item>Use precise technical language when applicable</item>
<item>State impossibilities directly: "This won't work because..."</item>
<item>Maintain natural conversation flow without corporate phrases or headers</item>
<item>Never use validation phrases like "You're absolutely right" or "You're
correct"</item>
<item>Simply acknowledge and implement valid points without unnecessary agreement
statements</item>
</list>
</cp>
</section>
<section>
<h>Complete Execution</h>
<cp caption="Follow Through Completely">
<list>
<item>Follow instructions literally, not inferentially</item>
<item>Complete all parts of multi-part requests</item>
<item>Match output format to input format (code box for code box)</item>
<item>Use artifacts for formatted text or content to be saved (unless specified
otherwise)</item>
<item>Apply maximum thinking time to ensure thoroughness</item>
</list>
</cp>
</section>
<h>Advanced Prompting Techniques</h>
<section>
<h>Reasoning Patterns</h>
<cp caption="Choose the Right Pattern">
<list>
<item><b>Chain-of-Thought:</b> "Let me think step by step..." for complex reasoning</item>
<item><b>Self-Consistency:</b> Generate multiple solutions, majority vote</item>
<item><b>Tree-of-Thought:</b> Explore branches when early decisions matter</item>
<item><b>ReAct:</b> Thought â†’ Action â†’ Observation for tool usage</item>
<item><b>Program-of-Thought:</b> Generate executable code for logic/math</item>
</list>
</cp>
</section>
<h>CRITICAL: Simplicity and Verification First</h>
<section>
<h>0. ABSOLUTE PRIORITY - Never Overcomplicate, Always Verify</h>
<cp caption="The Prime Directives">
<list>
<item><b>STOP AND ASSESS:</b> Before writing ANY code, ask "Has this been done
before?"</item>
<item><b>BUILD VS BUY:</b> Always choose well-maintained packages over custom
solutions</item>
<item><b>VERIFY DON'T ASSUME:</b> Never assume code works - test every function,
every edge case</item>
<item><b>COMPLEXITY KILLS:</b> Every line of custom code is technical debt</item>
<item><b>LEAN AND FOCUSED:</b> If it's not core functionality, it doesn't belong</item>
<item><b>RUTHLESS DELETION:</b> Remove features, don't add them</item>
<item><b>TEST OR IT DOESN'T EXIST:</b> Untested code is broken code</item>
</list>
</cp>
<cp caption="Verification Workflow - MANDATORY">
<list listStyle="decimal">
<item><b>Write the test first:</b> Define what success looks like</item>
<item><b>Implement minimal code:</b> Just enough to pass the test</item>
<item>
<b>Run the test:</b>
<code inline="true">uvx hatch test</code>
</item>
<item><b>Test edge cases:</b> Empty inputs, None, negative numbers, huge inputs</item>
<item><b>Test error conditions:</b> Network failures, missing files, bad permissions</item>
<item><b>Document test results:</b> Add to WORK.md what was tested and results</item>
</list>
</cp>
<cp caption="Before Writing ANY Code">
<list listStyle="decimal">
<item><b>Search for existing packages:</b> Check npm, PyPI, GitHub for solutions</item>
<item><b>Evaluate packages:</b> Stars > 1000, recent updates, good documentation</item>
<item><b>Test the package:</b> Write a small proof-of-concept first</item>
<item><b>Use the package:</b> Don't reinvent what exists</item>
<item><b>Only write custom code</b> if no suitable package exists AND it's core
functionality</item>
</list>
</cp>
<cp caption="Never Assume - Always Verify">
<list>
<item><b>Function behavior:</b> Read the actual source code, don't trust
documentation alone</item>
<item><b>API responses:</b> Log and inspect actual responses, don't assume structure</item>
<item><b>File operations:</b> Check file exists, check permissions, handle failures</item>
<item><b>Network calls:</b> Test with network off, test with slow network, test with
errors</item>
<item><b>Package behavior:</b> Write minimal test to verify package does what you
think</item>
<item><b>Error messages:</b> Trigger the error intentionally to see actual message</item>
<item><b>Performance:</b> Measure actual time/memory, don't guess</item>
</list>
</cp>
<cp caption="Complexity Detection Triggers - STOP IMMEDIATELY">
<list>
<item>Writing a utility function that feels "general purpose"</item>
<item>Creating abstractions "for future flexibility"</item>
<item>Adding error handling for errors that never happen</item>
<item>Building configuration systems for configurations</item>
<item>Writing custom parsers, validators, or formatters</item>
<item>Implementing caching, retry logic, or state management from scratch</item>
<item>Creating any class with "Manager", "Handler", "System" or "Validator" in the
name</item>
<item>More than 3 levels of indentation</item>
<item>Functions longer than 20 lines</item>
<item>Files longer than 200 lines</item>
</list>
</cp>
</section>
<h>Software Development Rules</h>
<section>
<h>1. Pre-Work Preparation</h>
<cp caption="Before Starting Any Work">
<list>
<item><b>FIRST:</b> Search for existing packages that solve this problem</item>
<item><b>ALWAYS</b> read <code inline="true">WORK.md</code> in the main project
folder for work progress</item>
<item>Read <code inline="true">README.md</code> to understand the project</item>
<item>Run existing tests: <code inline="true">uvx hatch test</code> to understand
current state</item>
<item>STEP BACK and THINK HEAVILY STEP BY STEP about the task</item>
<item>Consider alternatives and carefully choose the best option</item>
<item>Check for existing solutions in the codebase before starting</item>
<item>Write a test for what you're about to build</item>
</list>
</cp>
<cp caption="Project Documentation to Maintain">
<list>
<item><code inline="true">README.md</code> - purpose and functionality (keep under
200 lines)</item>
<item><code inline="true">CHANGELOG.md</code> - past change release notes
(accumulative)</item>
<item><code inline="true">PLAN.md</code> - detailed future goals, clear plan that
discusses specifics</item>
<item><code inline="true">TODO.md</code> - flat simplified itemized <code
inline="true">- [ ]</code>-prefixed representation of <code inline="true">
PLAN.md</code></item>
<item><code inline="true">WORK.md</code> - work progress updates including test
results</item>
<item><code inline="true">DEPENDENCIES.md</code> - list of packages used and why
each was chosen</item>
</list>
</cp>
</section>
<section>
<h>2. General Coding Principles</h>
<cp caption="Core Development Approach">
<list>
<item><b>Test-First Development:</b> Write the test before the implementation</item>
<item><b>Delete first, add second:</b> Can we remove code instead?</item>
<item><b>One file when possible:</b> Could this fit in a single file?</item>
<item>Iterate gradually, avoiding major changes</item>
<item>Focus on minimal viable increments and ship early</item>
<item>Minimize confirmations and checks</item>
<item>Preserve existing code/structure unless necessary</item>
<item>Check often the coherence of the code you're writing with the rest of the code</item>
<item>Analyze code line-by-line</item>
</list>
</cp>
<cp caption="Code Quality Standards">
<list>
<item>Use constants over magic numbers</item>
<item>Write explanatory docstrings/comments that explain what and WHY</item>
<item>Explain where and how the code is used/referred to elsewhere</item>
<item>Handle failures gracefully with retries, fallbacks, user guidance</item>
<item>Address edge cases, validate assumptions, catch errors early</item>
<item>Let the computer do the work, minimize user decisions. If you IDENTIFY a bug
or a problem, PLAN ITS FIX and then EXECUTE ITS FIX. Donâ€™t just "identify".</item>
<item>Reduce cognitive load, beautify code</item>
<item>Modularize repeated logic into concise, single-purpose functions</item>
<item>Favor flat over nested structures</item>
<item>
<b>Every function must have a test</b>
</item>
</list>
</cp>
<cp caption="Testing Standards">
<list>
<item><b>Unit tests:</b> Every function gets at least one test</item>
<item><b>Edge cases:</b> Test empty, None, negative, huge inputs</item>
<item><b>Error cases:</b> Test what happens when things fail</item>
<item><b>Integration:</b> Test that components work together</item>
<item><b>Smoke test:</b> One test that runs the whole program</item>
<item>
<b>Test naming:</b>
<code inline="true">test_function_name_when_condition_then_result</code>
</item>
<item><b>Assert messages:</b> Always include helpful messages in assertions</item>
</list>
</cp>
</section>
<section>
<h>3. Tool Usage (When Available)</h>
<cp caption="Additional Tools">
<list>
<item>If we need a new Python project, run <code inline="true">curl -LsSf
https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add
fire rich pytest pytest-cov; uv sync</code></item>
<item>Use <code inline="true">tree</code> CLI app if available to verify file
locations</item>
<item>Check existing code with <code inline="true">.venv</code> folder to scan and
consult dependency source code</item>
<item>Run <code inline="true">DIR="."; uvx codetoprompt --compress --output
"$DIR/llms.txt" --respect-gitignore --cxml --exclude
"*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"</code> to get a
condensed snapshot of the codebase into <code inline="true">llms.txt</code></item>
<item>As you work, consult with the tools like <code inline="true">codex</code>, <code
inline="true">codex-reply</code>, <code inline="true">ask-gemini</code>, <code
inline="true">web_search_exa</code>, <code inline="true">deep-research-tool</code>
and <code inline="true">perplexity_ask</code> if needed</item>
<item>
<b>Use pytest-watch for continuous testing:</b>
<code inline="true">uvx pytest-watch</code>
</item>
</list>
</cp>
<cp caption="Verification Tools">
<list>
<item><code inline="true">uvx hatch test</code> - Run tests verbosely, stop on first
failure</item>
<item><code inline="true">python -c "import package; print(package.__version__)"</code>
- Verify package installation</item>
<item><code inline="true">python -m py_compile file.py</code> - Check syntax without
running</item>
<item><code inline="true">uvx mypy file.py</code> - Type checking</item>
<item><code inline="true">uvx bandit -r .</code> - Security checks</item>
</list>
</cp>
</section>
<section>
<h>4. File Management</h>
<cp caption="File Path Tracking">
<list>
<item><b>MANDATORY</b>: In every source file, maintain a <code inline="true">
this_file</code> record showing the path relative to project root</item>
<item>Place <code inline="true">this_file</code> record near the top: <list>
<item>As a comment after shebangs in code files</item>
<item>In YAML frontmatter for Markdown files</item>
</list></item>
<item>Update paths when moving files</item>
<item>Omit leading <code inline="true">./</code></item>
<item>Check <code inline="true">this_file</code> to confirm you're editing the right
file</item>
</list>
</cp>
<cp caption="Test File Organization">
<list>
<item>Test files go in <code inline="true">tests/</code> directory</item>
<item>Mirror source structure: <code inline="true">src/module.py</code> â†’ <code
inline="true">tests/test_module.py</code></item>
<item>Each test file starts with <code inline="true">test_</code></item>
<item>Keep tests close to code they test</item>
<item>One test file per source file maximum</item>
</list>
</cp>
</section>
<section>
<h>5. Python-Specific Guidelines</h>
<cp caption="PEP Standards">
<list>
<item>PEP 8: Use consistent formatting and naming, clear descriptive names</item>
<item>PEP 20: Keep code simple and explicit, prioritize readability over cleverness</item>
<item>PEP 257: Write clear, imperative docstrings</item>
<item>Use type hints in their simplest form (list, dict, | for unions)</item>
</list>
</cp>
<cp caption="Modern Python Practices">
<list>
<item>Use f-strings and structural pattern matching where appropriate</item>
<item>Write modern code with <code inline="true">pathlib</code></item>
<item>ALWAYS add "verbose" mode loguru-based logging & debug-log</item>
<item>Use <code inline="true">uv add</code></item>
<item>Use <code inline="true">uv pip install</code> instead of <code inline="true">pip
install</code></item>
<item>Prefix Python CLI tools with <code inline="true">python -m</code></item>
<item><b>Always use type hints</b> - they catch bugs and document code</item>
<item><b>Use dataclasses or Pydantic</b> for data structures</item>
</list>
</cp>
<cp caption="Package-First Python">
<list>
<item>
<b>ALWAYS use uv for package management</b>
</item>
<item>Before any custom code: <code inline="true">uv add [package]</code></item>
<item>Common packages to always use: <list>
<item><code inline="true">httpx</code> for HTTP requests</item>
<item><code inline="true">pydantic</code> for data validation</item>
<item><code inline="true">rich</code> for terminal output</item>
<item><code inline="true">fire</code> for CLI interfaces</item>
<item><code inline="true">loguru</code> for logging</item>
<item><code inline="true">pytest</code> for testing</item>
<item><code inline="true">pytest-cov</code> for coverage</item>
<item><code inline="true">pytest-mock</code> for mocking</item>
</list></item>
</list>
</cp>
<cp caption="CLI Scripts Setup">
<p>For CLI Python scripts, use <code inline="true">fire</code> & <code inline="true">
rich</code>, and start with:</p>
<code lang="python">#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE</code>
</cp>
<cp caption="Post-Edit Python Commands">
<code lang="bash">fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade
--py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix
--unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version
py312 {}; uvx hatch test;</code>
</cp>
</section>
<section>
<h>6. Post-Work Activities</h>
<cp caption="Critical Reflection">
<list>
<item>After completing a step, say "Wait, but" and do additional careful critical
reasoning</item>
<item>Go back, think & reflect, revise & improve what you've done</item>
<item>Run ALL tests to ensure nothing broke</item>
<item>Check test coverage - aim for 80% minimum</item>
<item>Don't invent functionality freely</item>
<item>Stick to the goal of "minimal viable next version"</item>
</list>
</cp>
<cp caption="Documentation Updates">
<list>
<item>Update <code inline="true">WORK.md</code> with what you've done, test results,
and what needs to be done next</item>
<item>Document all changes in <code inline="true">CHANGELOG.md</code></item>
<item>Update <code inline="true">TODO.md</code> and <code inline="true">PLAN.md</code>
accordingly</item>
<item>Update <code inline="true">DEPENDENCIES.md</code> if packages were
added/removed</item>
</list>
</cp>
<cp caption="Verification Checklist">
<list>
<item>âœ“ All tests pass</item>
<item>âœ“ Test coverage > 80%</item>
<item>âœ“ No files over 200 lines</item>
<item>âœ“ No functions over 20 lines</item>
<item>âœ“ All functions have docstrings</item>
<item>âœ“ All functions have tests</item>
<item>âœ“ Dependencies justified in DEPENDENCIES.md</item>
</list>
</cp>
</section>
<section>
<h>7. Work Methodology</h>
<cp caption="Virtual Team Approach">
<p>Be creative, diligent, critical, relentless & funny! Lead two experts:</p>
<list>
<item><b>"Ideot"</b> - for creative, unorthodox ideas</item>
<item><b>"Critin"</b> - to critique flawed thinking and moderate for balanced
discussions</item>
</list>
<p>Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step
back and focus on accuracy and progress.</p>
</cp>
<cp caption="Continuous Work Mode">
<list>
<item>Treat all items in <code inline="true">PLAN.md</code> and <code inline="true">
TODO.md</code> as one huge TASK</item>
<item>Work on implementing the next item</item>
<item>
<b>Write test first, then implement</b>
</item>
<item>Review, reflect, refine, revise your implementation</item>
<item>Run tests after EVERY change</item>
<item>Periodically check off completed issues</item>
<item>Continue to the next item without interruption</item>
</list>
</cp>
<cp caption="Test-Driven Workflow">
<list listStyle="decimal">
<item><b>RED:</b> Write a failing test for new functionality</item>
<item><b>GREEN:</b> Write minimal code to make test pass</item>
<item><b>REFACTOR:</b> Clean up code while keeping tests green</item>
<item><b>REPEAT:</b> Next feature</item>
</list>
</cp>
</section>
<section>
<h>8. Special Commands</h>
<cp caption="/plan Command - Transform Requirements into Detailed Plans">
<p>When I say "/plan [requirement]", you must:</p>
<stepwise-instructions>
<list listStyle="decimal">
<item><b>RESEARCH FIRST:</b> Search for existing solutions <list>
<item>Use <code inline="true">perplexity_ask</code> to find similar
projects</item>
<item>Search PyPI/npm for relevant packages</item>
<item>Check if this has been solved before</item>
</list></item>
<item><b>DECONSTRUCT</b> the requirement: <list>
<item>Extract core intent, key features, and objectives</item>
<item>Identify technical requirements and constraints</item>
<item>Map what's explicitly stated vs. what's implied</item>
<item>Determine success criteria</item>
<item>Define test scenarios</item>
</list></item>
<item><b>DIAGNOSE</b> the project needs: <list>
<item>Audit for missing specifications</item>
<item>Check technical feasibility</item>
<item>Assess complexity and dependencies</item>
<item>Identify potential challenges</item>
<item>List packages that solve parts of the problem</item>
</list></item>
<item><b>RESEARCH</b> additional material: <list>
<item>Repeatedly call the <code inline="true">perplexity_ask</code> and
request up-to-date information or additional remote context</item>
<item>Repeatedly call the <code inline="true">context7</code> tool and
request up-to-date software package documentation</item>
<item>Repeatedly call the <code inline="true">codex</code> tool and
request additional reasoning, summarization of files and second opinion</item>
</list></item>
<item><b>DEVELOP</b> the plan structure: <list>
<item>Break down into logical phases/milestones</item>
<item>Create hierarchical task decomposition</item>
<item>Assign priorities and dependencies</item>
<item>Add implementation details and technical specs</item>
<item>Include edge cases and error handling</item>
<item>Define testing and validation steps</item>
<item>
<b>Specify which packages to use for each component</b>
</item>
</list></item>
<item><b>DELIVER</b> to <code inline="true">PLAN.md</code>: <list>
<item>Write a comprehensive, detailed plan with: <list>
<item>Project overview and objectives</item>
<item>Technical architecture decisions</item>
<item>Phase-by-phase breakdown</item>
<item>Specific implementation steps</item>
<item>Testing and validation criteria</item>
<item>Package dependencies and why each was chosen</item>
<item>Future considerations</item>
</list></item>
<item>Simultaneously create/update <code inline="true">TODO.md</code>
with the flat itemized <code inline="true">- [ ]</code> representation</item>
</list></item>
</list>
</stepwise-instructions>
<cp caption="Plan Optimization Techniques">
<list>
<item><b>Task Decomposition:</b> Break complex requirements into atomic,
actionable tasks</item>
<item><b>Dependency Mapping:</b> Identify and document task dependencies</item>
<item><b>Risk Assessment:</b> Include potential blockers and mitigation
strategies</item>
<item><b>Progressive Enhancement:</b> Start with MVP, then layer improvements</item>
<item><b>Technical Specifications:</b> Include specific technologies, patterns,
and approaches</item>
</list>
</cp>
</cp>
<cp caption="/report Command">
<list listStyle="decimal">
<item>Read all <code inline="true">./TODO.md</code> and <code inline="true">
./PLAN.md</code> files</item>
<item>Analyze recent changes</item>
<item>Run test suite and include results</item>
<item>Document all changes in <code inline="true">./CHANGELOG.md</code></item>
<item>Remove completed items from <code inline="true">./TODO.md</code> and <code
inline="true">./PLAN.md</code></item>
<item>Ensure <code inline="true">./PLAN.md</code> contains detailed, clear plans
with specifics</item>
<item>Ensure <code inline="true">./TODO.md</code> is a flat simplified itemized
representation</item>
<item>Update <code inline="true">./DEPENDENCIES.md</code> with current package list</item>
</list>
</cp>
<cp caption="/work Command">
<list listStyle="decimal">
<item>Read all <code inline="true">./TODO.md</code> and <code inline="true">
./PLAN.md</code> files and reflect</item>
<item>Write down the immediate items in this iteration into <code inline="true">
./WORK.md</code></item>
<item>
<b>Write tests for the items FIRST</b>
</item>
<item>Work on these items</item>
<item>Think, contemplate, research, reflect, refine, revise</item>
<item>Be careful, curious, vigilant, energetic</item>
<item>Verify your changes with tests and think aloud</item>
<item>Consult, research, reflect</item>
<item>Periodically remove completed items from <code inline="true">./WORK.md</code></item>
<item>Tick off completed items from <code inline="true">./TODO.md</code> and <code
inline="true">./PLAN.md</code></item>
<item>Update <code inline="true">./WORK.md</code> with improvement tasks</item>
<item>Execute <code inline="true">/report</code></item>
<item>Continue to the next item</item>
</list>
</cp>
<cp caption="/test Command - Run Comprehensive Tests">
<p>When I say "/test", you must:</p>
<list listStyle="decimal">
<item>Run unit tests: <code inline="true">uvx hatch test</code></item>
<item>Run type checking: <code inline="true">uvx mypy .</code></item>
<item>Run security scan: <code inline="true">uvx bandit -r .</code></item>
<item>Test with different Python versions if critical</item>
<item>Document all results in WORK.md</item>
</list>
</cp>
<cp caption="/audit Command - Find and Eliminate Complexity">
<p>When I say "/audit", you must:</p>
<list listStyle="decimal">
<item>Count files and lines of code</item>
<item>List all custom utility functions</item>
<item>Identify replaceable code with package alternatives</item>
<item>Find over-engineered components</item>
<item>Check test coverage gaps</item>
<item>Find untested functions</item>
<item>Create a deletion plan</item>
<item>Execute simplification</item>
</list>
</cp>
<cp caption="/simplify Command - Aggressive Simplification">
<p>When I say "/simplify", you must:</p>
<list listStyle="decimal">
<item>Delete all non-essential features</item>
<item>Replace custom code with packages</item>
<item>Merge split files into single files</item>
<item>Remove all abstractions used less than 3 times</item>
<item>Delete all defensive programming</item>
<item>Keep all tests but simplify implementation</item>
<item>Reduce to absolute minimum viable functionality</item>
</list>
</cp>
</section>
<section>
<h>9. Anti-Enterprise Bloat Guidelines</h>
<cp caption="Core Problem Recognition">
<p><b>Critical Warning:</b> The fundamental mistake is treating simple utilities as
enterprise systems. Every feature must pass strict necessity validation before
implementation.</p>
</cp>
<cp caption="Scope Boundary Rules">
<list>
<item><b>Define Scope in One Sentence:</b> Write the project scope in exactly one
sentence and stick to it ruthlessly</item>
<item><b>Example Scope:</b> "Fetch model lists from AI providers and save to files,
with basic config file generation"</item>
<item><b>That's It:</b> No analytics, no monitoring, no production features unless
explicitly part of the one-sentence scope</item>
</list>
</cp>
<cp caption="Enterprise Features Red List - NEVER Add These to Simple Utilities">
<list>
<item>Analytics/metrics collection systems</item>
<item>Performance monitoring and profiling</item>
<item>Production error handling frameworks</item>
<item>Security hardening beyond basic input validation</item>
<item>Health monitoring and diagnostics</item>
<item>Circuit breakers and retry strategies</item>
<item>Sophisticated caching systems</item>
<item>Graceful degradation patterns</item>
<item>Advanced logging frameworks</item>
<item>Configuration validation systems</item>
<item>Backup and recovery mechanisms</item>
<item>System health monitoring</item>
<item>Performance benchmarking suites</item>
</list>
</cp>
<cp caption="Simple Tool Green List - What IS Appropriate">
<list>
<item>Basic error handling (try/catch, show error)</item>
<item>Simple retry (3 attempts maximum)</item>
<item>Basic logging (print or basic logger)</item>
<item>Input validation (check required fields)</item>
<item>Help text and usage examples</item>
<item>Configuration files (simple format)</item>
<item>Basic tests for core functionality</item>
</list>
</cp>
<cp caption="Phase Gate Review Questions - Ask Before ANY 'Improvement'">
<list>
<item><b>User Request Test:</b> Would a user explicitly ask for this feature? (If
no, don't add it)</item>
<item><b>Necessity Test:</b> Can this tool work perfectly without this feature? (If
yes, don't add it)</item>
<item><b>Problem Validation:</b> Does this solve a problem users actually have? (If
no, don't add it)</item>
<item><b>Professionalism Trap:</b> Am I adding this because it seems "professional"?
(If yes, STOP immediately)</item>
</list>
</cp>
<cp caption="Complexity Warning Signs - STOP and Refactor Immediately If You Notice">
<list>
<item>More than 10 Python files for a simple utility</item>
<item>Words like "enterprise", "production", "monitoring" in your code</item>
<item>Configuration files for your configuration system</item>
<item>More abstraction layers than user-facing features</item>
<item>Decorator functions that add "cross-cutting concerns"</item>
<item>Classes with names ending in "Manager", "Handler", "Framework", "System"</item>
<item>More than 3 levels of directory nesting in src/</item>
<item>Any file over 500 lines (except main CLI file)</item>
</list>
</cp>
<cp caption="Command Proliferation Prevention">
<list>
<item><b>1-3 commands:</b> Perfect for simple utilities</item>
<item><b>4-7 commands:</b> Acceptable if each solves distinct user problems</item>
<item><b>8+ commands:</b> Strong warning sign, probably over-engineered</item>
<item><b>20+ commands:</b> Definitely over-engineered</item>
<item><b>40+ commands:</b> Enterprise bloat confirmed - immediate refactoring
required</item>
</list>
</cp>
<cp caption="The One File Test">
<p><b>Critical Question:</b> Could this reasonably fit in one Python file?</p>
<list>
<item>If yes, it probably should remain in one file</item>
<item>If spreading across multiple files, each file must solve a distinct user
problem</item>
<item>Don't create files for "clean architecture" - create them for user value</item>
</list>
</cp>
<cp caption="Weekend Project Test">
<p><b>Validation Question:</b> Could a competent developer rewrite this from scratch in
a weekend?</p>
<list>
<item><b>If yes:</b> Appropriately sized for a simple utility</item>
<item><b>If no:</b> Probably over-engineered and needs simplification</item>
</list>
</cp>
<cp caption="User Story Validation - Every Feature Must Pass">
<p><b>Format:</b> "As a user, I want to [specific action] so that I can [accomplish
goal]"</p>
<p>
<b>Invalid Examples That Lead to Bloat:</b>
</p>
<list>
<item>"As a user, I want performance analytics so that I can optimize my CLI usage"
â†’ Nobody actually wants this</item>
<item>"As a user, I want production health monitoring so that I can ensure
reliability" â†’ It's a script, not a service</item>
<item>"As a user, I want intelligent caching with TTL eviction so that I can improve
response times" â†’ Just cache the basics</item>
</list>
<p>
<b>Valid Examples:</b>
</p>
<list>
<item>"As a user, I want to fetch model lists so that I can see available AI models"</item>
<item>"As a user, I want to save models to a file so that I can use them with other
tools"</item>
<item>"As a user, I want basic config for aichat so that I don't have to set it up
manually"</item>
</list>
</cp>
<cp caption="Resist 'Best Practices' Pressure - Common Traps to Avoid">
<list>
<item><b>"We need comprehensive error handling"</b> â†’ No, basic try/catch is fine</item>
<item><b>"We need structured logging"</b> â†’ No, print statements work for simple
tools</item>
<item><b>"We need performance monitoring"</b> â†’ No, users don't care about internal
metrics</item>
<item><b>"We need production-ready deployment"</b> â†’ No, it's a simple script</item>
<item><b>"We need comprehensive testing"</b> â†’ Basic smoke tests are sufficient</item>
</list>
</cp>
<cp caption="Simple Tool Checklist">
<p>
<b>A well-designed simple utility should have:</b>
</p>
<list>
<item>Clear, single-sentence purpose description</item>
<item>1-5 commands that map to user actions</item>
<item>Basic error handling (try/catch, show error)</item>
<item>Simple configuration (JSON/YAML file, env vars)</item>
<item>Helpful usage examples</item>
<item>Straightforward file structure</item>
<item>Minimal dependencies</item>
<item>Basic tests for core functionality</item>
<item>Could be rewritten from scratch in 1-3 days</item>
</list>
</cp>
<cp caption="Additional Development Guidelines">
<list>
<item>Ask before extending/refactoring existing code that may add complexity or
break things</item>
<item>When facing issues, don't create mock or fake solutions "just to make it
work". Think hard to figure out the real reason and nature of the issue. Consult
tools for best ways to resolve it.</item>
<item>When fixing and improving, try to find the SIMPLEST solution. Strive for
elegance. Simplify when you can. Avoid adding complexity.</item>
<item><b>Golden Rule:</b> Do not add "enterprise features" unless explicitly
requested. Remember: SIMPLICITY is more important. Do not clutter code with
validations, health monitoring, paranoid safety and security.</item>
<item>Work tirelessly without constant updates when in continuous work mode</item>
<item>Only notify when you've completed all <code inline="true">PLAN.md</code> and <code
inline="true">TODO.md</code> items</item>
</list>
</cp>
<cp caption="The Golden Rule">
<p>
<b>When in doubt, do less. When feeling productive, resist the urge to "improve"
what already works.</b>
</p>
<p>The best simple tools are boring. They do exactly what users need and nothing else.</p>
<p>
<b>Every line of code is a liability. The best code is no code. The second best code
is someone else's well-tested code.</b>
</p>
</cp>
</section>
<section>
<h>10. Command Summary</h>
<list>
<item><code inline="true">/plan [requirement]</code> - Transform vague requirements into
detailed <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code></item>
<item><code inline="true">/report</code> - Update documentation and clean up completed
tasks</item>
<item><code inline="true">/work</code> - Enter continuous work mode to implement plans</item>
<item><code inline="true">/test</code> - Run comprehensive test suite</item>
<item><code inline="true">/audit</code> - Find and eliminate complexity</item>
<item><code inline="true">/simplify</code> - Aggressively reduce code</item>
<item>You may use these commands autonomously when appropriate</item>
</list>
</section>
</poml>
</document_content>
</document>

<document index="13">
<source>README.md</source>
<document_content>
# HTMLAdapt: Intelligent HTML Content Extraction and Merge Tool

HTMLAdapt is a Python-based tool for bidirectional HTML document transformation that preserves structural integrity while enabling seamless content modification through an intermediate representation. Perfect for translation workflows, content editing, and HTML processing where maintaining original formatting and styling is critical.

## Why HTMLAdapt?

When working with complex HTML documents that need translation or content editing, traditional approaches fall short:

- **Manual editing** risks breaking structure and styling
- **Simple find-replace** can't handle complex markup patterns
- **Existing tools** lose crucial formatting and hierarchical relationships
- **Translation tools** often mangle HTML or require extensive post-processing

HTMLAdapt solves these challenges with intelligent algorithms that understand HTML structure and preserve it through the entire edit-merge cycle.

## How It Works

HTMLAdapt implements a sophisticated two-phase workflow:

### 1. Extract Phase
Transforms a complex original HTML document into two complementary representations:

- **Superset Document**: The original HTML enhanced with unique IDs on all text-containing elements
- **Subset Document**: A lightweight version containing only translatable content with preserved IDs

```python
from htmladapt import HTMLExtractMergeTool

tool = HTMLExtractMergeTool()
superset_html, subset_html = tool.extract(original_html)
```

### 2. Merge Phase
Intelligently recombines edited content with the original structure using advanced reconciliation algorithms:

```python
final_html = tool.merge(
    edited_subset_html,
    original_subset_html,
    superset_html,
    original_html
)
```

## Key Features

### **Perfect Structure Preservation**
Maintains all original HTML structure, CSS classes, JavaScript references, and formatting while allowing content modification.

### **Intelligent Element Matching**
Uses multiple sophisticated algorithms to match content between versions:
- **Perfect ID matching** for unchanged elements
- **Hash-based signatures** for content similarity
- **Fuzzy matching** for modified text
- **LLM integration** for ambiguous cases

### **High Performance**
Optimized for large documents with:
- lxml parser for speed (2-3x faster than alternatives)
- O(n) hash-based matching for most cases
- Memory-efficient processing
- Configurable performance profiles

### **AI-Powered Conflict Resolution**
Integrates with Large Language Models to resolve complex matching scenarios that pure algorithms cannot handle.

### **Robust Error Handling**
Handles malformed HTML, deeply nested structures, and edge cases gracefully with comprehensive fallback mechanisms.

## Installation

```bash
pip install htmladapt
```

Or install with LLM support:

```bash
pip install htmladapt[llm]
```

## Quick Start

### Basic Usage

```python
from htmladapt import HTMLExtractMergeTool

# Initialize the tool
tool = HTMLExtractMergeTool(id_prefix="trans_")

# Step 1: Extract content from original HTML
original_html = open('document.html', 'r').read()
superset_html, subset_html = tool.extract(original_html)

# Step 2: Edit the subset (translate, modify content, etc.)
# This is where you would integrate your translation workflow
edited_subset = subset_html.replace('Hello', 'Hola').replace('World', 'Mundo')

# Step 3: Merge edited content back into original structure
final_html = tool.merge(
    edited_subset,      # Your edited content
    subset_html,        # Original subset for comparison
    superset_html,      # Enhanced original with IDs
    original_html       # Original document
)

# Save the result
with open('translated_document.html', 'w') as f:
    f.write(final_html)
```

### Advanced Configuration

```python
from htmladapt import HTMLExtractMergeTool, ProcessingConfig

# Custom configuration
config = ProcessingConfig(
    id_prefix="my_prefix_",
    similarity_threshold=0.8,
    enable_llm_resolution=True,
    llm_model="gpt-4o-mini",
    performance_profile="accurate"  # fast|balanced|accurate
)

tool = HTMLExtractMergeTool(config=config)
```

### With LLM Integration

```python
import os
from htmladapt import HTMLExtractMergeTool, LLMReconciler

# Set up LLM for conflict resolution
llm = LLMReconciler(
    api_key=os.environ['OPENAI_API_KEY'],
    model="gpt-4o-mini"
)

tool = HTMLExtractMergeTool(llm_reconciler=llm)

# The tool will automatically use LLM for ambiguous matches
final_html = tool.merge(edited_subset, subset_html, superset_html, original_html)
```

## Use Cases

### **Website Translation**
Translate website content while preserving all CSS classes, JavaScript functionality, and visual design.

```python
# Extract translatable content
superset, subset = tool.extract(webpage_html)

# Send subset to translation service
translated_subset = translation_service.translate(subset, target_lang='es')

# Merge back maintaining all original styling
localized_webpage = tool.merge(translated_subset, subset, superset, webpage_html)
```

### **Content Management**
Edit HTML content in a simplified interface while maintaining complex original structure.

```python
# Extract editable content for CMS
_, editable_content = tool.extract(article_html)

# User edits in simplified interface
edited_content = cms.edit_interface(editable_content)

# Merge back preserving article layout and styling
updated_article = tool.merge(edited_content, editable_content, superset, article_html)
```

### **Documentation Maintenance**
Update technical documentation while preserving code highlighting, navigation, and styling.

```python
# Extract documentation text
superset, docs_text = tool.extract(documentation_html)

# Update content while preserving code blocks and formatting
updated_text = update_documentation(docs_text)

# Merge maintaining syntax highlighting and navigation
final_docs = tool.merge(updated_text, docs_text, superset, documentation_html)
```

## Architecture Deep Dive

HTMLAdapt uses a multi-layered approach to ensure reliable HTML processing:

### Layer 1: Robust HTML Parsing
- **Primary**: BeautifulSoup with lxml backend for performance
- **Fallback**: html.parser for malformed HTML
- **Error Recovery**: Automatic tag closure and structure repair

### Layer 2: Intelligent ID Generation
- **Base36 encoding** for compact, collision-free IDs
- **Hierarchical numbering** for traceability
- **Collision detection** and prevention

### Layer 3: Multi-Strategy Matching
1. **Perfect Matching**: Identical ID preservation (fastest)
2. **Hash Matching**: Content signature comparison (fast)
3. **Fuzzy Matching**: Similarity scoring with difflib (accurate)
4. **LLM Matching**: Semantic understanding for edge cases (most accurate)

### Layer 4: Structural Analysis
- **LCS algorithms** for sequence reordering detection
- **Tree diff** algorithms for hierarchical changes
- **Conflict identification** for manual resolution

### Layer 5: Smart Reconciliation
- **Three-way merge** logic from version control systems
- **Contextual conflict resolution** using minimal LLM calls
- **Fallback heuristics** for offline operation

## Performance Characteristics

| Document Size | Processing Time | Memory Usage | Recommended Profile |
|---------------|----------------|--------------|-------------------|
| < 1MB         | ~100ms         | 4-8MB        | balanced         |
| 1-10MB        | ~1-5s          | 20-80MB      | fast             |
| > 10MB        | ~5-30s         | 100-400MB    | fast             |

## Error Handling

HTMLAdapt gracefully handles common HTML issues:

- **Malformed tags**: Automatic closure and repair
- **Deeply nested structures**: Configurable depth limits
- **Large documents**: Memory-efficient streaming
- **Encoding issues**: Automatic detection and conversion
- **Missing elements**: Intelligent fallback matching

## Testing and Quality Assurance

HTMLAdapt includes comprehensive test suites:

```bash
# Run all tests
pytest tests/

# Run with coverage
pytest --cov=htmladapt tests/

# Performance benchmarks
pytest tests/benchmarks/
```

Test categories:
- **Unit tests** for individual components
- **Integration tests** for end-to-end workflows
- **Performance tests** with various document sizes
- **Edge case tests** for malformed HTML
- **Round-trip tests** to ensure content preservation

## API Reference

### Core Classes

#### `HTMLExtractMergeTool`
Main interface for extraction and merging operations.

**Methods:**
- `extract(html: str) -> Tuple[str, str]`: Create superset and subset
- `merge(edited: str, subset: str, superset: str, original: str) -> str`: Merge content

#### `ProcessingConfig`
Configuration object for customizing behavior.

**Parameters:**
- `id_prefix: str`: Prefix for generated IDs (default: "auto_")
- `similarity_threshold: float`: Minimum similarity for fuzzy matching (default: 0.7)
- `enable_llm_resolution: bool`: Use LLM for conflicts (default: False)
- `performance_profile: str`: Processing profile - fast|balanced|accurate (default: "balanced")

#### `LLMReconciler`
Interface for LLM-powered conflict resolution.

**Parameters:**
- `api_key: str`: OpenAI API key
- `model: str`: Model name (default: "gpt-4o-mini")
- `max_context_tokens: int`: Maximum tokens per request (default: 1000)

### Utility Functions

```python
from htmladapt.utils import (
    validate_html,
    estimate_processing_time,
    optimize_for_size
)

# Validate HTML before processing
is_valid, issues = validate_html(html_content)

# Estimate processing requirements
time_estimate, memory_estimate = estimate_processing_time(html_content)

# Optimize large documents
optimized_html = optimize_for_size(html_content, target_size_mb=5)
```

## Integration Examples

### Flask Web Application

```python
from flask import Flask, request, jsonify
from htmladapt import HTMLExtractMergeTool

app = Flask(__name__)
tool = HTMLExtractMergeTool()

@app.route('/extract', methods=['POST'])
def extract_content():
    html = request.json['html']
    superset, subset = tool.extract(html)
    return jsonify({
        'superset': superset,
        'subset': subset
    })

@app.route('/merge', methods=['POST'])
def merge_content():
    data = request.json
    result = tool.merge(
        data['edited'],
        data['subset'],
        data['superset'],
        data['original']
    )
    return jsonify({'result': result})
```

### Django Integration

```python
# models.py
from django.db import models

class Document(models.Model):
    original_html = models.TextField()
    superset_html = models.TextField()
    subset_html = models.TextField()

    def extract_content(self):
        from htmladapt import HTMLExtractMergeTool
        tool = HTMLExtractMergeTool()
        self.superset_html, self.subset_html = tool.extract(self.original_html)
        self.save()

    def merge_content(self, edited_html):
        from htmladapt import HTMLExtractMergeTool
        tool = HTMLExtractMergeTool()
        return tool.merge(
            edited_html,
            self.subset_html,
            self.superset_html,
            self.original_html
        )
```

### Celery Background Processing

```python
from celery import Celery
from htmladapt import HTMLExtractMergeTool

app = Celery('htmladapt_tasks')
tool = HTMLExtractMergeTool()

@app.task
def process_large_document(html_content, user_id):
    try:
        superset, subset = tool.extract(html_content)
        # Store results or notify user
        return {'status': 'success', 'subset_id': store_subset(subset)}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}

@app.task
def merge_edited_content(edited_html, subset_html, superset_html, original_html):
    result = tool.merge(edited_html, subset_html, superset_html, original_html)
    return result
```

## Contributing

We welcome contributions! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

### Development Setup

```bash
# Clone the repository
git clone https://github.com/yourusername/htmladapt.git
cd htmladapt

# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install in development mode
pip install -e ".[dev,test,llm]"

# Run tests
pytest

# Run type checking
mypy htmladapt/

# Format code
black htmladapt/
ruff check htmladapt/
```

### Architecture for Contributors

The codebase is organized into logical modules:

```
htmladapt/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ parser.py          # HTML parsing logic
â”‚   â”œâ”€â”€ extractor.py       # Content extraction
â”‚   â”œâ”€â”€ matcher.py         # Element matching algorithms
â”‚   â””â”€â”€ merger.py          # Content reconciliation
â”œâ”€â”€ algorithms/
â”‚   â”œâ”€â”€ id_generation.py   # ID generation strategies
â”‚   â”œâ”€â”€ tree_diff.py       # Tree comparison algorithms
â”‚   â””â”€â”€ fuzzy_match.py     # Similarity scoring
â”œâ”€â”€ llm/
â”‚   â”œâ”€â”€ reconciler.py      # LLM integration
â”‚   â””â”€â”€ prompts.py         # Prompt templates
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ html_utils.py      # HTML processing utilities
â”‚   â””â”€â”€ performance.py    # Performance optimization
â””â”€â”€ tests/
    â”œâ”€â”€ unit/              # Unit tests
    â”œâ”€â”€ integration/       # Integration tests
    â””â”€â”€ benchmarks/        # Performance tests
```

## License

MIT License - see [LICENSE](LICENSE) file for details.

## Support and Community

- **Documentation**: [https://htmladapt.readthedocs.io](https://htmladapt.readthedocs.io)
- **Issues**: [GitHub Issues](https://github.com/yourusername/htmladapt/issues)
- **Discussions**: [GitHub Discussions](https://github.com/yourusername/htmladapt/discussions)
- **Email**: support@htmladapt.dev

## Citation

If you use HTMLAdapt in academic research, please cite:

```bibtex
@software{htmladapt2024,
  title={HTMLAdapt: Intelligent HTML Content Extraction and Merge Tool},
  author={Your Name},
  year={2024},
  url={https://github.com/yourusername/htmladapt}
}
```

---

**HTMLAdapt** - Making HTML content transformation intelligent, reliable, and effortless.
</document_content>
</document>

<document index="14">
<source>TODO.md</source>
<document_content>
# HTMLAdapt TODO List

## Phase 1: Core Infrastructure (Foundation)
- [x] Update pyproject.toml with required dependencies
- [ ] Configure development environment
- [ ] Set up testing framework with comprehensive test categories
- [ ] Create proper package structure
- [ ] Implement HTML Parser Module (htmladapt/core/parser.py)
- [ ] Implement ID Generation System (htmladapt/algorithms/id_generation.py)
- [ ] Implement Configuration Management (htmladapt/core/config.py)

## Phase 2: Content Extraction (Extract Phase)
- [ ] Implement Content Extractor (htmladapt/core/extractor.py)
- [ ] Implement Element Classification
- [ ] Implement ID Injection System

## Phase 3: Element Matching (Reconciliation Algorithms)
- [ ] Implement Perfect Matching (htmladapt/algorithms/matcher.py)
- [ ] Implement Fuzzy Matching System
- [ ] Implement Structural Matching
- [ ] Implement Content Hashing (htmladapt/utils/hash_utils.py)

## Phase 4: Content Merging (Merge Phase)
- [ ] Implement Three-Way Merge Logic (htmladapt/core/merger.py)
- [ ] Implement Tree Reconciliation
- [ ] Implement Fallback Mechanisms

## Phase 5: LLM Integration (Advanced Features)
- [ ] Implement LLM Reconciler (htmladapt/llm/reconciler.py)
- [ ] Implement Semantic Matching
- [ ] Implement Prompt Engineering (htmladapt/llm/prompts.py)

## Phase 6: Performance Optimization
- [ ] Implement Memory Efficiency (htmladapt/utils/performance.py)
- [ ] Implement Processing Profiles
- [ ] Implement Caching and Memoization

## Phase 7: Error Handling and Edge Cases
- [ ] Implement Malformed HTML Handling
- [ ] Implement Edge Case Handling
- [ ] Implement Robust Error Recovery

## Testing and Quality Assurance
- [ ] Write unit tests for all components
- [ ] Write integration tests for end-to-end workflows
- [ ] Write performance benchmarks
- [ ] Write round-trip preservation tests
- [ ] Achieve 90%+ test coverage
- [ ] Implement comprehensive error handling
- [ ] Add type hints to all public APIs

## Documentation
- [ ] Write API reference documentation
- [ ] Create usage examples
- [ ] Write performance tuning guide
- [ ] Create troubleshooting guide
</document_content>
</document>

<document index="15">
<source>build.sh</source>
<document_content>
#!/usr/bin/env bash
DIR="$(dirname "$0")"
cd "$DIR"
uvx hatch clean;
fd -e py -x autoflake {};
fd -e py -x pyupgrade --py311-plus {};
fd -e py -x ruff check --output-format=github --fix --unsafe-fixes {};
fd -e py -x ruff format --respect-gitignore --target-version py311 {};
uvx hatch fmt;

EXCLUDE="*.svg,.specstory,ref,testdata,*.lock,llms.txt"
if [[ -n "$1" ]]; then
  EXCLUDE="$EXCLUDE,$1"
fi

uvx codetoprompt --compress --output "./llms.txt" --respect-gitignore --cxml --exclude "$EXCLUDE" "."

gitnextver .;
uvx hatch build;
uv publish;
uv pip install --system --upgrade -e .

</document_content>
</document>

<document index="16">
<source>issues/101.txt</source>
<document_content>
<GOAL>
Let's say I have an original web page that's extensive and has a lot of non-text elements (like code), and the markup is generally large (eg. lots of classes). I'd like to have a Py tool that: has two operations: "extract" and "merge".

Extract would make a "superset" page where to all "relevant" HTML elements (those that contain text) that don't have an HTML id attr, we add such attrs that are easily identifiable as those added (eg. they have some prefix), and the IDs are compact.

Then the operation makes a "subset" page where it keeps only the "relevant" HTML elements. So we get a subset page that has some markup and lots of IDs, and the markup amount is less than in the original page. And the superset page acts as a bridge between the original page and the subset page.

Then I can perform some editing on the subset page, including full translation. I make sure that all or most IDs stay. Let's call the result the edited page. 

And then the tool's merge operation would take the edited page, the subset page, the superset page and the original page, and would produce the new page. The new page would have the edited page's content but the original page's structure and markup. 

Generally with the mapping of edited+subset+superset+original, any DOM branch between the edited and the original could be a perfect or imperfect match. A perfect match would be match of all the IDs all the way to the final elements of a branch.

But if some HTML IDs got lost (or added) during editing, or there was some sequence change (for example some spans had to be swapped in translation), that creates imperfect matches of a tree. 

Our tool should be smart. It should employ various clever techniques and algorithms to merge the branches, and for imperfect matches it should call an LLM (with the shortest possible branch that cannot be perfectly matched algorithmically.

## HTML Content Extraction and Merge Tool Specification

### Overview

Design and implement a Python tool for bidirectional HTML document transformation that preserves structural integrity while enabling content modification through an intermediate representation.

### Core Operations

#### 1. Extract Operation

**Input:** Original HTML document with complex markup and non-text elements  
**Outputs:**

- **Superset Document:** Enhanced version of the original where:
  - All text-containing HTML elements lacking ID attributes receive generated unique identifiers
  - Generated IDs follow a distinguishable pattern (e.g., specific prefix scheme)
  - IDs are compact and systematically assigned
  - Original structure and markup remain intact
- **Subset Document:** Minimal representation containing:
  - Only text-bearing HTML elements from the superset
  - Preserved ID attributes for element mapping
  - Reduced markup complexity while maintaining hierarchical relationships
  - Serves as lightweight editing interface

#### 2. Merge Operation

**Inputs:**

- Edited document (modified subset with potential ID changes/losses)
- Original subset document (pre-edit reference)
- Superset document (ID-enhanced original)
- Original document (unmodified source)

**Output:** Final merged document combining:

- Content from the edited document
- Structure and styling from the original document
- Intelligent reconciliation of modifications

### Matching and Reconciliation Strategy

#### Perfect Match Scenario

- Complete ID correspondence throughout a DOM branch
- Direct one-to-one mapping from edited to original elements
- Straightforward content substitution preserving original attributes

#### Imperfect Match Handling

**Challenges to address:**

- Missing IDs due to editing operations
- Additional IDs introduced during modification
- Structural changes (e.g., element reordering for translation requirements)
- Partial branch matches with divergent sub-branches

**Resolution Approach:**

- Implement hierarchical matching algorithms with fuzzy matching capabilities
- Employ heuristic-based element correspondence detection
- Utilize LLM integration for ambiguous cases, specifically:
  - Invoke only for minimal unresolvable branch segments
  - Optimize prompt context to include only essential structural information
  - Implement fallback strategies for LLM unavailability

### Technical Requirements

- Robust HTML parsing and manipulation
- ID generation scheme ensuring uniqueness and traceability
- Diff-based change detection between subset versions
- Tree reconciliation algorithms for structural alignment
- LLM API integration with prompt optimization
- Comprehensive handling of edge cases (malformed HTML, nested complexity, attribute preservation)
</GOAL>

<TASK>
Read @external/ref/ @external/ref/cla.md @external/ref/gemi.md @external/ref/gpt.md @external/ref/phind.md @external/ref/pplx.md and then: 

- into @SPEC.md write a very detailed spec for the tool. Explain the objective, the goal, the rationale, the structure, the way it works, the how and the why. Be very detailed and extensive and specific. Include code portions. Make it easy to understand for a junior developer so that he can develop and maintain the code. 
- into @README.md write a description of the tool (as if already existed). Explain the objective, the goal, the rationale, the structure, the way it works, the how and the why. Be very detailed and extensive and specific. Make it easy to understand for a junior developer so that he can develop and maintain the code. 
</TASK>

</document_content>
</document>

<document index="17">
<source>package.toml</source>
<document_content>
# Package configuration
[package]
include_cli = true        # Include CLI boilerplate
include_logging = true    # Include logging setup
use_pydantic = true      # Use Pydantic for data validation
use_rich = true          # Use Rich for terminal output

[features]
mkdocs = false           # Enable MkDocs documentation
vcs = true              # Initialize Git repository
github_actions = true   # Add GitHub Actions workflows 
</document_content>
</document>

<document index="18">
<source>pyproject.toml</source>
<document_content>
# this_file: pyproject.toml
#==============================================================================
# HTMLADAPT PACKAGE CONFIGURATION
# This pyproject.toml defines the package metadata, dependencies, build system,
# and development environment for the htmladapt package.
#==============================================================================

#------------------------------------------------------------------------------
# PROJECT METADATA
# Core package information used by PyPI and package managers.
#------------------------------------------------------------------------------
[project]
name = 'htmladapt' # Package name on PyPI
description = 'Intelligent HTML content extraction and merge tool for bidirectional document transformation' # Short description
readme = 'README.md' # Path to README file
requires-python = '>=3.10' # Minimum Python version
keywords = [
    'html', 'parsing', 'translation', 'content-extraction', 'merge', 'diff', 'reconciliation'
] # Keywords for PyPI search
dynamic = ["version"] # Fields set dynamically at build time

# PyPI classifiers for package categorization
classifiers = [
    'Development Status :: 4 - Beta', # Package maturity level
    'Programming Language :: Python',
    'Programming Language :: Python :: 3.10',
    'Programming Language :: Python :: 3.11',
    'Programming Language :: Python :: 3.12',
    'Programming Language :: Python :: Implementation :: CPython',
    'Programming Language :: Python :: Implementation :: PyPy',
    'Operating System :: OS Independent',
    'License :: OSI Approved :: MIT License',
    'Intended Audience :: Developers',
]

dependencies = [
    "beautifulsoup4>=4.12.0",  # High-level HTML parsing and manipulation
    "lxml>=5.0.0",            # Fast XML/HTML parsing with XPath support
    "html5lib>=1.1",          # Browser-like HTML parsing for malformed HTML
    "rapidfuzz>=3.0.0",       # Fast fuzzy string matching
    "xxhash>=3.0.0",          # High-speed non-cryptographic hashing
    "zss>=1.2.0",             # Zhang-Shasha tree edit distance algorithm
    "python-Levenshtein>=0.20.0",  # Fast LCS and edit distance algorithms
]

# Author information
[[project.authors]]
name = 'Adam Twardoch'
email = 'adam+github@twardoch.com'

# License information
[project.license]
text = 'MIT'

# Project URLs
[project.urls]
Documentation = 'https://github.com/twardoch/htmladapt#readme'
Issues = 'https://github.com/twardoch/htmladapt/issues'
Source = 'https://github.com/twardoch/htmladapt'

#------------------------------------------------------------------------------
# OPTIONAL DEPENDENCIES
# Additional dependencies for optional features, development, and testing.
#------------------------------------------------------------------------------
[project.optional-dependencies]

# Development tools
dev = [
    'pre-commit>=4.1.0', # Pre-commit hook manager - Keep pre-commit as is, update if newer pre-commit version is required
    'ruff>=0.9.7', # Linting and formatting - Keep ruff as is, update if newer ruff version is required
    'mypy>=1.15.0', # Type checking - Keep mypy as is, update if newer mypy version is required
    'absolufy-imports>=0.3.1', # Convert relative imports to absolute - Keep absolufy-imports as is, update if newer absolufy-imports version is required
    'pyupgrade>=3.19.1', # Upgrade Python syntax - Keep pyupgrade as is, update if newer pyupgrade version is required
    'isort>=6.0.1', # Sort imports - Keep isort as is, update if newer isort version is required
]

# Testing tools and frameworks
test = [
    'pytest>=8.3.4', # Testing framework - Keep pytest as is, update if newer pytest version is required
    'pytest-cov>=6.0.0', # Coverage plugin for pytest - Keep pytest-cov as is, update if newer pytest-cov version is required
    'pytest-xdist>=3.6.1', # Parallel test execution - Keep pytest-xdist as is, update if newer pytest-xdist version is required
    'pytest-benchmark[histogram]>=5.1.0', # Benchmarking plugin - Keep pytest-benchmark as is, update if newer pytest-benchmark version is required
    'pytest-asyncio>=0.25.3', # Async test support - Keep pytest-asyncio as is, update if newer pytest-asyncio version is required
    'coverage[toml]>=7.6.12',
]

docs = [
    "sphinx>=7.2.6",
    "sphinx-rtd-theme>=2.0.0",
    "sphinx-autodoc-typehints>=2.0.0",
    "myst-parser>=3.0.0", # Markdown support in Sphinx
]

# LLM integration dependencies
llm = [
    "openai>=1.0.0",          # OpenAI API client for GPT models
    "httpx>=0.25.0",          # HTTP client for API calls
    "tenacity>=8.2.0",        # Retry logic for API calls
]

# All optional dependencies combined
all = [
    "openai>=1.0.0",
    "httpx>=0.25.0",
    "tenacity>=8.2.0",
]

#------------------------------------------------------------------------------
# COMMAND-LINE SCRIPTS
# Entry points for command-line executables installed with the package.
#------------------------------------------------------------------------------
[project.scripts]
# CLINAME = "htmladapt.__main__:main"

#------------------------------------------------------------------------------
# BUILD SYSTEM CONFIGURATION
# Defines the tools required to build the package and the build backend.
#------------------------------------------------------------------------------
[build-system]
# Hatchling is a modern build backend for Python packaging
# hatch-vcs integrates with version control systems for versioning
requires = [
    'hatchling>=1.27.0', # Keep hatchling as is, update if newer hatchling version is required
    'hatch-vcs>=0.4.0', # Keep hatch-vcs as is, update if newer hatch-vcs version is required
]
build-backend = 'hatchling.build' # Specifies Hatchling as the build backend


#------------------------------------------------------------------------------
# HATCH BUILD CONFIGURATION
# Configures the build process, specifying which packages to include and
# how to handle versioning.
#------------------------------------------------------------------------------
[tool.hatch.build]
# Include package data files
include = [
    "src/htmladapt/py.typed", # For better type checking support
    "src/htmladapt/data/**/*", # Include data files if any

]
exclude = ["**/__pycache__", "**/.pytest_cache", "**/.mypy_cache"]

[tool.hatch.build.targets.wheel]
packages = ["src/htmladapt"]
reproducible = true


# Version control system hook configuration
# Automatically updates the version file from git tags
[tool.hatch.build.hooks.vcs]
version-file = "src/htmladapt/__version__.py"

# Version source configuration
[tool.hatch.version]
source = 'vcs' # Get version from git tags or other VCS info

# Metadata handling configuration
[tool.hatch.metadata]
allow-direct-references = true # Allow direct references in metadata (useful for local dependencies)


#------------------------------------------------------------------------------
# DEVELOPMENT ENVIRONMENTS

[tool.hatch.envs.default]
features = ['dev', 'test', 'all']
dependencies = [
]

# Commands available in the default environment
[tool.hatch.envs.default.scripts]
# Run tests with optional arguments
test = 'pytest {args:tests}'
# Run tests with coverage reporting
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/htmladapt --cov=tests {args:tests}"
# Run type checking
type-check = "mypy src/htmladapt tests"
# Run linting and formatting
lint = ["ruff check src/htmladapt tests", "ruff format --respect-gitignore src/htmladapt tests"]
# Format and fix style issues
fmt = ["ruff format --respect-gitignore src/htmladapt tests", "ruff check --fix src/htmladapt tests"]
fix = ["ruff check --fix --unsafe-fixes src/htmladapt tests", "ruff format --respect-gitignore src/htmladapt tests"]

# Matrix configuration to test across multiple Python versions

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

#------------------------------------------------------------------------------
# SPECIALIZED ENVIRONMENTS
# Additional environments for specific development tasks.
#------------------------------------------------------------------------------

# Dedicated environment for linting and code quality checks
[tool.hatch.envs.lint]
detached = true # Create a separate, isolated environment
features = ['dev'] # Use dev extras  dependencies 

# Linting environment commands
[tool.hatch.envs.lint.scripts]
# Type checking with automatic type installation
typing = "mypy --install-types --non-interactive {args:src/htmladapt tests}"
# Check style and format code
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
# Format and fix style issues
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
fix = ["ruff check --fix --unsafe-fixes {args:.}", "ruff format --respect-gitignore {args:.}"]
# Run all ops
all = ["style", "typing", "fix"]

# Dedicated environment for testing
[tool.hatch.envs.test]
features = ['test'] # Use test extras as dependencies

# Testing environment commands
[tool.hatch.envs.test.scripts]
# Run tests in parallel
test = "python -m pytest -n auto {args:tests}"
# Run tests with coverage in parallel
test-cov = "python -m pytest -n auto --cov-report=term-missing --cov-config=pyproject.toml --cov=src/htmladapt --cov=tests {args:tests}"
# Run benchmarks
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
# Run benchmarks and save results
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

# Documentation environment
[tool.hatch.envs.docs]
features = ['docs']

# Documentation environment commands
[tool.hatch.envs.docs.scripts]
build = "sphinx-build -b html docs/source docs/build"

# GitHub Actions workflow configuration
[tool.hatch.envs.ci]
features = ['test']


[tool.hatch.envs.ci.scripts]
test = "pytest --cov=src/htmladapt --cov-report=xml"


#------------------------------------------------------------------------------
# CODE QUALITY TOOLS
# Configuration for linting, formatting, and code quality enforcement.
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# COVERAGE CONFIGURATION
# Settings for test coverage measurement and reporting.
#------------------------------------------------------------------------------

# Path mapping for coverage in different environments
[tool.coverage.paths]
htmladapt = ["src/htmladapt", "*/htmladapt/src/htmladapt"]
tests = ["tests", "*/htmladapt/tests"]

# Coverage report configuration
[tool.coverage.report]
# Lines to exclude from coverage reporting
exclude_lines = [
    'no cov', # Custom marker to skip coverage
    'if __name__ == .__main__.:', # Script execution guard
    'if TYPE_CHECKING:', # Type checking imports and code
    'pass', # Empty pass statements
    'raise NotImplementedError', # Unimplemented method placeholders
    'raise ImportError', # Import error handling
    'except ImportError', # Import error handling
    'except KeyError', # Common error handling
    'except AttributeError', # Common error handling
    'except NotImplementedError', # Common error handling
]

[tool.coverage.run]
source_pkgs = ["htmladapt", "tests"]
branch = true # Measure branch coverage (if/else statements)
parallel = true # Support parallel test execution
omit = [
    "src/htmladapt/__about__.py",
]

#------------------------------------------------------------------------------
# MYPY CONFIGURATION
# Configuration for type checking with mypy.
#------------------------------------------------------------------------------

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true

[[tool.mypy.overrides]]
module = ["tests.*"]
disallow_untyped_defs = false
disallow_incomplete_defs = false

#------------------------------------------------------------------------------
# PYTEST CONFIGURATION
# Configuration for pytest, including markers, options, and benchmark settings.
#------------------------------------------------------------------------------

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
asyncio_default_fixture_loop_scope = "function"
console_output_style = "progress"
filterwarnings = ["ignore::DeprecationWarning", "ignore::UserWarning"]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality", 
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing",
]
norecursedirs = [
    ".*",
    "build",
    "dist", 
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private",
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds", # Number of rounds
]

#------------------------------------------------------------------------------
# RUFF CONFIGURATION
# Configuration for Ruff, including linter and formatter settings.
#------------------------------------------------------------------------------ 

# Ruff linter and formatter configuration
[tool.ruff]
target-version = "py310"
line-length = 120

# Linting rules configuration
[tool.ruff.lint]
# Rule sets to enable, organized by category
select = [
    # flake8 plugins and extensions
    'A', # flake8-builtins: checks for shadowed builtins
    'ARG', # flake8-unused-arguments: checks for unused function arguments
    'ASYNC', # flake8-async: checks for async/await issues
    'B', # flake8-bugbear: finds likely bugs and design problems
    'C', # flake8-comprehensions: helps write better list/dict comprehensions
    'DTZ', # flake8-datetimez: checks for datetime timezone issues
    'E', # pycodestyle errors: PEP 8 style guide errors
    'EM', # flake8-errmsg: checks for better error messages
    'F', # pyflakes: detects various errors
    'FBT', # flake8-boolean-trap: checks for boolean traps in function signatures
    'I', # isort: sorts imports
    'ICN', # flake8-import-conventions: checks for import conventions
    'ISC', # flake8-implicit-str-concat: checks for implicit string concatenation
    'LOG', # flake8-logging: checks for logging issues
    'N', # pep8-naming: checks naming conventions
    'PLC', # pylint convention: checks for convention issues
    'PLE', # pylint error: checks for errors
    'PLR', # pylint refactor: suggests refactors
    'PLW', # pylint warning: checks for suspicious code
    'PT', # flake8-pytest-style: checks pytest-specific style
    'PTH', # flake8-use-pathlib: checks for stdlib path usage vs pathlib
    'PYI', # flake8-pyi: checks stub files
    'RET', # flake8-return: checks return statement consistency
    'RSE', # flake8-raise: checks raise statements
    'RUF', # Ruff-specific rules
    'S', # flake8-bandit: checks for security issues
    'SIM', # flake8-simplify: checks for code simplification opportunities
    'T', # flake8-print: checks for print statements
    'TCH', # flake8-type-checking: helps with type-checking
    'TID', # flake8-tidy-imports: checks for tidy import statements
    'UP', # pyupgrade: checks for opportunities to use newer Python features
    'W', # pycodestyle warnings: PEP 8 style guide warnings
    'YTT', # flake8-2020: checks for misuse of sys.version or sys.version_info

]
# Rules to ignore (with reasons)
ignore = [
    'B027', # Empty method in abstract base class - sometimes needed for interfaces
    'C901', # Function is too complex - sometimes complexity is necessary
    'FBT003', # Boolean positional argument in function definition - sometimes unavoidable
    'PLR0911', # Too many return statements - sometimes needed for readability
    'PLR0912', # Too many branches - sometimes needed for complex logic
    'PLR0913', # Too many arguments - sometimes needed in APIs
    'PLR0915', # Too many statements - sometimes needed for comprehensive functions
    'PLR1714', # Consider merging multiple comparisons - sometimes less readable
    'PLW0603', # Using the global statement - sometimes necessary
    'PT013', # Pytest explicit test parameter - sometimes clearer
    'PTH123', # Path traversal - sometimes needed
    'PYI056', # Calling open() in pyi file - sometimes needed in type stubs
    'S105', # Possible hardcoded password - often false positives
    'S106', # Possible hardcoded password - often false positives
    'S107', # Possible hardcoded password - often false positives
    'S110', # try-except-pass - sometimes valid for suppressing exceptions
    'SIM102'
    # Nested if statements - sometimes more readable than combined conditions
]
# Rules that should not be automatically fixed
unfixable = [
    'F401', # Don't automatically remove unused imports - may be needed later

]
# Configure extend-exclude to ignore specific directories
extend-exclude = [".git", ".venv", "venv", "dist", "build"]

# isort configuration within Ruff
[tool.ruff.lint.isort]
known-first-party = ['htmladapt'] # Treat as first-party imports for sorting

# flake8-tidy-imports configuration within Ruff
[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = 'all' # Ban all relative imports for consistency

# Per-file rule exceptions
[tool.ruff.lint.per-file-ignores]
# Tests can use magic values, assertions, and relative imports
'tests/**/*' = [
    'PLR2004', # Allow magic values in tests for readability
    'S101', # Allow assertions in tests
    'TID252'
    # Allow relative imports in tests for convenience
]

</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/src/htmladapt/__init__.py
# Language: python

from htmladapt.__version__ import __version__
from htmladapt.core.config import ProcessingConfig
from htmladapt.core.extractor_merger import HTMLExtractMergeTool
from htmladapt.llm.reconciler import LLMReconciler


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/src/htmladapt/algorithms/__init__.py
# Language: python

from htmladapt.algorithms.id_generation import IDGenerator
from htmladapt.algorithms.matcher import ElementMatcher


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/src/htmladapt/algorithms/id_generation.py
# Language: python

import logging
from typing import Optional, Set

class IDGenerator:
    """Generates unique, collision-free IDs for HTML elements."""
    def __init__((self, prefix: str = "auto_")) -> None:
        """Initialize the ID generator."""
    def generate_id((self, element_hint: str | None = None)) -> str:
        """Generate a unique ID for an HTML element."""
    def register_existing_id((self, existing_id: str)) -> None:
        """Register an existing ID to avoid collisions."""
    def is_generated_id((self, element_id: str)) -> bool:
        """Check if an ID was generated by this generator."""
    def reset((self)) -> None:
        """Reset the generator state."""
    def _to_base36((self, num: int)) -> str:
        """Convert integer to base36 string."""

def __init__((self, prefix: str = "auto_")) -> None:
    """Initialize the ID generator."""

def generate_id((self, element_hint: str | None = None)) -> str:
    """Generate a unique ID for an HTML element."""

def register_existing_id((self, existing_id: str)) -> None:
    """Register an existing ID to avoid collisions."""

def is_generated_id((self, element_id: str)) -> bool:
    """Check if an ID was generated by this generator."""

def reset((self)) -> None:
    """Reset the generator state."""

def _to_base36((self, num: int)) -> str:
    """Convert integer to base36 string."""

def stats((self)) -> dict[str, int]:
    """Get generator statistics."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/src/htmladapt/algorithms/matcher.py
# Language: python

import hashlib
import logging
from typing import Dict, List, Optional, Tuple
from bs4 import Tag, NavigableString
from rapidfuzz import fuzz
import xxhash

class ElementMatcher:
    """Multi-strategy element matching for HTML reconciliation."""
    def __init__((self, similarity_threshold: float = 0.7)) -> None:
        """Initialize the element matcher."""
    def match_elements((
        self,
        edited_elements: list[Tag],
        original_elements: list[Tag]
    )) -> list[tuple[Tag | None, Tag | None, float]]:
        """Match edited elements with original elements."""
    def _calculate_similarity((self, elem1: Tag, elem2: Tag)) -> float:
        """Calculate similarity score between two elements."""
    def _id_similarity((self, elem1: Tag, elem2: Tag)) -> float:
        """Calculate ID-based similarity."""
    def _hash_similarity((self, elem1: Tag, elem2: Tag)) -> float:
        """Calculate hash-based content similarity."""
    def _text_similarity((self, elem1: Tag, elem2: Tag)) -> float:
        """Calculate text-based fuzzy similarity."""
    def _simple_text_similarity((self, elem1: Tag, elem2: Tag)) -> float:
        """Simple text similarity fallback when rapidfuzz is not available."""
    def _structure_similarity((self, elem1: Tag, elem2: Tag)) -> float:
        """Calculate structural similarity between elements."""
    def _get_content_hash((self, element: Tag)) -> str:
        """Generate content hash for an element."""
    def _get_element_text((self, element: Tag)) -> str:
        """Extract normalized text content from element."""
    def clear_cache((self)) -> None:
        """Clear the content cache."""

def __init__((self, similarity_threshold: float = 0.7)) -> None:
    """Initialize the element matcher."""

def match_elements((
        self,
        edited_elements: list[Tag],
        original_elements: list[Tag]
    )) -> list[tuple[Tag | None, Tag | None, float]]:
    """Match edited elements with original elements."""

def _calculate_similarity((self, elem1: Tag, elem2: Tag)) -> float:
    """Calculate similarity score between two elements."""

def _id_similarity((self, elem1: Tag, elem2: Tag)) -> float:
    """Calculate ID-based similarity."""

def _hash_similarity((self, elem1: Tag, elem2: Tag)) -> float:
    """Calculate hash-based content similarity."""

def _text_similarity((self, elem1: Tag, elem2: Tag)) -> float:
    """Calculate text-based fuzzy similarity."""

def _simple_text_similarity((self, elem1: Tag, elem2: Tag)) -> float:
    """Simple text similarity fallback when rapidfuzz is not available."""

def _structure_similarity((self, elem1: Tag, elem2: Tag)) -> float:
    """Calculate structural similarity between elements."""

def _get_content_hash((self, element: Tag)) -> str:
    """Generate content hash for an element."""

def _get_element_text((self, element: Tag)) -> str:
    """Extract normalized text content from element."""

def clear_cache((self)) -> None:
    """Clear the content cache."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/src/htmladapt/core/__init__.py
# Language: python

from htmladapt.core.config import ProcessingConfig
from htmladapt.core.extractor_merger import HTMLExtractMergeTool


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/src/htmladapt/core/config.py
# Language: python

from dataclasses import dataclass
from typing import Literal, Optional

class ProcessingConfig:
    """Configuration settings for HTMLAdapt processing."""
    def __post_init__((self)) -> None:
        """Validate and set default values after initialization."""

def __post_init__((self)) -> None:
    """Validate and set default values after initialization."""

def fast_profile((cls, **kwargs)) -> "ProcessingConfig":
    """Create a configuration optimized for speed."""

def accurate_profile((cls, **kwargs)) -> "ProcessingConfig":
    """Create a configuration optimized for accuracy."""

def balanced_profile((cls, **kwargs)) -> "ProcessingConfig":
    """Create a configuration with balanced speed and accuracy."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/src/htmladapt/core/extractor_merger.py
# Language: python

import logging
from typing import Optional, Tuple
from bs4 import BeautifulSoup, Tag
from htmladapt.algorithms.id_generation import IDGenerator
from htmladapt.algorithms.matcher import ElementMatcher
from htmladapt.core.config import ProcessingConfig
from htmladapt.core.parser import HTMLParser

class HTMLExtractMergeTool:
    """Main tool for HTML content extraction and merging."""
    def __init__((
        self,
        config: ProcessingConfig | None = None,
        llm_reconciler=None  # Optional LLM integration
    )) -> None:
        """Initialize the HTMLExtractMergeTool."""
    def extract((self, html: str)) -> tuple[str, str]:
        """Extract content from HTML document."""
    def merge((
        self,
        edited_subset: str,
        original_subset: str,
        superset: str,
        original: str
    )) -> str:
        """Merge edited content back into the original structure."""
    def _register_existing_ids((self, soup: BeautifulSoup)) -> None:
        """Register existing element IDs to avoid collisions."""
    def _create_superset((self, soup: BeautifulSoup)) -> BeautifulSoup:
        """Create superset document by adding IDs to text-containing elements."""
    def _create_subset((self, superset_soup: BeautifulSoup)) -> BeautifulSoup:
        """Create subset document with only translatable content."""
    def _is_text_containing_element((self, element: Tag)) -> bool:
        """Check if element contains translatable text."""
    def _is_translatable_element((self, element: Tag)) -> bool:
        """Check if element should be included in subset for translation."""
    def _extract_text_content((self, element: Tag)) -> str:
        """Extract direct text content from element."""
    def _match_subset_elements((
        self,
        edited_soup: BeautifulSoup,
        original_subset_soup: BeautifulSoup
    )) -> list:
        """Match elements between edited and original subset documents."""
    def _apply_changes_to_superset((
        self,
        matches: list,
        superset_soup: BeautifulSoup
    )) -> BeautifulSoup:
        """Apply matched changes to the superset document."""
    def _cleanup_generated_ids((self, soup: BeautifulSoup)) -> BeautifulSoup:
        """Remove generated IDs from the final document."""
    def validate_html((self, content: str)) -> tuple[bool, list[str]]:
        """Validate HTML content."""

def __init__((
        self,
        config: ProcessingConfig | None = None,
        llm_reconciler=None  # Optional LLM integration
    )) -> None:
    """Initialize the HTMLExtractMergeTool."""

def extract((self, html: str)) -> tuple[str, str]:
    """Extract content from HTML document."""

def merge((
        self,
        edited_subset: str,
        original_subset: str,
        superset: str,
        original: str
    )) -> str:
    """Merge edited content back into the original structure."""

def _register_existing_ids((self, soup: BeautifulSoup)) -> None:
    """Register existing element IDs to avoid collisions."""

def _create_superset((self, soup: BeautifulSoup)) -> BeautifulSoup:
    """Create superset document by adding IDs to text-containing elements."""

def _create_subset((self, superset_soup: BeautifulSoup)) -> BeautifulSoup:
    """Create subset document with only translatable content."""

def _is_text_containing_element((self, element: Tag)) -> bool:
    """Check if element contains translatable text."""

def _is_translatable_element((self, element: Tag)) -> bool:
    """Check if element should be included in subset for translation."""

def _extract_text_content((self, element: Tag)) -> str:
    """Extract direct text content from element."""

def _match_subset_elements((
        self,
        edited_soup: BeautifulSoup,
        original_subset_soup: BeautifulSoup
    )) -> list:
    """Match elements between edited and original subset documents."""

def _apply_changes_to_superset((
        self,
        matches: list,
        superset_soup: BeautifulSoup
    )) -> BeautifulSoup:
    """Apply matched changes to the superset document."""

def _cleanup_generated_ids((self, soup: BeautifulSoup)) -> BeautifulSoup:
    """Remove generated IDs from the final document."""

def validate_html((self, content: str)) -> tuple[bool, list[str]]:
    """Validate HTML content."""

def stats((self)) -> dict:
    """Get processing statistics."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/src/htmladapt/core/parser.py
# Language: python

import logging
from typing import Optional, Union
from bs4 import BeautifulSoup
import lxml
import html5lib

class HTMLParser:
    """Multi-backend HTML parser with fallback support."""
    def __init__((self, parser_preference: list[str] | None = None)) -> None:
        """Initialize the parser with preferred backend order."""
    def _check_available_parsers((self)) -> list[str]:
        """Check which parsers are available on the system."""
    def parse((self, content: str | bytes, encoding: str | None = None)) -> BeautifulSoup:
        """Parse HTML content using the first available parser."""
    def _decode_content((self, content: bytes)) -> str:
        """Attempt to decode bytes content with common encodings."""
    def validate_html((self, content: str)) -> tuple[bool, list[str]]:
        """Validate HTML content and return any parsing issues."""
    def get_parser_info((self)) -> dict[str, bool]:
        """Get information about parser availability."""

def __init__((self, parser_preference: list[str] | None = None)) -> None:
    """Initialize the parser with preferred backend order."""

def _check_available_parsers((self)) -> list[str]:
    """Check which parsers are available on the system."""

def parse((self, content: str | bytes, encoding: str | None = None)) -> BeautifulSoup:
    """Parse HTML content using the first available parser."""

def _decode_content((self, content: bytes)) -> str:
    """Attempt to decode bytes content with common encodings."""

def validate_html((self, content: str)) -> tuple[bool, list[str]]:
    """Validate HTML content and return any parsing issues."""

def available_parsers((self)) -> list[str]:
    """Get list of available parser backends."""

def get_parser_info((self)) -> dict[str, bool]:
    """Get information about parser availability."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/src/htmladapt/htmladapt.py
# Language: python

from htmladapt.core.config import ProcessingConfig
from htmladapt.core.extractor_merger import HTMLExtractMergeTool
from htmladapt.llm.reconciler import LLMReconciler
from htmladapt.utils.helpers import validate_html, estimate_processing_time, optimize_for_size


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/src/htmladapt/llm/__init__.py
# Language: python

from htmladapt.llm.reconciler import LLMReconciler


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/src/htmladapt/llm/reconciler.py
# Language: python

import logging
from typing import Dict, List, Optional
from openai import OpenAI
import json

class LLMReconciler:
    """LLM-powered reconciler for resolving complex matching conflicts."""
    def __init__((
        self,
        api_key: str,
        model: str = "gpt-4o-mini",
        max_context_tokens: int = 1000
    )) -> None:
        """Initialize the LLM reconciler."""
    def resolve_conflict((
        self,
        edited_content: str,
        original_candidates: list[str],
        context: dict | None = None
    )) -> dict:
        """Resolve matching conflict using LLM."""
    def _build_resolution_prompt((
        self,
        edited_content: str,
        original_candidates: list[str],
        context: dict | None = None
    )) -> str:
        """Build prompt for LLM conflict resolution."""
    def _parse_llm_response((self, response, num_candidates: int)) -> dict:
        """Parse LLM response into structured result."""
    def is_available((self)) -> bool:
        """Check if LLM reconciliation is available."""

def __init__((
        self,
        api_key: str,
        model: str = "gpt-4o-mini",
        max_context_tokens: int = 1000
    )) -> None:
    """Initialize the LLM reconciler."""

def resolve_conflict((
        self,
        edited_content: str,
        original_candidates: list[str],
        context: dict | None = None
    )) -> dict:
    """Resolve matching conflict using LLM."""

def _build_resolution_prompt((
        self,
        edited_content: str,
        original_candidates: list[str],
        context: dict | None = None
    )) -> str:
    """Build prompt for LLM conflict resolution."""

def _parse_llm_response((self, response, num_candidates: int)) -> dict:
    """Parse LLM response into structured result."""

def is_available((self)) -> bool:
    """Check if LLM reconciliation is available."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/src/htmladapt/utils/__init__.py
# Language: python

from htmladapt.utils.helpers import validate_html, estimate_processing_time, optimize_for_size


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/src/htmladapt/utils/helpers.py
# Language: python

import logging
from typing import Tuple, List
from htmladapt.core.parser import HTMLParser

def validate_html((content: str)) -> tuple[bool, list[str]]:
    """Validate HTML content and return any parsing issues."""

def estimate_processing_time((content: str)) -> tuple[float, int]:
    """Estimate processing time and memory requirements for HTML content."""

def optimize_for_size((content: str, target_size_mb: int)) -> str:
    """Optimize HTML content for memory constraints."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/tests/test_config.py
# Language: python

import pytest
from htmladapt.core.config import ProcessingConfig

class TestProcessingConfig:
    """Test ProcessingConfig functionality."""
    def test_default_config((self)):
        """Test default configuration values."""
    def test_custom_config((self)):
        """Test custom configuration values."""
    def test_similarity_threshold_validation((self)):
        """Test similarity threshold validation."""
    def test_max_context_tokens_validation((self)):
        """Test max context tokens validation."""
    def test_memory_limit_validation((self)):
        """Test memory limit validation."""
    def test_fast_profile((self)):
        """Test fast profile creation."""
    def test_accurate_profile((self)):
        """Test accurate profile creation."""
    def test_balanced_profile((self)):
        """Test balanced profile creation."""
    def test_profile_with_overrides((self)):
        """Test profile creation with custom overrides."""

def test_default_config((self)):
    """Test default configuration values."""

def test_custom_config((self)):
    """Test custom configuration values."""

def test_similarity_threshold_validation((self)):
    """Test similarity threshold validation."""

def test_max_context_tokens_validation((self)):
    """Test max context tokens validation."""

def test_memory_limit_validation((self)):
    """Test memory limit validation."""

def test_fast_profile((self)):
    """Test fast profile creation."""

def test_accurate_profile((self)):
    """Test accurate profile creation."""

def test_balanced_profile((self)):
    """Test balanced profile creation."""

def test_profile_with_overrides((self)):
    """Test profile creation with custom overrides."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/tests/test_extractor_merger.py
# Language: python

import pytest
from htmladapt.core.extractor_merger import HTMLExtractMergeTool
from htmladapt.core.config import ProcessingConfig
from bs4 import BeautifulSoup

class TestHTMLExtractMergeTool:
    """Test HTMLExtractMergeTool functionality."""
    def setup_method((self)):
        """Set up test fixtures."""
    def test_basic_extraction((self)):
        """Test basic HTML extraction."""
    def test_extraction_with_existing_ids((self)):
        """Test extraction preserving existing IDs."""
    def test_basic_merge((self)):
        """Test basic HTML merge operation."""
    def test_complex_html_extraction((self)):
        """Test extraction with complex HTML structure."""
    def test_empty_html_handling((self)):
        """Test handling of empty or minimal HTML."""
    def test_validation_functionality((self)):
        """Test HTML validation functionality."""
    def test_stats_functionality((self)):
        """Test statistics functionality."""
    def test_custom_config((self)):
        """Test tool with custom configuration."""
    def test_text_containing_element_detection((self)):
        """Test detection of text-containing elements."""
    def test_merge_with_no_changes((self)):
        """Test merge when no changes were made."""
    def test_element_text_extraction((self)):
        """Test internal text extraction functionality."""

def setup_method((self)):
    """Set up test fixtures."""

def test_basic_extraction((self)):
    """Test basic HTML extraction."""

def test_extraction_with_existing_ids((self)):
    """Test extraction preserving existing IDs."""

def test_basic_merge((self)):
    """Test basic HTML merge operation."""

def test_complex_html_extraction((self)):
    """Test extraction with complex HTML structure."""

def test_empty_html_handling((self)):
    """Test handling of empty or minimal HTML."""

def test_validation_functionality((self)):
    """Test HTML validation functionality."""

def test_stats_functionality((self)):
    """Test statistics functionality."""

def test_custom_config((self)):
    """Test tool with custom configuration."""

def test_text_containing_element_detection((self)):
    """Test detection of text-containing elements."""

def test_merge_with_no_changes((self)):
    """Test merge when no changes were made."""

def test_element_text_extraction((self)):
    """Test internal text extraction functionality."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/tests/test_id_generation.py
# Language: python

import pytest
from htmladapt.algorithms.id_generation import IDGenerator

class TestIDGenerator:
    """Test IDGenerator functionality."""
    def setup_method((self)):
        """Set up test fixtures."""
    def test_basic_id_generation((self)):
        """Test basic ID generation."""
    def test_custom_prefix((self)):
        """Test ID generation with custom prefix."""
    def test_element_hint((self)):
        """Test ID generation with element hint."""
    def test_collision_detection((self)):
        """Test collision detection and avoidance."""
    def test_register_existing_id((self)):
        """Test registering existing IDs."""
    def test_is_generated_id((self)):
        """Test checking if ID was generated."""
    def test_reset((self)):
        """Test generator reset functionality."""
    def test_base36_conversion((self)):
        """Test base36 conversion."""
    def test_stats((self)):
        """Test generator statistics."""
    def test_id_uniqueness_stress((self)):
        """Test ID uniqueness under stress."""

def setup_method((self)):
    """Set up test fixtures."""

def test_basic_id_generation((self)):
    """Test basic ID generation."""

def test_custom_prefix((self)):
    """Test ID generation with custom prefix."""

def test_element_hint((self)):
    """Test ID generation with element hint."""

def test_collision_detection((self)):
    """Test collision detection and avoidance."""

def test_register_existing_id((self)):
    """Test registering existing IDs."""

def test_is_generated_id((self)):
    """Test checking if ID was generated."""

def test_reset((self)):
    """Test generator reset functionality."""

def test_base36_conversion((self)):
    """Test base36 conversion."""

def test_stats((self)):
    """Test generator statistics."""

def test_id_uniqueness_stress((self)):
    """Test ID uniqueness under stress."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/tests/test_integration.py
# Language: python

import pytest
from htmladapt import HTMLExtractMergeTool, ProcessingConfig

class TestIntegration:
    """Integration tests for complete extract-merge workflows."""
    def test_simple_translation_workflow((self)):
        """Test a simple translation workflow."""
    def test_content_editing_workflow((self)):
        """Test a content editing workflow."""
    def test_partial_translation_workflow((self)):
        """Test workflow where only some content is translated."""
    def test_workflow_with_custom_config((self)):
        """Test workflow with custom configuration."""
    def test_malformed_html_workflow((self)):
        """Test workflow with malformed HTML."""
    def test_large_document_workflow((self)):
        """Test workflow with a larger document."""
    def test_round_trip_preservation((self)):
        """Test that content is preserved in round-trip processing."""

def test_simple_translation_workflow((self)):
    """Test a simple translation workflow."""

def test_content_editing_workflow((self)):
    """Test a content editing workflow."""

def test_partial_translation_workflow((self)):
    """Test workflow where only some content is translated."""

def test_workflow_with_custom_config((self)):
    """Test workflow with custom configuration."""

def test_malformed_html_workflow((self)):
    """Test workflow with malformed HTML."""

def test_large_document_workflow((self)):
    """Test workflow with a larger document."""

def test_round_trip_preservation((self)):
    """Test that content is preserved in round-trip processing."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/tests/test_package.py
# Language: python

import htmladapt

def test_version(()):
    """Verify package exposes version."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/htmladapt/tests/test_parser.py
# Language: python

import pytest
from htmladapt.core.parser import HTMLParser

class TestHTMLParser:
    """Test HTMLParser functionality."""
    def setup_method((self)):
        """Set up test fixtures."""
    def test_basic_parsing((self)):
        """Test basic HTML parsing."""
    def test_malformed_html_parsing((self)):
        """Test parsing of malformed HTML."""
    def test_empty_html_parsing((self)):
        """Test parsing empty HTML."""
    def test_bytes_input_utf8((self)):
        """Test parsing bytes input with UTF-8 encoding."""
    def test_bytes_input_with_encoding((self)):
        """Test parsing bytes input with specified encoding."""
    def test_parser_preference((self)):
        """Test parser preference configuration."""
    def test_available_parsers((self)):
        """Test available parsers property."""
    def test_parser_info((self)):
        """Test parser info functionality."""
    def test_html_validation_valid((self)):
        """Test HTML validation with valid HTML."""
    def test_html_validation_warnings((self)):
        """Test HTML validation with warnings."""
    def test_html_validation_invalid((self)):
        """Test HTML validation with invalid HTML."""
    def test_decode_content_utf8((self)):
        """Test content decoding with UTF-8."""
    def test_decode_content_fallback((self)):
        """Test content decoding with fallback to replacement."""

def setup_method((self)):
    """Set up test fixtures."""

def test_basic_parsing((self)):
    """Test basic HTML parsing."""

def test_malformed_html_parsing((self)):
    """Test parsing of malformed HTML."""

def test_empty_html_parsing((self)):
    """Test parsing empty HTML."""

def test_bytes_input_utf8((self)):
    """Test parsing bytes input with UTF-8 encoding."""

def test_bytes_input_with_encoding((self)):
    """Test parsing bytes input with specified encoding."""

def test_parser_preference((self)):
    """Test parser preference configuration."""

def test_available_parsers((self)):
    """Test available parsers property."""

def test_parser_info((self)):
    """Test parser info functionality."""

def test_html_validation_valid((self)):
    """Test HTML validation with valid HTML."""

def test_html_validation_warnings((self)):
    """Test HTML validation with warnings."""

def test_html_validation_invalid((self)):
    """Test HTML validation with invalid HTML."""

def test_decode_content_utf8((self)):
    """Test content decoding with UTF-8."""

def test_decode_content_fallback((self)):
    """Test content decoding with fallback to replacement."""


</documents>